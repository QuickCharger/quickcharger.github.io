<!--?xml version="1.0" encoding="UTF-8"?--><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8">
<meta name="generator" content="AsciiDoc 10.1.2">
<title>Bufferevents: advanced topics</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overridden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-M3CEY418LQ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-M3CEY418LQ');
</script>
<style id="translation-style">
      .translate {
        background-color: #f0f0f0; /* 浅灰色背景 */
        color: black;             /* 黑色文本 */
        font-weight: bold;        /* 加粗字体 */
      }
    </style></head>
<body class="article">
<div id="header">
<h1>Bufferevents: advanced topics</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="quoteblock">
<div class="content">
<div class="paragraph"><p>These documents are Copyright (c) 2009-2012 by Nick Mathewson, and are made
available under the Creative Commons Attribution-Noncommercial-Share Alike
license, version 3.0.  Future versions may be made available under a less
restrictive license.</p></div>
<div class="paragraph"><p>Additionally, the source code examples in these documents are also licensed
under the so-called "3-Clause" or "Modified" BSD license. See
<a href="license_bsd.html">the license_bsd file</a> distributed with these documents
for the full terms.</p></div>
<div class="paragraph"><p>To get the source for the latest version of this document, install git
and run "git clone git://github.com/libevent/libevent-book.git"</p></div>
</div>
<div class="attribution">
</div></div>
<div class="paragraph"><p>This chapter describes some advanced features of Libevent’s bufferevent
implementation that aren’t necessary for typical uses.  If you’re just
learning how to use bufferevents, you should skip this chapter for now
and go on to read <a href="Ref7_evbuffer.html">the evbuffer chapter</a>.</p><p class="translate">本章节将介绍Libevent的bufferevent实现中一些高级功能，这些功能对于典型用途来说并不是必需的。如果你刚开始学习如何使用bufferevents，你现在应该跳过这一章，继续阅读evbuffer章节。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_paired_bufferevents">Paired bufferevents</h2>
<div class="sectionbody">
<div class="paragraph"><p>Sometimes you have a networking program that needs to talk to itself.
For example, you could have a program written to tunnel user connections
over some protocol that sometimes also wants to tunnel connections <em>of
its own</em> over that protocol.  You could achieve this by opening a
connection to your own listening port and having your program use
itself, of course, but that would waste resources by having your program
talk to itself via the network stack.</p><p class="translate">有时你的程序需要与自身通信。例如，你的程序，用于通过某种协议隧道化连接用户，有时也希望通过该协议隧道化自己的连接。当然，你可以通过连接到自己的监听端口来实现这一点，但这样会通过网络堆栈让程序与自己通信而浪费资源。</p></div>
<div class="paragraph"><p>Instead, you can create a pair of <em>paired</em> bufferevents such that all bytes
written on one are received on the other (and vice versa), but no actual
platform sockets are used.</p><p class="translate">相反，你可以创建一对配对的bufferevents，这样在一端写入的所有字节都会在另一端接收到（反之亦然），但不使用任何实际的socket。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>int</strong> bufferevent_pair_new(<strong>struct</strong> event_base *base, <strong>int</strong> options,
    <strong>struct</strong> bufferevent *pair[2]);</code></pre>
</div></div>
<div class="paragraph"><p>Calling bufferevent_pair_new() sets pair[0] and pair[1] to a pair of
bufferevents, each connected to the other.  All the usual options are
supported, except for BEV_OPT_CLOSE_ON_FREE, which has no effect, and
BEV_OPT_DEFER_CALLBACKS, which is always on.</p><p class="translate">调用bufferevent_pair_new()会将pair[0]和pair[1]设置为一对bufferevents，每个都连接到另一个。所有常见的选项都支持，除了BEV_OPT_CLOSE_ON_FREE无效，以及BEV_OPT_DEFER_CALLBACKS始终开启。</p></div>
<div class="paragraph"><p>Why do bufferevent pairs need to run with callbacks deferred?  It’s pretty
common for an operation on one element of the pair to invoke a callback that
alters the bufferevent, thus invoking the other bufferevent’s callbacks, and
so on through many steps.  When the callbacks were not deferred, this chain
of calls would pretty frequently overflow the stack, starve other
connections, and require all the callbacks to be reentrant.</p><p class="translate">为什么bufferevent对需要延迟执行回调？在对配对的元素进行操作时，通常会调用一个回调来改变bufferevent，从而调用另一个bufferevent的回调，如此通过许多步骤。当回调没有被延迟时，这一连串的调用会相当频繁地导致栈溢出、饿死其他连接，并且要求所有回调都是可重入的。</p></div>
<div class="paragraph"><p>Paired bufferevents support flushing; setting the mode argument to either
either BEV_NORMAL or BEV_FLUSH forces all the relevant data to get
transferred from one bufferevent in the pair to the other, ignoring the
watermarks that would otherwise restrict it.  Setting mode to BEV_FINISHED
additionally generates an EOF event on the opposite bufferevent.</p><p class="translate">配对的bufferevents支持刷新；将mode参数设置为BEV_NORMAL或BEV_FLUSH会强制将一对bufferevents中的一端的所有相关数据传输到另一端，忽略限制它的watermark。将mode设置为BEV_FINISHED还会在对面的bufferevent上生成一个EOF事件。</p></div>
<div class="paragraph"><p>Freeing either member of the pair <em>does not</em> automatically free the other or
generate an EOF event; it just makes the other member of the pair become
unlinked.  Once the bufferevent is unlinked, it will no longer successfully
read or write data or generate any events.</p><p class="translate">释放任何一个成员不会自动释放另一个或生成EOF事件；它只会使配对中的另一个成员变得未链接。一旦bufferevent未链接，它将不再成功读取或写入数据或生成任何事件。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>struct</strong> bufferevent *bufferevent_pair_get_partner(<strong>struct</strong> bufferevent *bev)</code></pre>
</div></div>
<div class="paragraph"><p>Sometimes you may need to get the other member of a bufferevent pair given
only one member.  To do this, you can invoke the
bufferevent_pair_get_partner() function.  It will return the other member of
the pair if <em>bev</em> is a member of a pair, and the other member still exists.
Otherwise, it returns NULL.</p><p class="translate">有时候，你可能需要通过bufferevent对的一个来获取另一个。为了做到这一点，你可以调用bufferevent_pair_get_partner()函数。如果bev是对成对的，并且另一个成员仍然存在，它会返回对中的另一个成员。否则，它返回NULL。</p></div>
<div class="paragraph"><p>Bufferevent pairs were new in Libevent 2.0.1-alpha; the
bufferevent_pair_get_partner() function was introduced in Libevent 2.0.6.</p><p class="translate">Bufferevent对是在Libevent 2.0.1-alpha中新引入的功能；bufferevent_pair_get_partner()函数则是在Libevent 2.0.6中引入的。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_filtering_bufferevents">Filtering bufferevents</h2>
<div class="sectionbody">
<div class="paragraph"><p>Sometimes you want to transform all the data passing through a bufferevent
object.  You could do this to add a compression layer, or wrap a protocol in
another protocol for transport.</p><p class="translate">有时你想转换通过bufferevent对象传递的所有数据。你可以这样做来添加压缩层，或者封装一个协议。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>enum</strong> bufferevent_filter_result {
        BEV_OK = 0,
        BEV_NEED_MORE = 1,
        BEV_ERROR = 2
};
<strong>typedef</strong> <strong>enum</strong> bufferevent_filter_result (*bufferevent_filter_cb)(
    <strong>struct</strong> evbuffer *source, <strong>struct</strong> evbuffer *destination, ev_ssize_t dst_limit,
    <strong>enum</strong> bufferevent_flush_mode mode, <strong>void</strong> *ctx);


<strong>struct</strong> bufferevent *bufferevent_filter_new(<strong>struct</strong> bufferevent *underlying,
        bufferevent_filter_cb input_filter,
        bufferevent_filter_cb output_filter,
        <strong>int</strong> options,
        <strong>void</strong> (*free_context)(<strong>void</strong> *),
        <strong>void</strong> *ctx);</code></pre>
</div></div>
<div class="paragraph"><p>The bufferevent_filter_new() function creates a new filtering bufferevent,
wrapped around an existing "underlying" bufferevent.  All data received via
the underlying bufferevent is transformed with the "input" filter before
arriving at the filtering bufferevent, and all data sent via the filtering
bufferevent is transformed with an "output" filter before being sent out to
the underlying bufferevent.</p><p class="translate">bufferevent_filter_new()函数创建一个新的过滤bufferevent，围绕一个现有的"底层"bufferevent。通过底层bufferevent接收的所有数据都会在到达过滤bufferevent之前用"输入"过滤器进行转换，通过过滤bufferevent发送的所有数据都会在发送给底层bufferevent之前用一个"输出"过滤器进行转换。</p></div>
<div class="paragraph"><p>Adding a filter to an underlying bufferevent replaces the callbacks on the
underlying bufferevent.  You can still add callbacks to the underlying
bufferevent’s evbuffers, but you can’t set the callbacks on the bufferevent
itself if you want the filter to still work.</p><p class="translate">向底层bufferevent添加过滤器将替换底层bufferevent上的回调。你仍然可以向底层bufferevent的evbuffers添加回调，但如果你希望过滤器仍然工作，你就不能设置bufferevent本身的回调。</p></div>
<div class="paragraph"><p>The <em>input_filter</em> and <em>output_filter</em> functions are described below.
All the usual options are supported in <em>options</em>.  If BEV_OPT_CLOSE_ON_FREE
is set, then freeing the filtering bufferevent also frees the underlying
bufferevent.  The <em>ctx</em> field is an arbitrary pointer passed to the filter
functions; if a <em>free_context</em> function is provided, it is called on <em>ctx</em> just
before the filtering bufferevent is closed.</p><p class="translate">输入过滤器和输出过滤器函数如上所述。所有常见的选项在options中都支持。如果设置了BEV_OPT_CLOSE_ON_FREE，则释放过滤bufferevent也会释放底层bufferevent。ctx字段是传递给过滤函数的任意指针；如果提供了free_context函数，在关闭过滤bufferevent之前将对ctx调用该函数。</p></div>
<div class="paragraph"><p>The input filter function will be called whenever there is new readable data
on the underlying input buffer.  The output filter function is called
whenever there is new writable data on the filter’s output buffer.  Each one
receives a pair of evbuffers: a <em>source</em> evbuffer to read data from, and a
<em>destination</em> evbuffer to write data to.  The <em>dst_limit</em> argument describes
the upper bound of bytes to add to <em>destination</em>.  The filter function is
allowed to ignore this value, but doing so might violate high-water marks
or rate limits.  If <em>dst_limit</em> is -1, there is no limit.  The <em>mode</em>
parameter tells the filter how aggressive to be in writing.  If it is
BEV_NORMAL, then it should write as much as can be conveniently transformed.
The BEV_FLUSH value means to write as much as possible, and BEV_FINISHED
means that the filtering function should additionally do any cleanup
necessary at the end of the stream.  Finally, the filter function’s <em>ctx</em>
argument is a void pointer as provided to the bufferevent_filter_new()
constructor.</p><p class="translate">每当底层输入buffer有新的可读数据时，都会调用输入过滤器函数。每当过滤器的输出buffer有新的可写空间，都会调用输出过滤器函数。每个函数都会接收一对evbuffers：一个源evbuffer来读取数据，一个目的evbuffer来写入数据。dst_limit参数描述了添加到目的地的字节上限。过滤器函数被允许忽略此值，但这样做可能会违反high-water marks或速率限制。如果dst_limit是-1，则没有限制。mode参数告诉过滤器写入时的积极性。如果它是BEV_NORMAL，则它应该写尽可能多的能够方便转换的数据。BEV_FLUSH值意味着要写尽可能多，而BEV_FINISHED意味着过滤器函数还应该在流结束时做任何必要的清理工作。最后，过滤器函数的ctx参数是一个void指针，如同提供给bufferevent_filter_new()构造函数的一样。</p></div>
<div class="paragraph"><p>Filter functions must return BEV_OK if any data was successfully written to
the destination buffer, BEV_NEED_MORE if no more data can be written to the
destination buffer without getting more input or using a different flush
mode, and BEV_ERROR if there is a non-recoverable error on the filter.</p><p class="translate">过滤器函数必须在成功将任何数据写入目的缓冲区时返回BEV_OK，如果没有更多的输入或使用不同的刷新模式就无法将更多数据写入目的缓冲区，则返回BEV_NEED_MORE，如果过滤器上有不可恢复的错误，则返回BEV_ERROR。</p></div>
<div class="paragraph"><p>Creating the filter enables both reading and writing on the underlying
bufferevent.  You do not need to manage reads/writes on your own: the filter
will suspend reading on the underlying bufferevent for you whenever it
doesn’t want to read.  For 2.0.8-rc and later, it is permissible to
enable/disable reading and writing on the underlying bufferevent
independently from the filter.  If you do this, though, you may keep the
filter from successfully getting the data it wants.</p><p class="translate">创建过滤器会在底层bufferevent上启用读写功能。你不需要自己管理读/写：当过滤器不想读取时，它会为你暂停底层bufferevent上的读取。对于2.0.8-rc及之后的版本，允许独立于过滤器启用/禁用底层bufferevent上的读写。但如果你这样做，你可能会阻止过滤器成功获取它想要的数据。</p></div>
<div class="paragraph"><p>You don’t need to specify both an input filter and an output filter: any
filter you omit is replaced with one that passes data on without transforming
it.</p><p class="translate">你不需要指定输入过滤器和输出过滤器：你省略的任何过滤器都会被替换为不转换数据就传递数据的过滤器。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_limiting_maximum_single_read_write_size">Limiting maximum single read/write size</h2>
<div class="sectionbody">
<div class="paragraph"><p>By default, bufferevents won’t read or write the maximum possible amount
of bytes on each invocation of the event loop; doing so can lead to
weird unfair behaviors and resource starvation.  On the other hand, the
defaults might not be reasonable for all situations.</p><p class="translate">默认情况下，bufferevents在每次事件循环的调用中不会读取或写入最大可能的字节数；这样做可能会导致奇怪的不公平行为和资源饥饿。另一方面，默认设置可能并不适用于所有情况。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>int</strong> bufferevent_set_max_single_read(<strong>struct</strong> bufferevent *bev, size_t size);
<strong>int</strong> bufferevent_set_max_single_write(<strong>struct</strong> bufferevent *bev, size_t size);

ev_ssize_t bufferevent_get_max_single_read(<strong>struct</strong> bufferevent *bev);
ev_ssize_t bufferevent_get_max_single_write(<strong>struct</strong> bufferevent *bev);</code></pre>
</div></div>
<div class="paragraph"><p>The two "set" functions replace the current read and write maxima
respectively.  If the <em>size</em> value is 0 or above EV_SSIZE_MAX, they
instead set the maxima to the default value.  These functions return 0
on success and -1 on failure.</p><p class="translate">这两个“set”函数分别替换当前的读取和写入最大值。如果size值为0或超过EV_SSIZE_MAX，它们会将最大值设置为默认值。这些函数在成功时返回0，在失败时返回-1。</p></div>
<div class="paragraph"><p>The two "get" functions return the current per-loop read and write
maxima respectively.</p><p class="translate">这两个“get”函数分别返回当前每次循环的读取和写入最大值。</p></div>
<div class="paragraph"><p>These functions were added in 2.1.1-alpha.</p><p class="translate">这些函数在2.1.1-alpha中被添加。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_bufferevents_and_rate_limiting">Bufferevents and Rate-limiting</h2>
<div class="sectionbody">
<div class="paragraph"><p>Some programs want to limit the amount of bandwidth used for any single
bufferevent, or for a group of bufferevents.  Libevent 2.0.4-alpha and
Libevent 2.0.5-alpha added a basic facility to put caps on individual
bufferevents, or to assign bufferevents to a rate-limited group.</p><p class="translate">一些程序希望限制单个bufferevent或一组bufferevent的带宽。Libevent 2.0.4-alpha和Libevent 2.0.5-alpha增加了一个基本功能，可以对单个bufferevent进行带宽上限限制，或将bufferevent分配到一个速率限制组中。</p></div>
<div class="sect2">
<h3 id="_the_rate_limiting_model">The rate-limiting model</h3>
<div class="paragraph"><p>Libevent’s rate-limiting uses a <em>token bucket</em> algorithm to decide how many
bytes to read or write at a time.  Every rate-limited object, at any given
time, has a "read bucket" and a "write bucket", the sizes of which determine
how many bytes the object is allowed to read or write immediately.  Each
bucket has a refill rate, a maximum burst size, and a
timing unit or "tick".  Whenever the timing unit elapses, the bucket is refilled
proportionally to the refill rate—but if would become fuller than its burst
size, any excess bytes are lost.</p><p class="translate">Libevent的速率限制使用一个令牌桶算法来决定一次读取或写入多少字节。每个速率限制对象在任何给定时间都有一个“读桶”和一个“写桶”，其大小决定了对象可以立即读取或写入多少字节。每个桶都有一个补充率、最大突发大小和一个时间单位或“tick”。每当时间单位过去，桶就会根据补充率按比例补充——但如果桶比其突发大小更满，任何超出的字节都会丢失。</p></div>
<div class="paragraph"><p>Thus, the refill rate determines the maximum average rate at which the object
will send or receive bytes, and the burst size determines the largest number
of bytes that will be sent or received in a single burst.  The timing unit
determines the smoothness of the traffic.</p><p class="translate">因此，补充率决定了对象发送或接收字节的最大平均速率，突发大小决定了在单次突发中将发送或接收的最大字节数。时间单位决定了流量的平滑度。</p></div>
</div>
<div class="sect2">
<h3 id="_setting_a_rate_limit_on_a_bufferevent">Setting a rate limit on a bufferevent</h3>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code>#define EV_RATE_LIMIT_MAX EV_SSIZE_MAX
<strong>struct</strong> ev_token_bucket_cfg;
<strong>struct</strong> ev_token_bucket_cfg *ev_token_bucket_cfg_new(
        size_t read_rate, size_t read_burst,
        size_t write_rate, size_t write_burst,
        <strong>const</strong> <strong>struct</strong> timeval *tick_len);
<strong>void</strong> ev_token_bucket_cfg_free(<strong>struct</strong> ev_token_bucket_cfg *cfg);
<strong>int</strong> bufferevent_set_rate_limit(<strong>struct</strong> bufferevent *bev,
    <strong>struct</strong> ev_token_bucket_cfg *cfg);</code></pre>
</div></div>
<div class="paragraph"><p>An <em>ev_token_bucket_cfg</em> structure represents the configuration values for a
pair of token buckets used to limit reading and writing on a single
bufferevent or group of bufferevents.  To create one, call the
ev_token_bucket_cfg_new function and provide the maximum average read rate, the
maximum read burst, the maximum write rate, the maximum write burst, and the
length of a tick.  If the <em>tick_len</em> argument is NULL, the length of a tick
defaults to one second.  The function may return NULL on error.</p><p class="translate">ev_token_bucket_cfg结构表示用于限制单个bufferevent或一组bufferevent的读写的一对令牌桶的配置值。要创建一个，调用ev_token_bucket_cfg_new函数并提供最大平均读取速率、最大读取突发、最大写入速率、最大写入突发和滴答的长度。如果tick_len参数为NULL，tick的长度默认为一秒。该函数可能在错误时返回NULL。</p></div>
<div class="paragraph"><p>Note that the <em>read_rate</em> and <em>write_rate</em> arguments are scaled in units of
bytes per tick.  That is, if the tick is one tenth of a second, and
<em>read_rate</em> is 300, then the maximum average read rate is 3000 bytes per
second.  Rate and burst values over EV_RATE_LIMIT_MAX are not supported.</p><p class="translate">请注意，read_rate和write_rate参数的单位是每个tick的字节。也就是说，如果tick是十分之一秒，而read_rate是300，那么最大平均读取速率是每秒3000字节。超过EV_RATE_LIMIT_MAX的速率和突发值不受支持。</p></div>
<div class="paragraph"><p>To limit a bufferevent’s transfer rate, call bufferevent_set_rate_limit() on
it with an ev_token_bucket_cfg.  The function returns 0 on success, and -1 on
failure.  You can give any number of bufferevents the same
ev_token_bucket_cfg.  To remove a bufferevent’s rate limits, call
bufferevent_set_rate_limit(), passing NULL for the <em>cfg</em> parameter.</p><p class="translate">要限制bufferevent的传输速率，对其调用bufferevent_set_rate_limit()并使用一个ev_token_bucket_cfg。该函数成功时返回0，失败时返回-1。您可以给任意数量的bufferevent相同的ev_token_bucket_cfg。要移除bufferevent的速率限制，调用bufferevent_set_rate_limit()，并为cfg参数传递NULL。</p></div>
<div class="paragraph"><p>To free an ev_token_bucket_cfg, call ev_token_bucket_cfg_free().  Note that
it is NOT currently safe to do this until no bufferevents are using the
ev_token_bucket_cfg.</p><p class="translate">要释放一个ev_token_bucket_cfg，请调用ev_token_bucket_cfg_free()。请注意，直到没有bufferevent使用ev_token_bucket_cfg时，释放才是安全的。</p></div>
</div>
<div class="sect2">
<h3 id="_setting_a_rate_limit_on_a_group_of_bufferevents">Setting a rate limit on a group of bufferevents</h3>
<div class="paragraph"><p>You can assign bufferevents to a <em>rate limiting group</em> if you want to limit
their total bandwidth usage.</p><p class="translate">如果您想限制它们的总带宽使用量，您可以将bufferevent分配到一个速率限制组中。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>struct</strong> bufferevent_rate_limit_group;

<strong>struct</strong> bufferevent_rate_limit_group *bufferevent_rate_limit_group_new(
        <strong>struct</strong> event_base *base,
        <strong>const</strong> <strong>struct</strong> ev_token_bucket_cfg *cfg);
<strong>int</strong> bufferevent_rate_limit_group_set_cfg(
        <strong>struct</strong> bufferevent_rate_limit_group *group,
        <strong>const</strong> <strong>struct</strong> ev_token_bucket_cfg *cfg);
<strong>void</strong> bufferevent_rate_limit_group_free(<strong>struct</strong> bufferevent_rate_limit_group *);
<strong>int</strong> bufferevent_add_to_rate_limit_group(<strong>struct</strong> bufferevent *bev,
    <strong>struct</strong> bufferevent_rate_limit_group *g);
<strong>int</strong> bufferevent_remove_from_rate_limit_group(<strong>struct</strong> bufferevent *bev);</code></pre>
</div></div>
<div class="paragraph"><p>To construct a rate limiting group, call bufferevent_rate_limit_group() with an
event_base and an initial ev_token_bucket_cfg.  You can add bufferevents to
the group with bufferevent_add_to_rate_limit_group() and
bufferevent_remove_from_rate_limit_group(); these functions return 0 on
success and -1 on error.</p><p class="translate">要构建一个速率限制组，请使用一个event_base和一个初始过的ev_token_bucket_cfg调用bufferevent_rate_limit_group()。您可以通过bufferevent_add_to_rate_limit_group()和bufferevent_remove_from_rate_limit_group()将bufferevent添加到组中或从组中移除；这些函数成功时返回0，错误时返回-1。</p></div>
<div class="paragraph"><p>A single bufferevent can be a member of no more than one rate limiting group
at a time.  A bufferevent can have both an individual rate limit (as set with
bufferevent_set_rate_limit()) and a group rate limit.  When both limits are
set, the lower limit for each bufferevent applies.</p><p class="translate">单个bufferevent一次只能是一个速率限制组的成员。一个bufferevent可以同时有独立的速率限制（如通过bufferevent_set_rate_limit()设置）和组速率限制。当两个限制都设置时，bufferevent适用较低的限制。</p></div>
<div class="paragraph"><p>You can change the rate limit for an existing group by calling
bufferevent_rate_limit_group_set_cfg().  It returns 0 on success and -1 on
failure.  The bufferevent_rate_limit_group_free() function frees a rate limit
group and removes all of its members.</p><p class="translate">您可以通过调用bufferevent_rate_limit_group_set_cfg()来更改现有组的速率限制。它成功时返回0，失败时返回-1。bufferevent_rate_limit_group_free()函数释放一个速率限制组并移除其所有成员。</p></div>
<div class="paragraph"><p>As of version 2.0, Libevent’s group rate limiting tries to be fair on
aggregate, but the implementation can be unfair on very small timescales.  If
you care strongly about scheduling fairness, please help out
with patches for future versions.</p><p class="translate">截至2.0版，Libevent的组速率限制试图在总体上公平，但在非常小的时间尺度上实现可能不公平。如果您非常关心调度公平性，请通过补丁帮助未来版本。</p></div>
</div>
<div class="sect2">
<h3 id="_inspecting_current_rate_limit_values">Inspecting current rate-limit values</h3>
<div class="paragraph"><p>Sometimes your code may want to inspect the current rate limits that apply
for a given bufferevent or group.  Libevent provides some functions to do so.</p><p class="translate">有时您的代码可能想检查bufferevent或组的当前速率限制。Libevent提供了一些函数来做到这一点。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code>ev_ssize_t bufferevent_get_read_limit(<strong>struct</strong> bufferevent *bev);
ev_ssize_t bufferevent_get_write_limit(<strong>struct</strong> bufferevent *bev);
ev_ssize_t bufferevent_rate_limit_group_get_read_limit(
        <strong>struct</strong> bufferevent_rate_limit_group *);
ev_ssize_t bufferevent_rate_limit_group_get_write_limit(
        <strong>struct</strong> bufferevent_rate_limit_group *);</code></pre>
</div></div>
<div class="paragraph"><p>The above functions return the current size, in bytes, of a bufferevent’s or
a group’s read or write token buckets.  Note that these values can be
negative if a bufferevent has been forced to exceed its allocations.
(Flushing the bufferevent can do this.)</p><p class="translate">上述函数返回bufferevent或组的读或写令牌桶的当前大小，单位是字节。请注意，如果bufferevent被迫超出其分配，则这些值可以是负数。（刷新bufferevent可以做到这一点。）</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code>ev_ssize_t bufferevent_get_max_to_read(<strong>struct</strong> bufferevent *bev);
ev_ssize_t bufferevent_get_max_to_write(<strong>struct</strong> bufferevent *bev);</code></pre>
</div></div>
<div class="paragraph"><p>These functions return the number of bytes that a bufferevent would be
willing to read or write right now, taking into account any rate limits that
apply to the bufferevent, its rate limiting group (if any), and any
maximum-to-read/write-at-a-time values imposed by Libevent as a whole.</p><p class="translate">这些函数返回bufferevent现在愿意读取或写入的字节数，考虑到适用于bufferevent、其速率限制组（如果有的话），以及Libevent作为一个整体的任何最大一次读取/写入值。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>void</strong> bufferevent_rate_limit_group_get_totals(
    <strong>struct</strong> bufferevent_rate_limit_group *grp,
    ev_uint64_t *total_read_out, ev_uint64_t *total_written_out);
<strong>void</strong> bufferevent_rate_limit_group_reset_totals(
    <strong>struct</strong> bufferevent_rate_limit_group *grp);</code></pre>
</div></div>
<div class="paragraph"><p>Each bufferevent_rate_limit_group tracks the total number of bytes sent over
it, in total.  You can use this to track total usage by a number of
bufferevents in the group.   Calling
bufferevent_rate_limit_group_get_totals() on a group sets *<em>total_read_out</em>
and *<em>total_written_out</em> to the total number of bytes read and written on a
bufferevent group respectively.  These totals start at 0 when the group is
created, and reset to 0 whenever bufferevent_rate_limit_group_reset_totals()
is called on a group.</p><p class="translate">每个bufferevent_rate_limit_group跟踪它发送的总字节数。您可以使用此功能来跟踪组中多个bufferevent的总使用量。在组上调用bufferevent_rate_limit_group_get_totals()会将*total_read_out和*total_written_out设置为分别在bufferevent组上读取和写入的总字节数。这些总数在创建组时从0开始，并且每当在一个组上调用bufferevent_rate_limit_group_reset_totals()时重置为0。</p></div>
</div>
<div class="sect2">
<h3 id="_manually_adjusting_rate_limits">Manually adjusting rate limits</h3>
<div class="paragraph"><p>For programs with really complex needs, you might want to adjust the current
values of a token bucket.  You might want to do this, for example, if your
program is generating traffic in some way that isn’t via a bufferevent.</p><p class="translate">对于复杂需求的程序，您可能希望调整令牌桶的值。例如，如果您的程序以不通过bufferevent的方式生成流量。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>int</strong> bufferevent_decrement_read_limit(<strong>struct</strong> bufferevent *bev, ev_ssize_t decr);
<strong>int</strong> bufferevent_decrement_write_limit(<strong>struct</strong> bufferevent *bev, ev_ssize_t decr);
<strong>int</strong> bufferevent_rate_limit_group_decrement_read(
        <strong>struct</strong> bufferevent_rate_limit_group *grp, ev_ssize_t decr);
<strong>int</strong> bufferevent_rate_limit_group_decrement_write(
        <strong>struct</strong> bufferevent_rate_limit_group *grp, ev_ssize_t decr);</code></pre>
</div></div>
<div class="paragraph"><p>These functions decrement a current read or write bucket in a bufferevent or
rate limiting group.  Note that the decrements are signed: if you want to
increment a bucket, pass a negative value.</p><p class="translate">这些功能减少了bufferevent或速率限制组中当前的读或写桶。请注意，递减是有符号的：如果您想增加一个桶，请传递一个负值。</p></div>
</div>
<div class="sect2">
<h3 id="_setting_the_smallest_share_possible_in_a_rate_limited_group">Setting the smallest share possible in a rate-limited group</h3>
<div class="paragraph"><p>Frequently, you don’t want to divide the bytes available in a rate-limiting
group up evenly among all bufferevents in every tick.  For example, if you
had 10,000 active bufferevents in a rate-limiting group with 10,000 bytes
available for writing every tick, it wouldn’t be efficient to let each
bufferevent write only 1 byte per tick, due to the overheads of system calls
and TCP headers.</p><p class="translate">通常，您不希望在速率限制组中给所有bufferevent平均分配速率。例如，如果您有10,000个活跃的bufferevent在一个速率限制组中，每个tick有10,000字节可用于写入，由于系统调用和TCP头部的开销，让每个bufferevent每个tick只写1字节是不高效的。</p></div>
<div class="paragraph"><p>To solve this, each rate-limiting group has a notion of its "minimum share".
In the situation above, instead of every bufferevent being allowed to write 1
byte per tick, 10,000/SHARE bufferevents will be allowed to write SHARE bytes
each every tick, and the rest will be allowed to write nothing.  Which
bufferevents are allowed to write first is chosen randomly each tick.</p><p class="translate">为了解决这个问题，每个速率限制组都有一个“最小份额”的概念。在上述情况下，不是每个bufferevent每个tick都被允许写入1字节，而是10,000/SHARE的bufferevent被允许每个tick写入SHARE字节，其余的则不允许写入。每个tick中首先允许哪些bufferevent写入是随机选择的。</p></div>
<div class="paragraph"><p>The default minimum share is chosen to give decent performance, and is
currently (as of 2.0.6-rc) set to 64. You can adjust this value with the
following function:</p><p class="translate">默认的最小份额是为了提供良好的性能，并且目前（截至2.0.6-rc）设置为64。您可以使用以下函数调整这个值：</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>int</strong> bufferevent_rate_limit_group_set_min_share(
        <strong>struct</strong> bufferevent_rate_limit_group *group, size_t min_share);</code></pre>
</div></div>
<div class="paragraph"><p>Setting the min_share to 0 disables the minimum-share code entirely.</p><p class="translate">将min_share设置为0将完全禁用最小份额。</p></div>
<div class="paragraph"><p>Libevent’s rate-limiting has had minimum shares since it was first
introduced.  The function to change them was first exposed in Libevent
2.0.6-rc.</p><p class="translate">Libevent的速率限制自引入以来就有最小份额。更改它们的函数是在Libevent 2.0.6-rc首次公开的。</p></div>
</div>
<div class="sect2">
<h3 id="_limitations_of_the_rate_limiting_implementation">Limitations of the rate-limiting implementation</h3>
<div class="paragraph"><p>As of Libevent 2.0, there are some limitations to the rate-limiting
implementation that you should know.</p></div>
<div class="ulist"><ul>
<li>
<p>
Not every bufferevent type supports rate limiting well, or at all.
</p>
</li>
<li>
<p>
Bufferevent rate limiting groups cannot nest, and a bufferevent can only be
  in a single rate limiting group at a time.
</p>
</li>
<li>
<p>
The rate limiting implementation only counts bytes transferred in TCP
  packets as data, doesn’t include TCP headers.
</p>
</li>
<li>
<p>
The read-limiting implementation relies on the TCP stack noticing that the
  application is only consuming data at a certain rate, and pushing back on
  the other side of the TCP connection when its buffers get full.
</p>
</li>
<li>
<p>
Some implementations of bufferevents (particularly the windows IOCP
  implementation) can over-commit.
</p>
</li>
<li>
<p>
Buckets start out with one full tick’s worth of traffic.  This means that a
  bufferevent can start reading or writing immediately, and not wait until a
  full tick has passed.  It also means, though, that a bufferevent that has
  been rate limited for N.1 ticks can potentially transfer N+1 ticks worth of
  traffic.
</p>
</li>
<li>
<p>
Ticks cannot be smaller than 1 millisecond, and all fractions of a
  millisecond are ignored.
</p><p class="translate">截至Libevent 2.0版，您应该知道速率限制实现有一些局限性。<br>- 并非每一种bufferevent类型都能很好地或完全支持速率限制。<br>- Bufferevent速率限制组不能嵌套，且一个bufferevent一次只能在一个速率限制组中。<br>- 速率限制实现仅将TCP数据包中传输的字节计为数据，不包括TCP头部。<br>- 读取限制实现依赖于TCP堆栈，应用程序仅以特定速率消费数据，并在其缓冲区变满时对TCP连接的另一侧施加压力。<br>- 某些bufferevents实现（特别是Windows IOCP实现）可能会超额。<br>- 桶在开始时有一个完整tick流量。这意味着bufferevent可以立即开始读取或写入，而不必等待完整的tick通过。然而，这也意味着，一个已经被限制为N.1 tick的bufferevent可以潜在地传输N+1 tick的流量。<br>- tick不能小于1毫秒，所有小于1毫秒的分数都会被忽略。</p>
</li>
</ul></div>
<div class="paragraph"><p>/// TODO: Write an example for rate-limiting</p><p class="translate">/// todo：写一个关于速率限制的示例</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_bufferevents_and_ssl">Bufferevents and SSL</h2>
<div class="sectionbody">
<div class="paragraph"><p>Bufferevents can use the OpenSSL library to implement the SSL/TLS secure
transport layer.  Because many applications don’t need or want to link
OpenSSL, this functionality is implemented in a separate library installed as
"libevent_openssl".  Future versions of Libevent could add support for other
SSL/TLS libraries such as NSS or GnuTLS, but right now OpenSSL is all that’s
there.</p><p class="translate">bufferevent 可以使用OpenSSL库来实现SSL/TLS安全传输层。因为许多应用程序不需要或不想链接OpenSSL，这个功能被实现在一个独立的库中，安装时称为"libevent_openssl"。未来的Libevent版本可能会增加对其他SSL/TLS库如NSS或GnuTLS的支持，但现在只有OpenSSL。</p></div>
<div class="paragraph"><p>OpenSSL functionality was introduced in Libevent 2.0.3-alpha, though it didn’t
work so well before Libevent 2.0.5-beta or Libevent 2.0.6-rc.</p><p class="translate">在Libevent 2.0.3-alpha中引入了OpenSSL功能，尽管在Libevent 2.0.5-beta或Libevent 2.0.6-rc之前它的工作表现并不理想。</p></div>
<div class="paragraph"><p>This section is not a tutorial on OpenSSL, SSL/TLS, or cryptography in general.</p><p class="translate">本节不是关于OpenSSL，SSL/TLS或一般加密技术的教程。</p></div>
<div class="paragraph"><p>These functions are all declared in the header "event2/bufferevent_ssl.h".</p><p class="translate">这些函数都在头文件"event2/bufferevent_ssl.h"中声明。</p></div>
<div class="sect2">
<h3 id="_setting_up_and_using_an_openssl_based_bufferevent">Setting up and using an OpenSSL-based bufferevent</h3>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>enum</strong> bufferevent_ssl_state {
        BUFFEREVENT_SSL_OPEN = 0,
        BUFFEREVENT_SSL_CONNECTING = 1,
        BUFFEREVENT_SSL_ACCEPTING = 2
};

<strong>struct</strong> bufferevent *
bufferevent_openssl_filter_new(<strong>struct</strong> event_base *base,
    <strong>struct</strong> bufferevent *underlying,
    SSL *ssl,
    <strong>enum</strong> bufferevent_ssl_state state,
    <strong>int</strong> options);

<strong>struct</strong> bufferevent *
bufferevent_openssl_socket_new(<strong>struct</strong> event_base *base,
    evutil_socket_t fd,
    SSL *ssl,
    <strong>enum</strong> bufferevent_ssl_state state,
    <strong>int</strong> options);</code></pre>
</div></div>
<div class="paragraph"><p>You can create two kinds of SSL bufferevents: a filter-based bufferevent that
communicates over another underlying bufferevent, or a socket-based
bufferevent that tells OpenSSL to communicate with the network directly over.  In
either case, you must provide an SSL object and a description of the SSL
object’s state.  The state should be BUFFEREVENT_SSL_CONNECTING if the SSL is
currently performing negotiation as a client, BUFFEREVENT_SSL_ACCEPTING
if the SSL is currently performing negotiation as a server, or
BUFFEREVENT_SSL_OPEN if the SSL handshake is done.</p><p class="translate">你可以创建两种类型的SSL bufferevent：一种基于过滤器的bufferevent，通过另一个底层bufferevent进行通信，或者是一个基于socket的bufferevent，告诉OpenSSL直接通过网络进行通信。在任何一种情况下，你都必须提供一个SSL对象和对SSL对象状态的描述。如果SSL当前作为客户端进行协商，则状态应为BUFFEREVENT_SSL_CONNECTING；如果SSL当前作为服务器，则为BUFFEREVENT_SSL_ACCEPTING；或者如果SSL握手已完成，则为BUFFEREVENT_SSL_OPEN。</p></div>
<div class="paragraph"><p>The usual options are accepted; BEV_OPT_CLOSE_ON_FREE makes the SSL object
and the underlying fd or bufferevent get closed when the openssl bufferevent
itself is closed.</p><p class="translate">通常的选项：BEV_OPT_CLOSE_ON_FREE使得SSL对象和底层的fd或bufferevent在openssl bufferevent本身关闭时被关闭。</p></div>
<div class="paragraph"><p>Once the handshake is complete, the new bufferevent’s event callback gets invoked
with BEV_EVENT_CONNECTED in flags.</p><p class="translate">一旦握手完成，新的bufferevent的事件回调将被调用，并在标志中带有BEV_EVENT_CONNECTED。</p></div>
<div class="paragraph"><p>If you’re creating a socket-based bufferevent and the SSL object already
has a socket set, you do not need to provide the socket yourself: just pass
-1.  You can also set the fd later with bufferevent_setfd().</p><p class="translate">如果你正在创建一个基于socket的bufferevent，并且SSL对象已经设置了一个socket，你不需要自己提供套接字：只需传递-1。你也可以稍后用bufferevent_setfd()设置fd。</p></div>
<div class="paragraph"><p>/// TODO: Remove this once bufferevent_shutdown() API has been finished.</p><p class="translate">/// TODO：一旦bufferevent_shutdown() API完成后删除此项。</p></div>
<div class="paragraph"><p>Note that when BEV_OPT_CLOSE_ON_FREE is set on a SSL bufferevent,
a clean shutdown will not be performed on the SSL connection.  This has two
problems: first, the connection will seem to have been "broken" by the other
side, rather than having been closed cleanly: the other party will not be
able to tell whether you closed the connection, or whether it was broken
by an attacker or third party.  Second, OpenSSL will treat
the session as "bad", and removed from the session cache. This
can cause significant performance degradation on SSL applications under load.</p><p class="translate">请注意，当在SSL bufferevent上设置了BEV_OPT_CLOSE_ON_FREE时，SSL连接上不会执行干净的关闭。这有两个问题：首先，连接会看起来像是被对方"断开"的，而不是被干净地关闭：对方将无法判断是你关闭了连接，还是它被攻击者或第三方破坏了。其次，OpenSSL会将会话视为"坏的"，并从会话缓存中移除。这可能会在负载下的SSL应用程序上造成显著的性能下降。</p></div>
<div class="paragraph"><p>Currently the only workaround is to do lazy SSL shutdowns manually. While this
breaks the TLS RFC, it will make sure that sessions will stay in
cache once closed. The following code implements this workaround.</p><p class="translate">目前唯一的解决方法是手动进行懒惰的SSL关闭。虽然这违反了TLS RFC，但它将确保一旦关闭，会话将保留在缓存中。以下代码实现了这种解决方法。</p></div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre><code>SSL *ctx = bufferevent_openssl_get_ssl(bev);

<i>/*</i>
<i> * SSL_RECEIVED_SHUTDOWN tells SSL_shutdown to act as if we had already</i>
<i> * received a close notify from the other end.  SSL_shutdown will then</i>
<i> * send the final close notify in reply.  The other end will receive the</i>
<i> * close notify and send theirs.  By this time, we will have already</i>
<i> * closed the socket and the other end's real close notify will never be</i>
<i> * received.  In effect, both sides will think that they have completed a</i>
<i> * clean shutdown and keep their sessions valid.  This strategy will fail</i>
<i> * if the socket is not ready for writing, in which case this hack will</i>
<i> * lead to an unclean shutdown and lost session on the other end.</i>
<i> */</i>
SSL_set_shutdown(ctx, SSL_RECEIVED_SHUTDOWN);
SSL_shutdown(ctx);
bufferevent_free(bev);</code></pre>
</div></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code>SSL *bufferevent_openssl_get_ssl(<strong>struct</strong> bufferevent *bev);</code></pre>
</div></div>
<div class="paragraph"><p>This function returns the SSL object used by an OpenSSL bufferevent, or NULL
if <em>bev</em> is not an OpenSSL-based bufferevent.</p><p class="translate">这个函数返回由OpenSSL bufferevent使用的SSL对象，如果bev不是基于OpenSSL的bufferevent，则返回NULL。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>unsigned</strong> <strong>long</strong> bufferevent_get_openssl_error(<strong>struct</strong> bufferevent *bev);</code></pre>
</div></div>
<div class="paragraph"><p>This function returns the first pending OpenSSL error for a given
bufferevent’s operations, or 0 if there was no pending error.  The error
format is as returned by ERR_get_error() in the openssl library.</p><p class="translate">这个函数返回给定bufferevent操作的第一个挂起的OpenSSL错误，如果没有挂起错误，则返回0。错误格式与openssl库中的ERR_get_error()返回的格式相同。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>int</strong> bufferevent_ssl_renegotiate(<strong>struct</strong> bufferevent *bev);</code></pre>
</div></div>
<div class="paragraph"><p>Calling this function tells the SSL to renegotiate, and the bufferevent to
invoke appropriate callbacks.  This is an advanced topic; you should
generally avoid it unless you really know what you’re doing, especially since
many SSL versions have had known security issues related to
renegotiation.</p><p class="translate">调用这个函数告诉SSL重新协商，并且bufferevent调用相应的回调。这是一个高级主题；除非你真的知道你在做什么，通常应该避免它，尤其是因为许多SSL版本已知存在与重新协商相关的安全问题。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>int</strong> bufferevent_openssl_get_allow_dirty_shutdown(<strong>struct</strong> bufferevent *bev);
<strong>void</strong> bufferevent_openssl_set_allow_dirty_shutdown(<strong>struct</strong> bufferevent *bev,
    <strong>int</strong> allow_dirty_shutdown);</code></pre>
</div></div>
<div class="paragraph"><p>All good versions of the SSL protocol (that is, SSLv3 and all TLS
versions) support an authenticated shutdown operation that enables the
parties to distinguish an intentional close from an accidental or
maliciously induced termination in the underling buffer.  By default, we
treat anything besides a proper shutdown as an error on the connection.
If the allow_dirty_shutdown flag is set to 1, however, we treat a close
in the connection as a BEV_EVENT_EOF.</p><p class="translate">优秀的SSL版本（即SSLv3和所有TLS版本）都支持经过验证的关闭操作，它使得双方能够区分有意的关闭和意外或恶意引起的底层缓冲终止。默认情况下，我们将除了正确的关闭之外的任何事情视为连接上的错误。然而，如果将allow_dirty_shutdown标志设置为1，我们将在连接中的关闭视为BEV_EVENT_EOF。</p></div>
<div class="paragraph"><p>The allow_dirty_shutdown functions were added in Libevent 2.1.1-alpha.</p><p class="translate">allow_dirty_shutdown函数在Libevent 2.1.1-alpha中被添加。</p></div>
<div class="listingblock">
<div class="title">Example: A simple SSL-based echo server</div>
<div class="content">
<pre><code><i>/* Simple echo server using OpenSSL bufferevents */</i>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;

#include &lt;openssl/ssl.h&gt;
#include &lt;openssl/err.h&gt;
#include &lt;openssl/rand.h&gt;

#include &lt;event.h&gt;
#include &lt;event2/listener.h&gt;
#include &lt;event2/bufferevent_ssl.h&gt;

<strong>static</strong> <strong>void</strong>
ssl_readcb(<strong>struct</strong> bufferevent * bev, <strong>void</strong> * arg)
{
    <strong>struct</strong> evbuffer *in = bufferevent_get_input(bev);

    printf("Received %zu bytes\n", evbuffer_get_length(in));
    printf("----- data ----\n");
    printf("%.*s\n", (<strong>int</strong>)evbuffer_get_length(in), evbuffer_pullup(in, -1));

    bufferevent_write_buffer(bev, in);
}

<strong>static</strong> <strong>void</strong>
ssl_acceptcb(<strong>struct</strong> evconnlistener *serv, <strong>int</strong> sock, <strong>struct</strong> sockaddr *sa,
             <strong>int</strong> sa_len, <strong>void</strong> *arg)
{
    <strong>struct</strong> event_base *evbase;
    <strong>struct</strong> bufferevent *bev;
    SSL_CTX *server_ctx;
    SSL *client_ctx;

    server_ctx = (SSL_CTX *)arg;
    client_ctx = SSL_new(server_ctx);
    evbase = evconnlistener_get_base(serv);

    bev = bufferevent_openssl_socket_new(evbase, sock, client_ctx,
                                         BUFFEREVENT_SSL_ACCEPTING,
                                         BEV_OPT_CLOSE_ON_FREE);

    bufferevent_enable(bev, EV_READ);
    bufferevent_setcb(bev, ssl_readcb, NULL, NULL, NULL);
}

<strong>static</strong> SSL_CTX *
evssl_init(<strong>void</strong>)
{
    SSL_CTX  *server_ctx;

<i>    /* Initialize the OpenSSL library */</i>
    SSL_load_error_strings();
    SSL_library_init();
<i>    /* We MUST have entropy, or else there's no point to crypto. */</i>
    <strong>if</strong> (!RAND_poll())
        <strong>return</strong> NULL;

    server_ctx = SSL_CTX_new(SSLv23_server_method());

    <strong>if</strong> (! SSL_CTX_use_certificate_chain_file(server_ctx, "cert") ||
        ! SSL_CTX_use_PrivateKey_file(server_ctx, "pkey", SSL_FILETYPE_PEM)) {
        puts("Couldn't read 'pkey' or 'cert' file.  To generate a key\n"
           "and self-<strong>signed</strong> certificate, run:\n"
           "  openssl genrsa -out pkey 2048\n"
           "  openssl req -<strong>new</strong> -key pkey -out cert.req\n"
           "  openssl x509 -req -days 365 -in cert.req -signkey pkey -out cert");
        <strong>return</strong> NULL;
    }
    SSL_CTX_set_options(server_ctx, SSL_OP_NO_SSLv2);

    <strong>return</strong> server_ctx;
}

<strong>int</strong>
main(<strong>int</strong> argc, <strong>char</strong> **argv)
{
    SSL_CTX *ctx;
    <strong>struct</strong> evconnlistener *listener;
    <strong>struct</strong> event_base *evbase;
    <strong>struct</strong> sockaddr_in sin;

    memset(&amp;sin, 0, <strong>sizeof</strong>(sin));
    sin.sin_family = AF_INET;
    sin.sin_port = htons(9999);
    sin.sin_addr.s_addr = htonl(0x7f000001); /* 127.0.0.1 */

    ctx = evssl_init();
    <strong>if</strong> (ctx == NULL)
        <strong>return</strong> 1;
    evbase = event_base_new();
    listener = evconnlistener_new_bind(
                         evbase, ssl_acceptcb, (<strong>void</strong> *)ctx,
                         LEV_OPT_CLOSE_ON_FREE | LEV_OPT_REUSEABLE, 1024,
                         (<strong>struct</strong> sockaddr *)&amp;sin, <strong>sizeof</strong>(sin));

    event_base_loop(evbase, 0);

    evconnlistener_free(listener);
    SSL_CTX_free(ctx);

    <strong>return</strong> 0;
}</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_some_notes_on_threading_and_openssl">Some notes on threading and OpenSSL</h3>
<div class="paragraph"><p>The built in threading mechanisms of Libevent do not cover OpenSSL locking.
Since OpenSSL uses a myriad of global variables, you must still configure
OpenSSL to be thread safe. While this process is outside the scope of Libevent,
this topic comes up enough to warrant discussion.</p><p class="translate">Libevent的内置线程机制不覆盖OpenSSL锁。由于OpenSSL使用了大量的全局变量，你仍然必须配置OpenSSL以确保线程安全。虽然这个过程不在Libevent的范围内，但这个话题被足够多地提及，值得进行讨论。</p></div>
<div class="listingblock">
<div class="title">Example: A very simple example of how to enable thread safe OpenSSL</div>
<div class="content">
<pre><code><i>/*</i>
<i> * Please refer to OpenSSL documentation to verify you are doing this correctly,</i>
<i> * Libevent does not guarantee this code is the complete picture, but to be used</i>
<i> * only as an example.</i>
<i> */</i>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &lt;pthread.h&gt;
#include &lt;openssl/ssl.h&gt;
#include &lt;openssl/crypto.h&gt;

pthread_mutex_t * ssl_locks;
<strong>int</strong> ssl_num_locks;

#ifndef WIN32
#define _SSLtid (<strong>unsigned</strong> <strong>long</strong>)pthread_self()
#<strong>else</strong>
#define _SSLtid pthread_self().p
#endif

<i>/* Implements a thread-ID function as requied by openssl */</i>
#<strong>if</strong> OPENSSL_VERSION_NUMBER &lt; 0x10000000L
<strong>static</strong> <strong>unsigned</strong> <strong>long</strong>
get_thread_id_cb(<strong>void</strong>)
{
    <strong>return</strong> _SSLtid;
}

#<strong>else</strong>

<strong>static</strong> <strong>void</strong>
get_thread_id_cb(CRYPTO_THREADID *id)
{
    CRYPTO_THREADID_set_numeric(id, _SSLtid);
}
#endif

<strong>static</strong> <strong>void</strong>
thread_lock_cb(<strong>int</strong> mode, <strong>int</strong> which, <strong>const</strong> <strong>char</strong> * f, <strong>int</strong> l)
{
    <strong>if</strong> (which &lt; ssl_num_locks) {
        <strong>if</strong> (mode &amp; CRYPTO_LOCK) {
            pthread_mutex_lock(&amp;(ssl_locks[which]));
        } <strong>else</strong> {
            pthread_mutex_unlock(&amp;(ssl_locks[which]));
        }
    }
}

<strong>int</strong>
init_ssl_locking(<strong>void</strong>)
{
    <strong>int</strong> i;

    ssl_num_locks = CRYPTO_num_locks();
    ssl_locks = malloc(ssl_num_locks * <strong>sizeof</strong>(pthread_mutex_t));
    <strong>if</strong> (ssl_locks == NULL)
        <strong>return</strong> -1;

    <strong>for</strong> (i = 0; i &lt; ssl_num_locks; i++) {
        pthread_mutex_init(&amp;(ssl_locks[i]), NULL);
    }


#<strong>if</strong> OPENSSL_VERSION_NUMBER &lt; 0x10000000L
    CRYPTO_set_id_callback(get_thread_id_cb);
#<strong>else</strong>
    CRYPTO_THREADID_set_callback(get_thread_id_cb);
#endif

    CRYPTO_set_locking_callback(thread_lock_cb);

    <strong>return</strong> 0;
}</code></pre>
</div></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr></div>
<div id="footer">
<div id="footer-text">
Last updated
 2024-02-18 20:10:44 UTC
</div>
</div>


</body></html>