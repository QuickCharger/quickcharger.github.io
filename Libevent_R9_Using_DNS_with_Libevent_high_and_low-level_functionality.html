<!--?xml version="1.0" encoding="UTF-8"?--><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8">
<meta name="generator" content="AsciiDoc 10.1.2">
<title>Using DNS with Libevent: high and low-level functionality</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overridden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-M3CEY418LQ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-M3CEY418LQ');
</script>
<style id="translation-style">
      .translate {
        background-color: #f0f0f0; /* 浅灰色背景 */
        color: black;             /* 黑色文本 */
        font-weight: bold;        /* 加粗字体 */
      }
    </style></head>
<body class="article">
<div id="header">
<h1>Using DNS with Libevent: high and low-level functionality</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="quoteblock">
<div class="content">
<div class="paragraph"><p>These documents are Copyright (c) 2009-2012 by Nick Mathewson, and are made
available under the Creative Commons Attribution-Noncommercial-Share Alike
license, version 3.0.  Future versions may be made available under a less
restrictive license.</p></div>
<div class="paragraph"><p>Additionally, the source code examples in these documents are also licensed
under the so-called "3-Clause" or "Modified" BSD license. See
<a href="license_bsd.html">the license_bsd file</a> distributed with these documents
for the full terms.</p></div>
<div class="paragraph"><p>To get the source for the latest version of this document, install git
and run "git clone git://github.com/libevent/libevent-book.git"</p></div>
</div>
<div class="attribution">
</div></div>
<div class="paragraph"><p>Libevent provides a few APIs to use for resolving DNS names, and a
facility for implementing simple DNS servers.</p><p class="translate">Libevent 提供了一些用于解析 DNS 名称的 API，以及用于实现简单 DNS 服务器的实现。 设施 -&gt; 实现</p></div>
<div class="paragraph"><p>We’ll start by describing the higher-level facilities for name lookup,
and then describe the low-level and server facilities.</p><p class="translate">我们将首先描述用于名称查找的高级实现，然后描述底层和服务器实现。</p></div>
<div class="paragraph"><div class="title">Note</div><p>There are known limitations in Libevent’s current DNS client implementation.
It doesn’t support TCP lookups, DNSSec, or arbitrary record types.  We’d like
to fix all of these in some future version of Libevent, but for now, they’re
not there.</p><p class="translate">Libevent 当前 DNS 客户端实现中存在已知的局限性。它不支持 TCP 查找、DNSSec 或任意记录类型。我们希望在 Libevent 的未来版本中修复所有这些问题，但就目前而言，这些功能还未实现。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_preliminaries_portable_blocking_name_resolution">Preliminaries: Portable blocking name resolution</h2>
<div class="sectionbody">
<div class="paragraph"><p>To aid in porting programs that already use blocking name resolution,
Libevent provides a portable implementation of the standard
getaddrinfo() interface.  This can be helpful when your program needs to
run on platforms where either there is no getaddrinfo() function, or
where getaddrinfo() doesn’t conform to the standard as well as our
replacement.  (There are shockingly many of each.)</p><p class="translate">为了帮助那些已经使用阻塞式名称解析的程序进行移植，Libevent 提供了一个标准 getaddrinfo() 接口的可移植实现。这在你的程序需要在没有 getaddrinfo() 函数的平台上运行，或者平台上的 getaddrinfo() 函数不符合标准的情况下很有帮助。（令人震惊的是这样的情况很多。）</p></div>
<div class="paragraph"><p>The getaddrinfo() interface is specified in RFC 3493, section 6.1.  See
the "Compatibility Notes" section below for a summary of how we fall
short of a conformant implemenation.</p><p class="translate">getaddrinfo() 接口在 RFC 3493 的第 6.1 节中有规定。请参阅下面的“Compatibility Notes”部分，了解我们与符合标准实现的差距。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>struct</strong> evutil_addrinfo {
    <strong>int</strong> ai_flags;
    <strong>int</strong> ai_family;
    <strong>int</strong> ai_socktype;
    <strong>int</strong> ai_protocol;
    size_t ai_addrlen;
    <strong>char</strong> *ai_canonname;
    <strong>struct</strong> sockaddr *ai_addr;
    <strong>struct</strong> evutil_addrinfo *ai_next;
};

#define EVUTIL_AI_PASSIVE     /* ... */
#define EVUTIL_AI_CANONNAME   /* ... */
#define EVUTIL_AI_NUMERICHOST /* ... */
#define EVUTIL_AI_NUMERICSERV /* ... */
#define EVUTIL_AI_V4MAPPED    /* ... */
#define EVUTIL_AI_ALL         /* ... */
#define EVUTIL_AI_ADDRCONFIG  /* ... */

<strong>int</strong> evutil_getaddrinfo(<strong>const</strong> <strong>char</strong> *nodename, <strong>const</strong> <strong>char</strong> *servname,
    <strong>const</strong> <strong>struct</strong> evutil_addrinfo *hints, <strong>struct</strong> evutil_addrinfo **res);
<strong>void</strong> evutil_freeaddrinfo(<strong>struct</strong> evutil_addrinfo *ai);
<strong>const</strong> <strong>char</strong> *evutil_gai_strerror(<strong>int</strong> err);</code></pre>
</div></div>
<div class="paragraph"><p>The evutil_getaddrinfo() function tries to resolve the provided nodename
and servname fields, according to the rules you give it in <em>hints</em>, and
build you a linked list of evutil_addrinfo structures and store them in
*res.  It returns 0 on success, and a nonzero error code on failure.</p><p class="translate">evutil_getaddrinfo() 函数试图根据你在 hints 中给出的规则解析提供的 nodename 和 servname 字段，并为你构建一个 evutil_addrinfo 结构的链表，并将它们存储在 *res 中。成功时返回 0，失败时返回非零错误代码。</p></div>
<div class="paragraph"><p>You must provide at least one of <em>nodename</em> and <em>servname</em>.  If
<em>nodename</em> is provided, it is either a literal IPv4 address (like
"127.0.0.1"), a literal IPv6 address (like "::1"), or a DNS name (like
"www.example.com").  If <em>servname</em> is provided, it is either the
symbolic name of a network service (like "https") or a string containing
a port number given in decimal (like "443").</p><p class="translate">你必须至少提供 nodename 和 servname 中的一个。如果提供了 nodename，它可以是一个字面的 IPv4 地址（如 "127.0.0.1"）、一个字面的 IPv6 地址（如 "::1"）或一个 DNS 名称（如 "www.example.com"）。如果提供了 servname，它可以是网络服务的符号名称（如 "https"）或包含十进制端口号的字符串（如 "443"）。</p></div>
<div class="paragraph"><p>If you do not specify <em>servname</em>, then the port values in *res will be
set to zero.  If you do not specify <em>nodename</em>, then the addresses in
*res will either be for localhost (by default), or for "any" (if
EVUTIL_AI_PASSIVE is set.)</p><p class="translate">如果你没有指定 servname，那么 *res 中的端口值将被设置为零。如果你没有指定 nodename，那么 *res 中的地址要么是 localhost（默认情况下），要么是“any”（如果设置了 EVUTIL_AI_PASSIVE）。</p></div>
<div class="paragraph"><p>The ai_flags field of <em>hints</em> tells evutil_getaddrinfo how to perform
the lookup.  It can contain zero or more of the flags below, ORed together.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
EVUTIL_AI_PASSIVE
</dt>
<dd>
<p>
        This flag indicates that we’re going to be using the address
        for listening, not for connection.  Ordinarily this makes
        no difference, except when <em>nodename</em> is NULL: for connecting,
        a NULL nodename is localhost (127.0.0.1 or ::1), whereas when
        listening, a NULL node name is ANY (0.0.0.0 or ::0).
</p>
</dd>
<dt class="hdlist1">
EVUTIL_AI_CANONNAME
</dt>
<dd>
<p>
        If this flag is set, we try to report the canonical name for the
        host in the ai_canonname field.
</p>
</dd>
<dt class="hdlist1">
EVUTIL_AI_NUMERICHOST
</dt>
<dd>
<p>
        When this flag is set, we only resolve numeric IPv4 and IPv6
        addresses; if the <em>nodename</em> would require a name lookup,
        we instead give an EVUTIL_EAI_NONAME error.
</p>
</dd>
<dt class="hdlist1">
EVUTIL_AI_NUMERICSERV
</dt>
<dd>
<p>
        When this flag is set, we only resolve numeric service names.
        If the <em>servname</em> is neither NULL nor a decimal integer,
        give an EVUTIL_EAI_NONAME error.
</p>
</dd>
<dt class="hdlist1">
EVUTIL_AI_V4MAPPED
</dt>
<dd>
<p>
        This flag indicates that if ai_family is AF_INET6, and no IPv6
        addresses are found, any IPv4 addresses in the result should be
        returned as v4-mapped IPv6 addresses.  It is not currently
        supported by evutil_getaddrinfo() unless the OS supports it.
</p>
</dd>
<dt class="hdlist1">
EVUTIL_AI_ALL
</dt>
<dd>
<p>
        If this flag and EVUTIL_AI_V4MAPPED are both set, then IPv4
        addresses in the result included in the result as 4-mapped IPv6
        addresses, whether there are any IPv6 addresses or not.  It is
        not currently supported by evutil_getaddrinfo() unless the OS
        supports it.
</p>
</dd>
<dt class="hdlist1">
EVUTIL_AI_ADDRCONFIG
</dt>
<dd>
<p>
        If this flag is set, then IPv4 addresses are only included in
        the result if the system has a nonlocal IPv4 address, and IPv6
        addresses are only included in the result if the system has a
        nonlocal IPv6 address.
</p><p class="translate">hints 中的 ai_flags 字段告诉 evutil_getaddrinfo 如何执行查找。它可以包含下面列出的一个或多个标志，通过 OR 运算组合在一起。</p><hr>EVUTIL_AI_PASSIVE<hr>  这个标志表明我们将使用地址进行监听，而不是用于连接。通常这没有什么区别，除非 nodename 为NULL：对于连接，空的 nodename 是 localhost（127.0.0.1 或 ::1），而监听时，空的 nodename 是 ANY（0.0.0.0 或 ::0）。<hr>EVUTIL_AI_CANONNAME<hr>  如果设置了这个标志，我们会尝试在 ai_canonname 字段中报告主机的规范名称。<hr>EVUTIL_AI_NUMERICHOST<hr>  设置这个标志时，我们只解析数字的 IPv4 和 IPv6 地址；如果 nodename 需要名称查找，我们会返回 EVUTIL_EAI_NONAME 错误。<hr>EVUTIL_AI_NUMERICSERV<hr>  设置这个标志时，我们只解析数字服务名称。如果 servname 既不是 NULL 也不是十进制整数，返回 EVUTIL_EAI_NONAME 错误。<hr>EVUTIL_AI_V4MAPPED<hr>  这个标志表示，如果 ai_family 是 AF_INET6 并且没有找到 IPv6 地址，结果中的任何 IPv4 地址应该作为 v4 映射的 IPv6 地址返回。除非操作系统支持，否则 evutil_getaddrinfo() 当前不支持它。<hr>EVUTIL_AI_ALL<hr>  如果同时设置了这个标志和 EVUTIL_AI_V4MAPPED，那么结果中的 IPv4 地址会作为 v4 映射的 IPv6 地址包含在结果中，不管是否有 IPv6 地址。除非操作系统支持，否则 evutil_getaddrinfo() 当前不支持它。<hr>EVUTIL_AI_ADDRCONFIG<hr>  如果设置了这个标志，那么只有当系统具有非本地 IPv4 地址时，结果中才包括 IPv4 地址，并且只有当系统具有非本地 IPv6 地址时，结果中才包括 IPv6 地址。<p></p>
</dd>
</dl></div>
<div class="paragraph"><p>The ai_family field of <em>hints</em> is used to tell evutil_getaddrinfo() which
addresses it should return.  It can be AF_INET to request IPv4 addresses
only, AF_INET6 to request IPv6 addresses only, or AF_UNSPEC to request
all available addresses.</p><p class="translate">hints 中的 ai_family 字段用于告诉 evutil_getaddrinfo() 它应该返回哪些地址。它可以是 AF_INET 来仅请求 IPv4 地址，AF_INET6 来仅请求 IPv6 地址，或者 AF_UNSPEC 来请求所有可用地址。</p></div>
<div class="paragraph"><p>The ai_socktype and ai_protocol fields of <em>hints</em> are used to tell
evutil_getaddrinfo() how you’re going to use the address.  They’re the
same as the socktype and protocol fields you would pass to socket().</p><p class="translate">hints 中的 ai_socktype 和 ai_protocol 字段用于告诉 evutil_getaddrinfo() 你将如何使用地址。它们与你传递给 socket() 的 socktype 和 protocol 字段相同。</p></div>
<div class="paragraph"><p>If evutil_getaddrinfo() is successful, it allocates a new linked list of
evutil_addrinfo structures, where each points to the next with its
"ai_next" pointer, and stores them in *res.  Because this value is
heap-allocated, you will need to use evutil_freeaddrinfo to free it.</p><p class="translate">如果 evutil_getaddrinfo() 成功，它会分配一个新的 evutil_addrinfo 结构的链表，每个结构通过它的 "ai_next" 指针指向下一个，并将它们存储在 *res 中。因为这个值是在堆上分配的，你需要使用 evutil_freeaddrinfo 来释放它。</p></div>
<div class="paragraph"><p>If it fails, it returns one of these numeric error codes:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
EVUTIL_EAI_ADDRFAMILY
</dt>
<dd>
<p>
      You requested an address family that made no sense for the
      nodename.
</p>
</dd>
<dt class="hdlist1">
EVUTIL_EAI_AGAIN
</dt>
<dd>
<p>
      There was a recoverable error in name resolution; try again later.
</p>
</dd>
<dt class="hdlist1">
EVUTIL_EAI_FAIL
</dt>
<dd>
<p>
      There was a non-recoverable error in name resolution; your
      resolver or your DNS server may be busted.
</p>
</dd>
<dt class="hdlist1">
EVUTIL_EAI_BADFLAGS
</dt>
<dd>
<p>
      The ai_flags field in hints was somehow invalid.
</p>
</dd>
<dt class="hdlist1">
EVUTIL_EAI_FAMILY
</dt>
<dd>
<p>
      The ai_family field in hints was not one we support.
</p>
</dd>
<dt class="hdlist1">
EVUTIL_EAI_MEMORY
</dt>
<dd>
<p>
      We ran out of memory while trying to answer your request.
</p>
</dd>
<dt class="hdlist1">
EVUTIL_EAI_NODATA
</dt>
<dd>
<p>
      The host you asked for exists, but has no address information
      associated with it.  (Or, it has no address information of the
      type you requested.)
</p>
</dd>
<dt class="hdlist1">
EVUTIL_EAI_NONAME
</dt>
<dd>
<p>
      The host you asked for doesn’t seem to exist.
</p>
</dd>
<dt class="hdlist1">
EVUTIL_EAI_SERVICE
</dt>
<dd>
<p>
      The service you asked for doesn’t seem to exist.
</p>
</dd>
<dt class="hdlist1">
EVUTIL_EAI_SOCKTYPE
</dt>
<dd>
<p>
      We don’t support the socket type you asked for, or it isn’t
      compatible with ai_protocol.
</p>
</dd>
<dt class="hdlist1">
EVUTIL_EAI_SYSTEM
</dt>
<dd>
<p>
      There was some other system error during name resolution.  Check
      errno for more information.
</p>
</dd>
<dt class="hdlist1">
EVUTIL_EAI_CANCEL
</dt>
<dd>
<p>
      The application requested that this DNS lookup should be canceled
      before it was finished.  The evutil_getaddrinfo() function never
      produces this error, but it can come from evdns_getaddrinfo()
      as described in the section below.
</p><p class="translate">如果失败，它会返回以下一个数值错误代码：<br>EVUTIL_EAI_ADDRFAMILY<br>  你请求了一个对于 nodename 没有意义的地址族。<br>EVUTIL_EAI_AGAIN<br>  名称解析中有一个可恢复的错误；稍后再试。<br>EVUTIL_EAI_FAIL<br>  名称解析中有一个不可恢复的错误；你的解析器或 DNS 服务器可能出问题了。<br>EVUTIL_EAI_BADFLAGS<br>  hints 中的 ai_flags 字段无效。<br>EVUTIL_EAI_FAMILY<br>  hints 中的 ai_family 字段不支持。<br>EVUTIL_EAI_MEMORY<br>  在尝试回答你的请求时我们耗尽了内存。<br>EVUTIL_EAI_NODATA<br>  你询问的主机存在，但没有与之相关的地址信息。（或者，它没有你请求的类型的地址信息。）<br>EVUTIL_EAI_NONAME<br>  你询问的主机似乎不存在。<br>EVUTIL_EAI_SERVICE<br>  你询问的服务似乎不存在。<br>EVUTIL_EAI_SOCKTYPE<br>  我们不支持你请求的socket类型，或者它与 ai_protocol 不兼容。<br>EVUTIL_EAI_SYSTEM<br>  在名称解析过程中出现了其他系统错误。检查 errno 以获取更多信息。<br>EVUTIL_EAI_CANCEL<br>  应用程序请求在 DNS 查找完成之前取消它。evutil_getaddrinfo() 函数永远不会产生这个错误，但它可能来自 evdns_getaddrinfo()，如下面的章节所述。</p>
</dd>
</dl></div>
<div class="paragraph"><p>You can use evutil_gai_strerror() to convert one of these results into a
human-readable string.</p><p class="translate">你可以使用 evutil_gai_strerror() 将这些结果之一转换为人类可读的字符串。</p></div>
<div class="paragraph"><p>Note: If your OS defines struct addrinfo, then evutil_addrinfo is just
an alias for your OS’s built-in structure.  Similarly, if your operating
system defines any of the AI_* flags, then the corresponding EVUTIL_AI_*
flag is just an alias for the native flag; and if your operating system
defines any of the EAI_* errors, then the corresponding EVUTIL_EAI_*
code is the same as your platform’s native error code.</p><p class="translate">注意：如果你的操作系统定义了 struct addrinfo，则 evutil_addrinfo 只是你的操作系统内置结构的别名。类似地，如果你的操作系统定义了任何 AI_* 标志，那么对应的 EVUTIL_AI_* 标志只是本地标志的别名；如果你的操作系统定义了任何 EAI_* 错误，那么相应的 EVUTIL_EAI_* 代码与你的平台的本地错误代码相同。</p></div>
<div class="listingblock">
<div class="title">Example: Resolving a hostname and making a blocking connection</div>
<div class="content">
<pre><code>#include &lt;event2/util.h&gt;

#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;unistd.h&gt;

evutil_socket_t
get_tcp_socket_for_host(<strong>const</strong> <strong>char</strong> *hostname, ev_uint16_t port)
{
    <strong>char</strong> port_buf[6];
    <strong>struct</strong> evutil_addrinfo hints;
    <strong>struct</strong> evutil_addrinfo *answer = NULL;
    <strong>int</strong> err;
    evutil_socket_t sock;

<i>    /* Convert the port to decimal. */</i>
    evutil_snprintf(port_buf, <strong>sizeof</strong>(port_buf), "%d", (<strong>int</strong>)port);

<i>    /* Build the hints to tell getaddrinfo how to act. */</i>
    memset(&amp;hints, 0, <strong>sizeof</strong>(hints));
    hints.ai_family = AF_UNSPEC; /* v4 or v6 is fine. */
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_protocol = IPPROTO_TCP; /* We want a TCP socket */
<i>    /* Only return addresses we can use. */</i>
    hints.ai_flags = EVUTIL_AI_ADDRCONFIG;

<i>    /* Look up the hostname. */</i>
    err = evutil_getaddrinfo(hostname, port_buf, &amp;hints, &amp;answer);
    <strong>if</strong> (err != 0) {
          fprintf(stderr, "Error <strong>while</strong> resolving '%s': %s",
                  hostname, evutil_gai_strerror(err));
          <strong>return</strong> -1;
    }

<i>    /* If there was no error, we should have at least one answer. */</i>
    assert(answer);
<i>    /* Just use the first answer. */</i>
    sock = socket(answer-&gt;ai_family,
                  answer-&gt;ai_socktype,
                  answer-&gt;ai_protocol);
    <strong>if</strong> (sock &lt; 0)
        <strong>return</strong> -1;
    <strong>if</strong> (connect(sock, answer-&gt;ai_addr, answer-&gt;ai_addrlen)) {
<i>        /* Note that we're doing a blocking connect in this function.</i>
<i>         * If this were nonblocking, we'd need to treat some errors</i>
<i>         * (like EINTR and EAGAIN) specially. */</i>
        EVUTIL_CLOSESOCKET(sock);
        <strong>return</strong> -1;
    }

    <strong>return</strong> sock;
}</code></pre>
</div></div>
<div class="paragraph"><p>These functions and constants were new in Libevent 2.0.3-alpha.  They
are declared in event2/util.h.</p><p class="translate">这些函数和常量在 Libevent 2.0.3-alpha 中是新的。它们在 event2/util.h 中声明。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_non_blocking_hostname_resolution_with_evdns_getaddrinfo">Non-blocking hostname resolution with evdns_getaddrinfo()</h2>
<div class="sectionbody">
<div class="paragraph"><p>The main problem with the regular getaddrinfo() interface, and with
evutil_getaddrinfo() above, is that they’re blocking: when you call
them, the thread you’re in has to wait while they query your DNS
server(s) and wait for a response.  Since you’re using Libevent, that
probably isn’t the behavior you want.</p><p class="translate">常规的getaddrinfo()接口以及上述的evutil_getaddrinfo()的主要问题在于它们是阻塞的：当你调用它们时，你所在的线程必须等待它们查询DNS服务器并等待响应。由于你正在使用Libevent，这可能不是你想要的行为。</p></div>
<div class="paragraph"><p>So for nonblocking use, Libevent provides a set of functions to launch
DNS requests, and use Libevent to wait for the server to answer.</p><p class="translate">因此，为了非阻塞使用，Libevent提供了一系列函数来发起DNS请求，并使用Libevent等待服务器回应。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>typedef</strong> <strong>void</strong> (*evdns_getaddrinfo_cb)(
    <strong>int</strong> result, <strong>struct</strong> evutil_addrinfo *res, <strong>void</strong> *arg);
<strong>struct</strong> evdns_getaddrinfo_request;

<strong>struct</strong> evdns_getaddrinfo_request *evdns_getaddrinfo(
    <strong>struct</strong> evdns_base *dns_base,
    <strong>const</strong> <strong>char</strong> *nodename, <strong>const</strong> <strong>char</strong> *servname,
    <strong>const</strong> <strong>struct</strong> evutil_addrinfo *hints_in,
    evdns_getaddrinfo_cb cb, <strong>void</strong> *arg);

<strong>void</strong> evdns_getaddrinfo_cancel(<strong>struct</strong> evdns_getaddrinfo_request *req);</code></pre>
</div></div>
<div class="paragraph"><p>The evdns_getaddrinfo() function behaves just like evutil_getaddrinfo(),
except that instead of blocking on DNS servers, it uses Libevent’s
low-level DNS facilities to look hostnames up for you.  Because it can’t
always return you the result immediately, you need to provide it a
callback function of type evdns_getaddrinfo_cb, and an optional
user-supplied argument for that callback function.</p><p class="translate">evdns_getaddrinfo()函数的行为就像evutil_getaddrinfo()一样，不同之处在于它不是在DNS服务器上阻塞，而是使用Libevent的低级DNS实现为你查找主机名。因为它不能总是立即返回结果，你需要为它提供一个类型为evdns_getaddrinfo_cb的回调函数，以及一个可选的用户提供的该回调函数的参数。</p></div>
<div class="paragraph"><p>Additionally, you need to provide evdns_getaddrinfo() with a pointer to
an evdns_base.  This structure holds the state  and configuration for
Libevent’s DNS resolver.  See the next section for more information on
how to get one.</p><p class="translate">此外，你需要为evdns_getaddrinfo()提供一个evdns_base。这个结构体保存了Libevent DNS解析器的状态和配置。更多信息请参阅下一节。</p></div>
<div class="paragraph"><p>The evdns_getaddrinfo() function returns NULL if it fails or succeeds
immediately.  Otherwise, it returns a pointer to an
evdns_getaddrinfo_request.  You can use this to cancel the request with
evdns_getaddrinfo_cancel() at any time before the request is finished.</p><p class="translate">如果evdns_getaddrinfo()函数失败或立即成功，它将返回NULL。否则，它将返回一个指向evdns_getaddrinfo_request的指针。在请求完成之前，你可以随时使用evdns_getaddrinfo_cancel()来取消该请求。</p></div>
<div class="paragraph"><p>Note that the callback function <em>will</em> eventually be invoked whether
evdns_getaddrinfo() returns NULL or not, and whether
evdns_getaddrinfo_cancel() is called or not.</p><p class="translate">注意，无论evdns_getaddrinfo()是否返回NULL，以及是否调用了evdns_getaddrinfo_cancel()，最终都会调用回调函数。</p></div>
<div class="paragraph"><p>When you call evdns_getaddrinfo(), it makes its own internal copies of its
nodename, servname, and hints arguments: you do not need to ensure that they
continue to exist while the name lookup is in progress.</p><p class="translate">当你调用evdns_getaddrinfo()时，它会对其nodename、servname和hints参数做自己的内部副本：你不需要确保它们在名称查找进行时继续存在。</p></div>
<div class="listingblock">
<div class="title">Example: Nonblocking lookups with evdns_getaddrinfo()</div>
<div class="content">
<pre><code>#include &lt;event2/dns.h&gt;
#include &lt;event2/util.h&gt;
#include &lt;event2/event.h&gt;

#include &lt;sys/socket.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

<strong>int</strong> n_pending_requests = 0;
<strong>struct</strong> event_base *base = NULL;

<strong>struct</strong> user_data {
    <strong>char</strong> *name; /* the name we're resolving */
    <strong>int</strong> idx; /* its position on the command line */
};

<strong>void</strong> callback(<strong>int</strong> errcode, <strong>struct</strong> evutil_addrinfo *addr, <strong>void</strong> *ptr)
{
    <strong>struct</strong> user_data *data = ptr;
    <strong>const</strong> <strong>char</strong> *name = data-&gt;name;
    <strong>if</strong> (errcode) {
        printf("%d. %s -&gt; %s\n", data-&gt;idx, name, evutil_gai_strerror(errcode));
    } <strong>else</strong> {
        <strong>struct</strong> evutil_addrinfo *ai;
        printf("%d. %s", data-&gt;idx, name);
        <strong>if</strong> (addr-&gt;ai_canonname)
            printf(" [%s]", addr-&gt;ai_canonname);
        puts("");
        <strong>for</strong> (ai = addr; ai; ai = ai-&gt;ai_next) {
            <strong>char</strong> buf[128];
            <strong>const</strong> <strong>char</strong> *s = NULL;
            <strong>if</strong> (ai-&gt;ai_family == AF_INET) {
                <strong>struct</strong> sockaddr_in *sin = (<strong>struct</strong> sockaddr_in *)ai-&gt;ai_addr;
                s = evutil_inet_ntop(AF_INET, &amp;sin-&gt;sin_addr, buf, 128);
            } <strong>else</strong> <strong>if</strong> (ai-&gt;ai_family == AF_INET6) {
                <strong>struct</strong> sockaddr_in6 *sin6 = (<strong>struct</strong> sockaddr_in6 *)ai-&gt;ai_addr;
                s = evutil_inet_ntop(AF_INET6, &amp;sin6-&gt;sin6_addr, buf, 128);
            }
            <strong>if</strong> (s)
                printf("    -&gt; %s\n", s);
        }
        evutil_freeaddrinfo(addr);
    }
    free(data-&gt;name);
    free(data);
    <strong>if</strong> (--n_pending_requests == 0)
        event_base_loopexit(base, NULL);
}

<i>/* Take a list of domain names from the command line and resolve them in</i>
<i> * parallel. */</i>
<strong>int</strong> main(<strong>int</strong> argc, <strong>char</strong> **argv)
{
    <strong>int</strong> i;
    <strong>struct</strong> evdns_base *dnsbase;

    <strong>if</strong> (argc == 1) {
        puts("No addresses given.");
        <strong>return</strong> 0;
    }
    base = event_base_new();
    <strong>if</strong> (!base)
        <strong>return</strong> 1;
    dnsbase = evdns_base_new(base, 1);
    <strong>if</strong> (!dnsbase)
        <strong>return</strong> 2;

    <strong>for</strong> (i = 1; i &lt; argc; ++i) {
        <strong>struct</strong> evutil_addrinfo hints;
        <strong>struct</strong> evdns_getaddrinfo_request *req;
        <strong>struct</strong> user_data *user_data;
        memset(&amp;hints, 0, <strong>sizeof</strong>(hints));
        hints.ai_family = AF_UNSPEC;
        hints.ai_flags = EVUTIL_AI_CANONNAME;
<i>        /* Unless we specify a socktype, we'll get at least two entries for</i>
<i>         * each address: one for TCP and one for UDP. That's not what we</i>
<i>         * want. */</i>
        hints.ai_socktype = SOCK_STREAM;
        hints.ai_protocol = IPPROTO_TCP;

        <strong>if</strong> (!(user_data = malloc(<strong>sizeof</strong>(<strong>struct</strong> user_data)))) {
            perror("malloc");
            exit(1);
        }
        <strong>if</strong> (!(user_data-&gt;name = strdup(argv[i]))) {
            perror("strdup");
            exit(1);
        }
        user_data-&gt;idx = i;

        ++n_pending_requests;
        req = evdns_getaddrinfo(
                          dnsbase, argv[i], NULL /* no service name given */,
                          &amp;hints, callback, user_data);
        <strong>if</strong> (req == NULL) {
          printf("    [request <strong>for</strong> %s returned immediately]\n", argv[i]);
<i>          /* No need to free user_data or decrement n_pending_requests; that</i>
<i>           * happened in the callback. */</i>
        }
    }

    <strong>if</strong> (n_pending_requests)
      event_base_dispatch(base);

    evdns_base_free(dnsbase, 0);
    event_base_free(base);

    <strong>return</strong> 0;
}</code></pre>
</div></div>
<div class="paragraph"><p>These functions were new in Libevent 2.0.3-alpha.  They are declared in
event2/dns.h.</p><p class="translate">这些函数是在Libevent 2.0.3-alpha中新增的。它们在event2/dns.h中声明。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_creating_and_configuring_an_evdns_base">Creating and configuring an evdns_base</h2>
<div class="sectionbody">
<div class="paragraph"><p>Before you can do nonblocking DNS lookups with evdns, you’ll need to
configure an evdns_base.  Each evdns_base stores a list of nameservers,
and DNS configuration options, and tracks active and in-flight DNS
requests.</p><p class="translate">在你可以使用evdns进行非阻塞DNS查找之前，你需要配置一个evdns_base。每个evdns_base存储了一个域名服务器列表、DNS配置选项，并跟踪活动的和执行中的DNS请求。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>struct</strong> evdns_base *evdns_base_new(<strong>struct</strong> event_base *event_base,
       <strong>int</strong> initialize);
<strong>void</strong> evdns_base_free(<strong>struct</strong> evdns_base *base, <strong>int</strong> fail_requests);</code></pre>
</div></div>
<div class="paragraph"><p>The evdns_base_new() function returns a new evdns_base on success, and
NULL on failure.  If the <em>initialize</em> argument is 1, it tries to
configure the DNS base sensibly given your operating system’s default.
If it is 0, it leaves the evdns_base empty, with no nameservers or
options configured.</p><p class="translate">evdns_base_new()函数在成功时返回一个新的evdns_base，在失败时返回NULL。如果initialize参数为1，它将尝试根据你的操作系统默认设置合理地配置base。如果它为0，它将留下一个空的evdns_base，没有配置任何域名服务器或选项。</p></div>
<div class="paragraph"><p>When you no longer need an evdns_base, you can free it with
evdns_base_free.  If its <em>fail_requests</em> argument is true, it will
make all in-flight requests get their callbacks invoked with a
<em>canceled</em> error code before it frees the base.</p><p class="translate">当你不再需要一个evdns_base时，你可以用evdns_base_free来释放它。如果其fail_requests参数为真，它将在释放base之前使所有执行中的请求调用其回调函数，并带有一个 canceled 的错误代码。</p></div>
<div class="sect2">
<h3 id="_initializing_evdns_from_the_system_configuration">Initializing evdns from the system configuration</h3>
<div class="paragraph"><p>If you want a little more control over how the evdns_base is
initialized, you can pass 0 as the <em>initialize</em> argument to
evdns_base_new, and invoke one of these functions.</p><p class="translate">如果你想对evdns_base的初始化过程有更多控制，你可以将initialize参数设为0传递给evdns_base_new，并且调用以下其中一个函数。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code>#define DNS_OPTION_SEARCH 1
#define DNS_OPTION_NAMESERVERS 2
#define DNS_OPTION_MISC 4
#define DNS_OPTION_HOSTSFILE 8
#define DNS_OPTIONS_ALL 15
<strong>int</strong> evdns_base_resolv_conf_parse(<strong>struct</strong> evdns_base *base, <strong>int</strong> flags,
                                 <strong>const</strong> <strong>char</strong> *filename);

#ifdef WIN32
<strong>int</strong> evdns_base_config_windows_nameservers(<strong>struct</strong> evdns_base *);
#define EVDNS_BASE_CONFIG_WINDOWS_NAMESERVERS_IMPLEMENTED
#endif</code></pre>
</div></div>
<div class="paragraph"><p>The evdns_base_resolv_conf_parse() function will scan the resolv.conf
formatted file stored in <em>filename</em>, and read in all the options from it
that are listed in <em>flags</em>.  (For more information on the resolv.conf
file, see your local Unix manual pages.)</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
DNS_OPTION_SEARCH
</dt>
<dd>
<p>
     Tells evdns to read the <em>domain</em> and <em>search</em> fields from the
     resolv.conf file and the <em>ndots</em> option, and use them to decide
     which domains (if any) to search for hostnames that aren’t
     fully-qualified.
</p>
</dd>
<dt class="hdlist1">
DNS_OPTION_NAMESERVERS
</dt>
<dd>
<p>
     This flag tells evdns to learn the nameservers from the resolv.conf
     file.
</p>
</dd>
<dt class="hdlist1">
DNS_OPTION_MISC
</dt>
<dd>
<p>
     Tells evdns to set other configuration options from the resolv.conf
     file.
</p>
</dd>
<dt class="hdlist1">
DNS_OPTION_HOSTSFILE
</dt>
<dd>
<p>
     Tells evdns to read a list of hosts from /etc/hosts as part of
     loading the resolv.conf file.
</p>
</dd>
<dt class="hdlist1">
DNS_OPTIONS_ALL
</dt>
<dd>
<p>
     Tells evdns to learn as much as it can from the resolv.conf file.
</p><p class="translate">evdns_base_resolv_conf_parse()函数会扫描保存在filename中的resolv.conf格式的文件，并从中读取所有在flags中列出的选项。（关于resolv.conf文件的更多信息，请参见你本地的Unix手册页。）<br>DNS_OPTION_SEARCH<br>  指示evdns从resolv.conf文件读取域名和搜索字段以及ndots选项，并使用它们来决定搜索哪些域名（如果有的话）来解析不是完全合格的主机名。<br>DNS_OPTION_NAMESERVERS<br>  这个标志告诉evdns从resolv.conf文件中学习域名服务器。<br>DNS_OPTION_MISC<br>  指示evdns从resolv.conf文件设置其他配置选项。<br>DNS_OPTION_HOSTSFILE<br>  指示evdns在加载resolv.conf文件时从/etc/hosts读取主机列表。<br>DNS_OPTIONS_ALL<br>  告诉evdns从resolv.conf文件中尽可能多地学习。</p>
</dd>
</dl></div>
<div class="paragraph"><p>On Windows, you don’t have a resolv.conf file to tell you where your
nameservers are, so you can use the
evdns_base_config_windows_nameservers() function to read all your
nameservers from your registry (or your NetworkParams, or wherever
they’re hidden).</p><p class="translate">在Windows上，你没有resolv.conf文件来告诉你域名服务器在哪里，所以你可以使用evdns_base_config_windows_nameservers()函数从你的注册表中读取所有的域名服务器（或者你的NetworkParams，或者它们被隐藏的任何地方）。</p></div>
<div class="sect3">
<h4 id="_the_resolv_conf_file_format">The resolv.conf file format</h4>
<div class="paragraph"><p>The resolv.conf format we recognize is a text file, each line of which
should either be empty, contain a comment starting with the # character,
or consist of a token followed zero or more arguments.  The tokens
we recognize are:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
nameserver
</dt>
<dd>
<p>
     Must be followed by the IP address of exactly one nameserver.  As
     an extension, Libevent allows you to specify a nonstandard port for
     the nameserver, using the IP:Port or the [IPv6]:port syntax.
</p>
</dd>
<dt class="hdlist1">
domain
</dt>
<dd>
<p>
     The local domain name.
</p>
</dd>
<dt class="hdlist1">
search
</dt>
<dd>
<p>
     A list of names to search when resolving local hostnames.
     Any name that has fewer than "ndots" dots in it is considered
     local, and if we can’t resolve it as-is, we look in these domain
     names.  For example, if "search" is example.com and "ndots" is 1,
     then when the user asks us to resolve "www", we will consider
     "www.example.com".
</p>
</dd>
<dt class="hdlist1">
options
</dt>
<dd>
<p>
     A space-separated list of options.  Each option is given either as
     a bare string, or (if it takes an argument) in the option:value
     format.  Recognized options are:
</p>
<div class="dlist"><dl>
<dt class="hdlist1">
ndots:INTEGER
</dt>
<dd>
<p>
        Used to configure searching.  See "search" above.  Defaults to 1.
</p>
</dd>
<dt class="hdlist1">
timeout:FLOAT
</dt>
<dd>
<p>
        How long, in seconds, do we wait for a response from a DNS
        server before we assume we aren’t getting one?  Defaults to 5
        seconds.
</p>
</dd>
<dt class="hdlist1">
max-timeouts:INT
</dt>
<dd>
<p>
        How many times do we allow a nameserver to time-out in a row
        before we assume that it’s down?  Defaults to 3.
</p>
</dd>
<dt class="hdlist1">
max-inflight:INT
</dt>
<dd>
<p>
        How many DNS requests do we allow to be pending at once?  (If
        we try to do more requests than this, the extras will stall
        until the earlier ones are answered or time out.)  Defaults to
        64.
</p>
</dd>
<dt class="hdlist1">
attempts:INT
</dt>
<dd>
<p>
        How many times to we re-transmit a DNS request before giving up
        on it?  Defaults to 3.
</p>
</dd>
<dt class="hdlist1">
randomize-case:INT
</dt>
<dd>
<p>
        If nonzero, we randomize the case on outgoing DNS requests and
        make sure that replies have the same case as our requests.  This
        so-called "0x20 hack" can help prevent some otherwise simple
        active events against DNS.  Defaults to 1.
</p>
</dd>
<dt class="hdlist1">
bind-to:ADDRESS
</dt>
<dd>
<p>
        If provided, we bind to the given address whenever we send
        packets to a nameserver.  As of Libevent 2.0.4-alpha, it only
        applied to subsequent nameserver entries.
</p>
</dd>
<dt class="hdlist1">
initial-probe-timeout:FLOAT
</dt>
<dd>
<p>
        When we decide that a nameserver is down, we probe it with
        exponentially decreasing frequency to see if it has come back
        up.  This option configures the first timeout in the series, in
        seconds.  Defaults to 10.
</p>
</dd>
<dt class="hdlist1">
getaddrinfo-allow-skew:FLOAT
</dt>
<dd>
<p>
        When evdns_getaddrinfo() requests both an IPv4 address and an
        IPv6 address, it does so in separate DNS request packets, since
        some servers can’t handle both requests in one packet.  Once
        it has an answer for one address type, it waits a little while
        to see if an answer for the other one comes in.  This option
        configures how long to wait, in seconds.  Defaults to 3 seconds.
</p><p class="translate">我们识别的resolv.conf格式是一个文本文件，每一行要么是空的，要么包含一个以#字符开始的注释，或者由一个标记和零个或多个参数组成。我们识别的标记有：<br>nameserver<br>  必须跟着一个域名服务器的IP地址。作为扩展，Libevent允许你指定一个非标准端口给域名服务器，使用IP:Port或者[IPv6]:port语法。<br>domain<br>  本地域名。<br>search<br>  解析本地主机名时要搜索的名称列表。任何名称如果点的数量少于"ndots"，则被认为是本地的，如果我们不能按原样解析它，我们就会在这些域名中寻找。例如，如果"search"是example.com并且"ndots"是1，那么当用户让我们解析"www"时，我们会考虑"www.example.com"。<br>options<br>  由空格分隔的选项列表。每个选项要么作为一个简单字符串给出，要么（如果它带有参数）以option:value格式给出。识别的选项是：<br>  ndots:INTEGER<br>    用于配置搜索。见上面的"search"。默认为1。<br>  timeout:FLOAT<br>    我们等待来自DNS服务器响应的时间有多长。默认为5秒。<br>  max-timeouts:INT<br>    我们允许一个域名服务器连续超时多少次。默认为3次。<br>  max-inflight:INT<br>    我们允许同时有多少DNS请求等待中？（如果我们尝试的请求超过这个数量，额外的请求将会暂停，直到先前的请求得到回答或超时。）默认为64。<br>  attempts:INT<br>    在我们放弃一个DNS请求之前，我们重新传输多少次。默认为3次。<br>  randomize-case:INT<br>    如果非零，则我们在发送DNS请求时随机化大小写，并确保回复具有与我们的请求相同的大小写。这种所谓的"0x20 hack"可以帮助防止一些简单的DNS活动攻击。默认为1。<br>  bind-to:ADDRESS<br>    如果提供，我们每次向域名服务器发送数据包时都会绑定到给定的地址。在Libevent 2.0.4-alpha之后，它只适用于随后的域名服务器条目。<br>  initial-probe-timeout:FLOAT<br>    当我们决定一个域名服务器已经宕机时，我们会以指数递减的频率探测它，看它是否已经恢复。此选项配置系列中的第一个超时时间，以秒为单位。默认为10秒。<br>  getaddrinfo-allow-skew:FLOAT<br>    当evdns_getaddrinfo()同时请求IPv4地址和IPv6地址时，它会在单独的DNS请求数据包中进行，因为有些服务器不能在一个数据包中处理两个请求。一旦它得到了一种地址类型的答案，它会稍等一会儿看看另一种地址类型的答案是否会到来。此选项配置等待多长时间，以秒为单位。默认为3秒。</p>
</dd>
</dl></div>
</dd>
</dl></div>
<div class="paragraph"><p>Unrecognized tokens and options are ignored.</p><p class="translate">不被识别的标记和选项将被忽略。</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_configuring_evdns_manually">Configuring evdns manually</h3>
<div class="paragraph"><p>If you want even more fine-grained control over evdns’s behavior,
you can use these functions:</p><p class="translate">如果你想对evdns的行为有更细粒度的控制，你可以使用这些函数：</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>int</strong> evdns_base_nameserver_sockaddr_add(<strong>struct</strong> evdns_base *base,
                                 <strong>const</strong> <strong>struct</strong> sockaddr *sa, ev_socklen_t len,
                                 <strong>unsigned</strong> flags);
<strong>int</strong> evdns_base_nameserver_ip_add(<strong>struct</strong> evdns_base *base,
                                 <strong>const</strong> <strong>char</strong> *ip_as_string);
<strong>int</strong> evdns_base_load_hosts(<strong>struct</strong> evdns_base *base, <strong>const</strong> <strong>char</strong> *hosts_fname);

<strong>void</strong> evdns_base_search_clear(<strong>struct</strong> evdns_base *base);
<strong>void</strong> evdns_base_search_add(<strong>struct</strong> evdns_base *base, <strong>const</strong> <strong>char</strong> *domain);
<strong>void</strong> evdns_base_search_ndots_set(<strong>struct</strong> evdns_base *base, <strong>int</strong> ndots);

<strong>int</strong> evdns_base_set_option(<strong>struct</strong> evdns_base *base, <strong>const</strong> <strong>char</strong> *option,
    <strong>const</strong> <strong>char</strong> *val);

<strong>int</strong> evdns_base_count_nameservers(<strong>struct</strong> evdns_base *base);</code></pre>
</div></div>
<div class="paragraph"><p>The evdns_base_nameserver_sockaddr_add() function adds a nameserver to an
existing evdns_base by its address.  The <em>flags</em> argument is currently
ignored, and should be 0 for forward-compatibility.  The function returns 0 on
success and negative on failure.  (It was added in Libevent 2.0.7-rc.)</p><p class="translate">evdns_base_nameserver_sockaddr_add()函数通过其地址向现有的evdns_base添加一个域名服务器。flags参数目前被忽略，并且应该为了向前兼容而设为0。函数成功时返回0，失败时返回负值。（它在Libevent 2.0.7-rc中被加入。）</p></div>
<div class="paragraph"><p>The evdns_base_nameserver_ip_add function adds a nameserver to an existing
evdns_base.  It takes the nameserver in a text string, either as an IPv4
address, an IPv6 address, an IPv4 address with a port (IPv4:Port), or an
IPv6 address with a port ([IPv6]:Port).  It returns 0 on success and
negative on failure.</p><p class="translate">evdns_base_nameserver_ip_add函数向现有的evdns_base添加一个域名服务器。它接受文本字符串中的域名服务器，可以是IPv4地址、IPv6地址、带端口的IPv4地址（IPv4:Port）或带端口的IPv6地址（[IPv6]:Port）。成功时返回0，失败时返回负值。</p></div>
<div class="paragraph"><p>The evdns_base_load_hosts() function loads a hosts file (in the same
format as /etc/hosts) from hosts_fname.  It also returns 0 on success
and negative on failure.</p><p class="translate">evdns_base_load_hosts()函数从hosts_fname加载一个hosts文件（与/etc/hosts的格式相同）。它也在成功时返回0，在失败时返回负值。</p></div>
<div class="paragraph"><p>The evdns_base_search_clear() function removes all current search suffixes
(as configured by the <em>search</em> option) from the evdns_base; the
evdns_base_search_add() function adds a suffix.</p><p class="translate">evdns_base_search_clear()函数移除evdns_base中所有当前的搜索后缀（由search选项配置）；evdns_base_search_add()函数添加一个后缀。</p></div>
<div class="paragraph"><p>The evdns_base_set_option() function sets a given option to a given value in
the evdns_base.  Each one is given as a string.  (Before Libevent
2.0.3, the option name needed to have a colon after it.)</p><p class="translate">evdns_base_set_option()函数在evdns_base中为给定的选项设置给定的值。每个都以字符串形式给出。（在Libevent 2.0.3之前，选项名称需要在其后面有一个冒号。）</p></div>
<div class="paragraph"><p>If you’ve just parsed a set of configuration files and want to see if
any nameservers were added, you can use evdns_base_count_nameservers()
to see how many there are.</p><p class="translate">如果你刚刚解析了一组配置文件并想知道是否添加了任何域名服务器，你可以使用evdns_base_count_nameservers()来查看有多少个。</p></div>
</div>
<div class="sect2">
<h3 id="_library_side_configuration">Library-side configuration</h3>
<div class="paragraph"><p>There are a couple of functions you can use to specify library-wide
settings for the evdns module:</p><p class="translate">有几个函数你可以用来为evdns模块指定库级别的设置：</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>typedef</strong> <strong>void</strong> (*evdns_debug_log_fn_type)(<strong>int</strong> is_warning, <strong>const</strong> <strong>char</strong> *msg);
<strong>void</strong> evdns_set_log_fn(evdns_debug_log_fn_type fn);
<strong>void</strong> evdns_set_transaction_id_fn(ev_uint16_t (*fn)(<strong>void</strong>));</code></pre>
</div></div>
<div class="paragraph"><p>For historical reasons, the evdns subsystem does its own logging; you
can use evdns_set_log_fn() to give it a callback that does something
with its messages besides discard them.</p><p class="translate">由于历史原因，evdns子系统执行自己的日志记录；你可以使用evdns_set_log_fn()给它一个回调，用来处理它的消息，而不是丢弃它们。</p></div>
<div class="paragraph"><p>For security, evdns needs a good source of random numbers: it uses
this to pick hard-to-guess transaction IDs and to randomize queries
when using the 0x20 hack.  (See the "randomize-case" option for more
info here.)  Older versions of Libevent, did not provide a secure RNG
of its own, however.  You can give evdns a better random number
generator by calling evdns_set_transaction_id_fn and giving it a
function that returns a hard-to-predict two-byte unsigned integer.</p><p class="translate">出于安全考虑，evdns需要一个良好的随机数来源：它使用这个来挑选难以猜测的交易ID并在使用0x20 hack时随机化查询。（有关"randomize-case"选项的更多信息，请参阅这里。）然而，旧版本的Libevent并没有提供自己的安全RNG。你可以通过调用evdns_set_transaction_id_fn并给它一个函数来给evdns一个更好的随机数生成器，该函数返回一个难以预测的两字节无符号整数。</p></div>
<div class="paragraph"><p>In Libevent 2.0.4-alpha and later, Libevent uses its own built-in
secure RNG; evdns_set_transaction_id_fn() has no effect.</p><p class="translate">在Libevent 2.0.4-alpha及以后版本中，Libevent使用自己内置的安全RNG；evdns_set_transaction_id_fn()没有效果。</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_low_level_dns_interfaces">Low-level DNS interfaces</h2>
<div class="sectionbody">
<div class="paragraph"><p>Occasionally, you’ll want the ability to launch specific DNS requests
with more fine-grained control than you get from evdns_getaddrinfo().
Libevent gives you some interfaces to do that.</p><p class="translate">偶尔，您会希望能够发起具有比evdns_getaddrinfo()提供的更细粒度控制的特定DNS请求。Libevent提供了一些接口来实现这一点。</p></div>
<div class="paragraph"><div class="title">Missing features</div><p>Right now, Libevent’s DNS support lacks a few features that you’d
expect from a low-level DNS system, like support for arbitrary request
types and TCP requests.  If you need features that evdns doesn’t have,
please consider contributing a patch.  You might also look into
a more full-featured DNS library like c-ares.</p><p class="translate">目前，Libevent的DNS支持缺少一些您期望从低级DNS系统中找到的功能，例如对任意请求类型和TCP请求的支持。如果您需要evdns没有的功能，请考虑贡献一个补丁。您也可以考虑使用更完整的DNS库，如c-ares。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code>#define DNS_QUERY_NO_SEARCH /* ... */

#define DNS_IPv4_A         /* ... */
#define DNS_PTR            /* ... */
#define DNS_IPv6_AAAA      /* ... */

<strong>typedef</strong> <strong>void</strong> (*evdns_callback_type)(<strong>int</strong> result, <strong>char</strong> type, <strong>int</strong> count,
    <strong>int</strong> ttl, <strong>void</strong> *addresses, <strong>void</strong> *arg);

<strong>struct</strong> evdns_request *evdns_base_resolve_ipv4(<strong>struct</strong> evdns_base *base,
    <strong>const</strong> <strong>char</strong> *name, <strong>int</strong> flags, evdns_callback_type callback, <strong>void</strong> *ptr);
<strong>struct</strong> evdns_request *evdns_base_resolve_ipv6(<strong>struct</strong> evdns_base *base,
    <strong>const</strong> <strong>char</strong> *name, <strong>int</strong> flags, evdns_callback_type callback, <strong>void</strong> *ptr);
<strong>struct</strong> evdns_request *evdns_base_resolve_reverse(<strong>struct</strong> evdns_base *base,
    <strong>const</strong> <strong>struct</strong> in_addr *in, <strong>int</strong> flags, evdns_callback_type callback,
    <strong>void</strong> *ptr);
<strong>struct</strong> evdns_request *evdns_base_resolve_reverse_ipv6(
    <strong>struct</strong> evdns_base *base, <strong>const</strong> <strong>struct</strong> in6_addr *in, <strong>int</strong> flags,
    evdns_callback_type callback, <strong>void</strong> *ptr);</code></pre>
</div></div>
<div class="paragraph"><p>These resolve functions initiate a DNS request for a particular record.  Each
takes an evdns_base to use for the request, a resource to look up (either a
hostname for forward lookups, or an address for reverse lookups), a set of
flags to determine how to do the lookup, a callback to invoke when the lookup
is done, and a pointer to pass to the user-supplied callback.</p><p class="translate">这些解析函数开始对特定记录的DNS请求初始化。每个函数都接受一个evdns_base用于请求，一个要查找的资源（前向查找的主机名或反向查找的地址），一组标志来确定如何进行查找，一个在查找完成时调用的回调函数，以及一个传递给用户提供的回调函数的指针。</p></div>
<div class="paragraph"><p>The <em>flags</em> argument is either 0 or DNS_QUERY_NO_SEARCH to explicitly
suppress searching in the list of search if the original search fails.
DNS_QUERY_NO_SEARCH has no effect for reverse lookups, since those never do
searching.</p><p class="translate">flags参数是0或DNS_QUERY_NO_SEARCH，用于否定搜索列表如果原始搜索失败。DNS_QUERY_NO_SEARCH对于反向查找没有效果，因为反向查找从不进行搜索。</p></div>
<div class="paragraph"><p>When the request is done---either successfully or not---the callback function
will be invoked.  The callback takes a <em>result</em> that indicates success or an
error code (see DNS Errors table below), a record type (one of DNS_IPv4_A,
DNS_IPv6_AAAA, or DNS_PTR), the number of records in <em>addresses</em>, a
time-to-live in seconds, the addresses themselves, and the user-supplied
argument pointer.</p><p class="translate">当请求完成——不论是成功还是失败——回调函数将被调用。回调接受一个结果，表示成功或一个错误代码（见下面的DNS错误表），一个记录类型（DNS_IPv4_A、DNS_IPv6_AAAA或DNS_PTR之一），地址中的记录数量，以秒为单位的生存时间，地址本身，以及用户提供的参数指针。</p></div>
<div class="paragraph"><p>The <em>addresses</em> argument to the callback is NULL in the event of an error.
For a PTR record, it’s a NUL-terminated string.  For IPv4 records, it is an
array of four-byte values in network order.  For IPv6 records, it is an array
of 16-byte records in network order.  (Note that the number of addresses can
be 0 even if there was no error.  This can happen when the name exists, but
it has no records of the requested type.)</p><p class="translate">如果发生错误，回调中的地址参数为NULL。对于PTR记录，它是一个NUL结尾的字符串。对于IPv4记录，它是网络顺序的四字节值数组。对于IPv6记录，它是网络顺序的16字节记录数组。（注意，即使没有错误，地址数量也可以是0。当名称存在，但没有请求类型的记录时，就会发生这种情况。）</p></div>
<div class="paragraph"><p>The errors codes that can be passed to the callback are as follows:</p><p class="translate">可以传递给回调的错误代码如下：</p></div>
<div class="paragraph"><div class="title">DNS Errors</div><p>[options="header",width="70%"</p></div>
<div class="tableblock">
<table rules="all" width="100%" frame="border" cellspacing="0" cellpadding="4">
<colgroup><col width="50%">
<col width="50%">
</colgroup><tbody>
<tr>
<td align="left" valign="top"><p class="table">Code</p></td>
<td align="left" valign="top"><p class="table">Meaning</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">DNS_ERR_NONE</p></td>
<td align="left" valign="top"><p class="table">No error occurred</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">DNS_ERR_FORMAT</p></td>
<td align="left" valign="top"><p class="table">The server didn’t understand the query</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">DNS_ERR_SERVERFAILED</p></td>
<td align="left" valign="top"><p class="table">The server reported an internal error</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">DNS_ERR_NOTEXIST</p></td>
<td align="left" valign="top"><p class="table">There was no record with the given name</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">DNS_ERR_NOTIMPL</p></td>
<td align="left" valign="top"><p class="table">The server doesn’t understand this kind of query</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">DNS_ERR_REFUSED</p></td>
<td align="left" valign="top"><p class="table">The server rejected the query for policy reasons</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">DNS_ERR_TRUNCATED</p></td>
<td align="left" valign="top"><p class="table">The DNS record wouldn’t fit in a UDP packet</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">DNS_ERR_UNKNOWN</p></td>
<td align="left" valign="top"><p class="table">Unknown internal error</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">DNS_ERR_TIMEOUT</p></td>
<td align="left" valign="top"><p class="table">We waited too long for an answer</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">DNS_ERR_SHUTDOWN</p></td>
<td align="left" valign="top"><p class="table">The user asked us to shut down the evdns system</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">DNS_ERR_CANCEL</p></td>
<td align="left" valign="top"><p class="table">The user asked us to cancel this request</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">DNS_ERR_NODATA</p></td>
<td align="left" valign="top"><p class="table">The response arrived, but contained no answers</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>(DNS_ERR_NODATA was new in 2.0.15-stable.)</p><p class="translate">（DNS_ERR_NODATA在2.0.15-stable中是新加的。）</p></div>
<div class="paragraph"><p>You can decode these error codes to a human-readable string with:</p><p class="translate">您可以使用以下接口将这些错误代码解码为可读字符串：</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>const</strong> <strong>char</strong> *evdns_err_to_string(<strong>int</strong> err);</code></pre>
</div></div>
<div class="paragraph"><p>Each resolve function returns a pointer to an opaque <em>evdns_request</em>
structure.  You can use this to cancel the request at any point before the
callback is invoked:</p><p class="translate">每个解析函数返回一个指向不透明evdns_request结构的指针。您可以使用此结构在回调被调用之前的任何时点取消请求：</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>void</strong> evdns_cancel_request(<strong>struct</strong> evdns_base *base,
    <strong>struct</strong> evdns_request *req);</code></pre>
</div></div>
<div class="paragraph"><p>Canceling a request with this function makes its callback get invoked with
the DNS_ERR_CANCEL result code.</p><p class="translate">用这个函数取消一个请求会使其调用回调并附带DNS_ERR_CANCEL。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_suspending_dns_client_operations_and_changing_nameservers">Suspending DNS client operations and changing nameservers</h2>
<div class="sectionbody">
<div class="paragraph"><p>Sometimes you want to reconfigure or shut down the DNS subsystem without
affecting in-flight DNS request too much.</p><p class="translate">有时候，您可能希望重新配置或关闭DNS子系统，而不会过多影响正在进行中的DNS请求。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>int</strong> evdns_base_clear_nameservers_and_suspend(<strong>struct</strong> evdns_base *base);
<strong>int</strong> evdns_base_resume(<strong>struct</strong> evdns_base *base);</code></pre>
</div></div>
<div class="paragraph"><p>If you call evdns_base_clear_nameservers_and_suspend() on an evdns_base,
all nameservers are removed, and pending requests are left in limbo until
later you re-add nameservers and call evdns_base_resume().</p><p class="translate">如果您在一个evdns_base上调用evdns_base_clear_nameservers_and_suspend()，所有的域名服务器都会被移除，而挂起的请求会处于不确定状态，直到您稍后重新添加域名服务器并调用evdns_base_resume()。</p></div>
<div class="paragraph"><p>These functions return 0 on success and -1 on failure.  They were introduced
in Libevent 2.0.1-alpha.</p><p class="translate">这些函数成功时返回0，失败时返回-1。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_dns_server_interfaces">DNS server interfaces</h2>
<div class="sectionbody">
<div class="paragraph"><p>Libevent provides simple functionality for acting as a trivial DNS
server and responding to UDP DNS requests.</p><p class="translate">Libevent提供了简单的功能，用作一个简单的DNS服务器并响应UDP DNS请求。</p></div>
<div class="paragraph"><p>This section assumes some familiarity with the DNS protocol.</p><p class="translate">这一部分假设你对DNS协议有一定的了解。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_creating_and_closing_a_dns_server">Creating and closing a DNS server</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>struct</strong> evdns_server_port *evdns_add_server_port_with_base(
    <strong>struct</strong> event_base *base,
    evutil_socket_t socket,
    <strong>int</strong> flags,
    evdns_request_callback_fn_type callback,
    <strong>void</strong> *user_data);

<strong>typedef</strong> <strong>void</strong> (*evdns_request_callback_fn_type)(
    <strong>struct</strong> evdns_server_request *request,
    <strong>void</strong> *user_data);

<strong>void</strong> evdns_close_server_port(<strong>struct</strong> evdns_server_port *port);</code></pre>
</div></div>
<div class="paragraph"><p>To begin listening for DNS requests, call evdns_add_server_port_with_base().
It takes an event_base to use for event handling; a UDP socket to listen on;
a flags variable (always 0 for now); a callback function to call when a new
DNS query is received; and a pointer to user data that will be passed to the
callback.  It returns a new evdns_server_port object.</p><p class="translate">要开始监听DNS请求，请调用evdns_add_server_port_with_base()。它需要一个event_base来处理事件；一个用于监听的UDP socket；一个标志变量（目前始终为0）；当接收到新的DNS查询时调用的回调函数；以及一个将传递给回调的用户数据指针。它返回一个新的evdns_server_port对象。</p></div>
<div class="paragraph"><p>When you are done with the DNS server, you can pass it to
evdns_close_server_port().</p><p class="translate">当您完成DNS服务器的使用时，可以将其传递给evdns_close_server_port()。</p></div>
<div class="paragraph"><p>The evdns_add_server_port_with_base() function was new in 2.0.1-alpha;
evdns_close_server_port() was introduced in 1.3.</p><p class="translate">evdns_add_server_port_with_base()函数是在2.0.1-alpha中新增的；evdns_close_server_port()则是在1.3中引入的。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_examining_a_dns_request">Examining a DNS request</h2>
<div class="sectionbody">
<div class="paragraph"><p>Unfortunately, Libevent doesn’t currently provide a great way to look at DNS
requests via a programmatic interface.  Instead, you’re stuck including
event2/dns_struct.h and looking at the evdns_server_request structure
manually.</p><p class="translate">不幸的是，Libevent目前没有提供一个很好的程序化接口来检查DNS请求。相反，你只能包含event2/dns_struct.h并手动检查evdns_server_request结构。</p></div>
<div class="paragraph"><p>It would be great if a future version of Libevent provided a better way to do
this.</p><p class="translate">如果未来版本的Libevent能提供一个更好的方式来做这件事，那将是极好的。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>struct</strong> evdns_server_request {
        <strong>int</strong> flags;
        <strong>int</strong> nquestions;
        <strong>struct</strong> evdns_server_question **questions;
};
#define EVDNS_QTYPE_AXFR 252
#define EVDNS_QTYPE_ALL  255
<strong>struct</strong> evdns_server_question {
        <strong>int</strong> type;
        <strong>int</strong> dns_question_class;
        <strong>char</strong> name[1];
};</code></pre>
</div></div>
<div class="paragraph"><p>The <em>flags</em> field of the request contains the DNS flags set in the request;
the <em>nquestions</em> field is the number of questions in the request; and
<em>questions</em> is an array of pointers to struct evdns_server_question.  Each
evdns_server_question includes the resource type of the request (see below
for a list of EVDNS_*_TYPE macros), the class of the request (typically
EVDNS_CLASS_INET), and the name of the requested hostname.</p><p class="translate">请求中的flags字段包含请求设置的DNS标志；nquestions字段是请求的数量；questions是指向struct evdns_server_question的指针数组。每个evdns_server_question包括请求的资源类型（下面有一个列表，列出了EVDNS_*_TYPE宏），请求的类别（通常是EVDNS_CLASS_INET），以及所请求的主机名。</p></div>
<div class="paragraph"><p>These structures were introduced in Libevent 1.3.  Before Libevent 1.4,
dns_question_class was called "class", which made trouble for the C++ people.
C programs that still use the old "class" name will stop working in a future
release.</p><p class="translate">这些结构是在Libevent 1.3中引入的。在Libevent 1.4之前，dns_question_class被称为"class"，这给C++使用者造成了麻烦。那些仍然使用旧的"class"名字的C程序将在未来的版本中停止工作。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>int</strong> evdns_server_request_get_requesting_addr(<strong>struct</strong> evdns_server_request *req,
        <strong>struct</strong> sockaddr *sa, <strong>int</strong> addr_len);</code></pre>
</div></div>
<div class="paragraph"><p>Sometimes you’ll want to know which address made a particular DNS request.
You can check this by calling evdns_server_request_get_requesting_addr() on
it.  You should pass in a sockaddr with enough storage to hold the address:
struct sockaddr_storage is recommended.</p><p class="translate">有时你可能想知道是哪个地址发出了特定的DNS请求。你可以通过对它调用evdns_server_request_get_requesting_addr()来检查。你应该传入一个足够存储地址的sockaddr：建议使用struct sockaddr_storage。</p></div>
<div class="paragraph"><p>This function was introduced in Libevent 1.3c.</p><p class="translate">这个函数是在Libevent 1.3c中引入的。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_responding_to_dns_requests">Responding to DNS requests</h2>
<div class="sectionbody">
<div class="paragraph"><p>Every time your DNS server receives a request, the request is passed to
the callback function you provided, along with your user_data pointer.  The
callback function must either respond to the request, ignore the request, or
make sure that the request is <em>eventually</em> answered or ignored.</p><p class="translate">每次你的DNS服务器收到一个请求时，这个请求都会被传递给你提供的回调函数，以及你的user_data指针。回调函数必须响应请求、忽略请求，或确保请求最终被回答或忽略。</p></div>
<div class="paragraph"><p>Before you respond to a request, you can add one or more answers to your
response:</p><p class="translate">在你响应一个请求之前，你可以向你的响应中添加一个或多个答案：</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>int</strong> evdns_server_request_add_a_reply(<strong>struct</strong> evdns_server_request *req,
    <strong>const</strong> <strong>char</strong> *name, <strong>int</strong> n, <strong>const</strong> <strong>void</strong> *addrs, <strong>int</strong> ttl);
<strong>int</strong> evdns_server_request_add_aaaa_reply(<strong>struct</strong> evdns_server_request *req,
    <strong>const</strong> <strong>char</strong> *name, <strong>int</strong> n, <strong>const</strong> <strong>void</strong> *addrs, <strong>int</strong> ttl);
<strong>int</strong> evdns_server_request_add_cname_reply(<strong>struct</strong> evdns_server_request *req,
    <strong>const</strong> <strong>char</strong> *name, <strong>const</strong> <strong>char</strong> *cname, <strong>int</strong> ttl);</code></pre>
</div></div>
<div class="paragraph"><p>The functions above all add a single RR (of type A, AAAA, or CNAME
respectively) to the answers section of a DNS reply for the request <em>req</em>.
In each case the argument <em>name</em> is the hostname to add an answer for, and
<em>ttl</em> is the time-to-live value of the answer in seconds.  For A and AAAA
records, <em>n</em> is the number of addresses to add, and <em>addrs</em> is a pointer to
the raw addresses, either given as a sequence of n*4 bytes for IPv4 addresses
in an A record, or as a sequence of n*16 bytes for IPv6 addresses in an AAAA
record.</p><p class="translate">以上函数都在DNS回复中为请求req添加了一个单独的资源记录（RR）（分别是类型A、AAAA或CNAME）。在每种情况下，name参数是要添加答案的主机名，ttl是答案的生存时间值，以秒为单位。对于A和AAAA记录，n是要添加的地址数量，addrs是指向原始地址的指针，要么是A记录中IPv4地址的n*4字节序列，要么是AAAA记录中IPv6地址的n*16字节序列。</p></div>
<div class="paragraph"><p>These functions return 0 on success and -1 on failure.</p><p class="translate">这些函数成功时返回0，失败时返回-1。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>int</strong> evdns_server_request_add_ptr_reply(<strong>struct</strong> evdns_server_request *req,
    <strong>struct</strong> in_addr *in, <strong>const</strong> <strong>char</strong> *inaddr_name, <strong>const</strong> <strong>char</strong> *hostname,
    <strong>int</strong> ttl);</code></pre>
</div></div>
<div class="paragraph"><p>This function adds a PTR record to the answer section of a request.  The
arguments <em>req</em> and <em>ttl</em> are as above.  You must provide exactly one of <em>in</em>
(an IPv4 address) or <em>inaddr_name</em> (an address in the .arpa domain) to
indicate which address you’re providing a response for.  The <em>hostname</em>
argument is the answer for the PTR lookup.</p><p class="translate">这个函数在请求的答案部分添加一个PTR记录。req和ttl的参数如上所述。你必须准确地提供in（一个IPv4地址）或inaddr_name（一个.arpa域中的地址）中的一个，以表明你正在为哪个地址提供响应。hostname参数是PTR查找的答案。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code>#define EVDNS_ANSWER_SECTION 0
#define EVDNS_AUTHORITY_SECTION 1
#define EVDNS_ADDITIONAL_SECTION 2

#define EVDNS_TYPE_A       1
#define EVDNS_TYPE_NS      2
#define EVDNS_TYPE_CNAME   5
#define EVDNS_TYPE_SOA     6
#define EVDNS_TYPE_PTR    12
#define EVDNS_TYPE_MX     15
#define EVDNS_TYPE_TXT    16
#define EVDNS_TYPE_AAAA   28

#define EVDNS_CLASS_INET   1

<strong>int</strong> evdns_server_request_add_reply(<strong>struct</strong> evdns_server_request *req,
    <strong>int</strong> section, <strong>const</strong> <strong>char</strong> *name, <strong>int</strong> type, <strong>int</strong> dns_class, <strong>int</strong> ttl,
    <strong>int</strong> datalen, <strong>int</strong> is_name, <strong>const</strong> <strong>char</strong> *data);</code></pre>
</div></div>
<div class="paragraph"><p>This function adds an arbitrary RR to the DNS reply of a request <em>req</em>.
The <em>section</em> argument describes which section to add it to, and should be
one of the EVDNS_*_SECTION values.  The <em>name</em> argument is the name field of
the RR.  The <em>type</em> argument is the <em>type</em> field of the RR, and should be one
of the EVDNS_TYPE_* values if possible.  The <em>dns_class</em> argument is the
class field of the RR, and should generally be EVDNS_CLASS_INET.  The <em>ttl</em>
argument is the time-to-live in seconds of the RR.  The rdata and rdlength
fields of the RR will be generated from the <em>datalen</em> bytes provided in
<em>data</em>.  If is_name is true, the data will be encoded as a DNS name (i.e.,
with DNS name compression).  Otherwise, it’s included verbatim.</p><p class="translate">这个函数为请求req的DNS回复添加了一个任意的资源记录（RR）。section参数描述了要将其添加到的部分，并且应该是EVDNS_*_SECTION值中的一个。name参数是RR的name字段。type参数是RR的type字段，如果可能的话，应该是EVDNS_TYPE_*值中的一个。dns_class参数是RR的class字段，通常应该是EVDNS_CLASS_INET。ttl参数是RR的生存时间，单位是秒。RR的rdata和rdlength字段将由提供的datalen字节的data生成。如果is_name为真，则数据会被编码为DNS名称（即，使用DNS名称压缩）。否则，它会按原样包含。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>int</strong> evdns_server_request_respond(<strong>struct</strong> evdns_server_request *req, <strong>int</strong> err);
<strong>int</strong> evdns_server_request_drop(<strong>struct</strong> evdns_server_request *req);</code></pre>
</div></div>
<div class="paragraph"><p>The evdns_server_request_respond() function sends a DNS response to a
request, including all of the RRs that you attached to it, with the error
code <em>err</em>.  If you get a request that you don’t want to respond to, you can
ignore it by calling evdns_server_request_drop() on it to release all the
associated memory and bookkeeping structures.</p><p class="translate">evdns_server_request_respond()函数发送一个DNS响应给一个请求，包括所有你附加到它的RR，以及错误代码err。如果你收到了一个你不想响应的请求，你可以通过在它上面调用evdns_server_request_drop()来释放所有关联的内存和结构。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code>#define EVDNS_FLAGS_AA  0x400
#define EVDNS_FLAGS_RD  0x080

<strong>void</strong> evdns_server_request_set_flags(<strong>struct</strong> evdns_server_request *req,
                                    <strong>int</strong> flags);</code></pre>
</div></div>
<div class="paragraph"><p>If you want to set any flags on your response message, you can call this
function at any time before you send the response.</p><p class="translate">如果你想在你的响应消息上设置任何标志，你可以在发送响应之前的任何时候调用这个函数。</p></div>
<div class="paragraph"><p>All the functions in this section were introduced in Libevent 1.3, except for
evdns_server_request_set_flags() which first appeared in Libevent 2.0.1-alpha.</p><p class="translate">本节中的所有函数都是在Libevent 1.3中引入的，除了evdns_server_request_set_flags()，它是在Libevent 2.0.1-alpha中首次出现的。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_dns_server_example">DNS Server example</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="title">Example: A trivial DNS responder</div>
<div class="content">
<pre><code>#include &lt;event2/dns.h&gt;
#include &lt;event2/dns_struct.h&gt;
#include &lt;event2/util.h&gt;
#include &lt;event2/event.h&gt;

#include &lt;sys/socket.h&gt;

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

<i>/* Let's try binding to 5353.  Port 53 is more traditional, but on most</i>
<i>   operating systems it requires root privileges. */</i>
#define LISTEN_PORT 5353

#define LOCALHOST_IPV4_ARPA "1.0.0.127.in-addr.arpa"
#define LOCALHOST_IPV6_ARPA ("1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0."         \
                             "0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa")

<strong>const</strong> ev_uint8_t LOCALHOST_IPV4[] = { 127, 0, 0, 1 };
<strong>const</strong> ev_uint8_t LOCALHOST_IPV6[] = { 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1 };

#define TTL 4242

<i>/* This toy DNS server callback answers requests for localhost (mapping it to</i>
<i>   127.0.0.1 or ::1) and for 127.0.0.1 or ::1 (mapping them to localhost).</i>
<i> */</i>
<strong>void</strong> server_callback(<strong>struct</strong> evdns_server_request *request, <strong>void</strong> *data)
{
    <strong>int</strong> i;
    <strong>int</strong> error=DNS_ERR_NONE;
<i>    /* We should try to answer all the questions.  Some DNS servers don't do</i>
<i>       this reliably, though, so you should think hard before putting two</i>
<i>       questions in one request yourself. */</i>
    <strong>for</strong> (i=0; i &lt; request-&gt;nquestions; ++i) {
        <strong>const</strong> <strong>struct</strong> evdns_server_question *q = request-&gt;questions[i];
        <strong>int</strong> ok=-1;
<i>        /* We don't use regular strcasecmp here, since we want a locale-</i>
<i>           independent comparison. */</i>
        <strong>if</strong> (0 == evutil_ascii_strcasecmp(q-&gt;name, "localhost")) {
            <strong>if</strong> (q-&gt;type == EVDNS_TYPE_A)
                ok = evdns_server_request_add_a_reply(
                       request, q-&gt;name, 1, LOCALHOST_IPV4, TTL);
            <strong>else</strong> <strong>if</strong> (q-&gt;type == EVDNS_TYPE_AAAA)
                ok = evdns_server_request_add_aaaa_reply(
                       request, q-&gt;name, 1, LOCALHOST_IPV6, TTL);
        } <strong>else</strong> <strong>if</strong> (0 == evutil_ascii_strcasecmp(q-&gt;name, LOCALHOST_IPV4_ARPA)) {
            <strong>if</strong> (q-&gt;type == EVDNS_TYPE_PTR)
                ok = evdns_server_request_add_ptr_reply(
                       request, NULL, q-&gt;name, "LOCALHOST", TTL);
        } <strong>else</strong> <strong>if</strong> (0 == evutil_ascii_strcasecmp(q-&gt;name, LOCALHOST_IPV6_ARPA)) {
            <strong>if</strong> (q-&gt;type == EVDNS_TYPE_PTR)
                ok = evdns_server_request_add_ptr_reply(
                       request, NULL, q-&gt;name, "LOCALHOST", TTL);
        } <strong>else</strong> {
            error = DNS_ERR_NOTEXIST;
        }
        <strong>if</strong> (ok&lt;0 &amp;&amp; error==DNS_ERR_NONE)
            error = DNS_ERR_SERVERFAILED;
    }
<i>    /* Now send the reply. */</i>
    evdns_server_request_respond(request, error);
}

<strong>int</strong> main(<strong>int</strong> argc, <strong>char</strong> **argv)
{
    <strong>struct</strong> event_base *base;
    <strong>struct</strong> evdns_server_port *server;
    evutil_socket_t server_fd;
    <strong>struct</strong> sockaddr_in listenaddr;

    base = event_base_new();
    <strong>if</strong> (!base)
        <strong>return</strong> 1;

    server_fd = socket(AF_INET, SOCK_DGRAM, 0);
    <strong>if</strong> (server_fd &lt; 0)
        <strong>return</strong> 2;
    memset(&amp;listenaddr, 0, <strong>sizeof</strong>(listenaddr));
    listenaddr.sin_family = AF_INET;
    listenaddr.sin_port = htons(LISTEN_PORT);
    listenaddr.sin_addr.s_addr = INADDR_ANY;
    <strong>if</strong> (bind(server_fd, (<strong>struct</strong> sockaddr*)&amp;listenaddr, <strong>sizeof</strong>(listenaddr))&lt;0)
        <strong>return</strong> 3;
<i>    /*The server will hijack the event loop after receiving the first request if the socket is blocking*/</i>
    <strong>if</strong>(evutil_make_socket_nonblocking(server_fd)&lt;0)
        <strong>return</strong> 4;
    server = evdns_add_server_port_with_base(base, server_fd, 0,
                                             server_callback, NULL);

    event_base_dispatch(base);

    evdns_close_server_port(server);
    event_base_free(base);

    <strong>return</strong> 0;
}</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_obsolete_dns_interfaces">Obsolete DNS interfaces</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="title">Obsolete Interfaces</div>
<div class="content">
<pre><code>void evdns_base_search_ndots_set(struct evdns_base *base,
                                 const int ndots);
int evdns_base_nameserver_add(struct evdns_base *base,
    unsigned long int address);
void evdns_set_random_bytes_fn(void (*fn)(char *, size_t));

struct evdns_server_port *evdns_add_server_port(evutil_socket_t socket,
    int flags, evdns_request_callback_fn_type callback, void *user_data);</code></pre>
</div></div>
<div class="paragraph"><p>Calling evdns_base_search_ndots_set() is equivalent to using
evdns_base_set_option() with the "ndots" option.</p><p class="translate">调用 evdns_base_search_ndots_set() 等同于使用带有 "ndots" 选项的 evdns_base_set_option()。</p></div>
<div class="paragraph"><p>The evdns_base_nameserver_add() function behaves as
evdns_base_nameserver_ip_add(), except it can only add nameservers
with IPv4 addresses.  It takes them, idiosyncratically, as four bytes
in network order.</p><p class="translate">evdns_base_nameserver_add() 函数的行为类似于 evdns_base_nameserver_ip_add()，不同之处在于它只能添加具有IPv4地址的名称服务器。它以一种特殊的方式接收它们，即以网络顺序的四个字节。</p></div>
<div class="paragraph"><p>Before Libevent 2.0.1-alpha, there was no way to specify a event base for a
DNS server port.  You had to use evdns_add_server_port() instead, which took
the default event_base.</p><p class="translate">在Libevent 2.0.1-alpha之前，无法为DNS服务器端口指定 event_base。你必须使用 evdns_add_server_port()，它采用默认的event_base。</p></div>
<div class="paragraph"><p>From Libevent 2.0.1-alpha through 2.0.3-alpha, you could use
evdns_set_random_bytes_fn to specify a function to use for generating
random numbers instead of evdns_set_transaction_id_fn.  It no longer
has any effect, now that Libevent provides its own secure RNG.</p><p class="translate">从Libevent 2.0.1-alpha到2.0.3-alpha，你可以使用 evdns_set_random_bytes_fn 来指定用于生成随机数的函数，而不是 evdns_set_transaction_id_fn。现在，由于Libevent提供其自己的安全随机数生成器（RNG），它不再有任何作用。</p></div>
<div class="paragraph"><p>The DNS_QUERY_NO_SEARCH flag has also been called DNS_NO_SEARCH.</p><p class="translate">DNS_QUERY_NO_SEARCH 标志也被称为 DNS_NO_SEARCH。</p></div>
<div class="paragraph"><p>Before Libevent 2.0.1-alpha, there was no separate notion of an evdns_base:
all information in the evdns subsystem was stored globally, and the functions
that manipulated it took no evdns_base as an argument.  They are all now
deprecated, and declared only in event2/dns_compat.h.  They are implemented
via a single global evdns_base; you can access this base by calling
the evdns_get_global_base() function introduced in Libevent 2.0.3-alpha.</p><p class="translate">在Libevent 2.0.1-alpha之前，没有单独的 evdns_base 概念：evdns 子系统中的所有信息都被全局存储，操作它的函数不接受 evdns_base 作为参数。它们现在都已被弃用，并且只在 event2/dns_compat.h 中声明。它们通过一个单一的全局 evdns_base 实现；你可以通过在Libevent 2.0.3-alpha中引入的 evdns_get_global_base() 函数访问这个base。</p></div>
<div class="tableblock">
<table rules="all" width="85%" frame="border" cellspacing="0" cellpadding="4">
<colgroup><col width="50%">
<col width="50%">
</colgroup><thead>
<tr>
<th align="left" valign="top"> Current function                           </th>
<th align="left" valign="top"> Obsolete global-evdns_base version</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">event_base_new()</p></td>
<td align="left" valign="top"><p class="table">evdns_init()</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">evdns_base_free()</p></td>
<td align="left" valign="top"><p class="table">evdns_shutdown()</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">evdns_base_nameserver_add()</p></td>
<td align="left" valign="top"><p class="table">evdns_nameserver_add()</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">evdns_base_count_nameservers()</p></td>
<td align="left" valign="top"><p class="table">evdns_count_nameservers()</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">evdns_base_clear_nameservers_and_suspend()</p></td>
<td align="left" valign="top"><p class="table">evdns_clear_nameservers_and_suspend()</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">evdns_base_resume()</p></td>
<td align="left" valign="top"><p class="table">evdns_resume()</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">evdns_base_nameserver_ip_add()</p></td>
<td align="left" valign="top"><p class="table">evdns_nameserver_ip_add()</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">evdns_base_resolve_ipv4()</p></td>
<td align="left" valign="top"><p class="table">evdns_resolve_ipv4()</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">evdns_base_resolve_ipv6()</p></td>
<td align="left" valign="top"><p class="table">evdns_resolve_ipv6()</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">evdns_base_resolve_reverse()</p></td>
<td align="left" valign="top"><p class="table">evdns_resolve_reverse()</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">evdns_base_resolve_reverse_ipv6()</p></td>
<td align="left" valign="top"><p class="table">evdns_resolve_reverse_ipv6()</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">evdns_base_set_option()</p></td>
<td align="left" valign="top"><p class="table">evdns_set_option()</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">evdns_base_resolv_conf_parse()</p></td>
<td align="left" valign="top"><p class="table">evdns_resolv_conf_parse()</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">evdns_base_search_clear()</p></td>
<td align="left" valign="top"><p class="table">evdns_search_clear()</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">evdns_base_search_add()</p></td>
<td align="left" valign="top"><p class="table">evdns_search_add()</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">evdns_base_search_ndots_set()</p></td>
<td align="left" valign="top"><p class="table">evdns_search_ndots_set()</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">evdns_base_config_windows_nameservers()</p></td>
<td align="left" valign="top"><p class="table">evdns_config_windows_nameservers()</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>The EVDNS_CONFIG_WINDOWS_NAMESERVERS_IMPLEMENTED macro is defined if and
only if evdns_config_windows_nameservers() is available.</p><p class="translate">如果且仅当 evdns_config_windows_nameservers() 可用时，才会定义 EVDNS_CONFIG_WINDOWS_NAMESERVERS_IMPLEMENTED 宏。</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr></div>
<div id="footer">
<div id="footer-text">
Last updated
 2024-02-18 20:10:44 UTC
</div>
</div>


</body></html>