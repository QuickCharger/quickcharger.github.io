<!--?xml version="1.0" encoding="UTF-8"?--><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8">
<meta name="generator" content="AsciiDoc 10.1.2">
<title>A tiny introduction to synchronous non-blocking IO</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overridden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-M3CEY418LQ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-M3CEY418LQ');
</script>
<style id="translation-style">
      .translate {
        background-color: #f0f0f0; /* 浅灰色背景 */
        color: black;             /* 黑色文本 */
        font-weight: bold;        /* 加粗字体 */
      }
    </style></head>
<body class="article">
<div id="header">
<h1>A tiny introduction to synchronous non-blocking IO</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="quoteblock">
<div class="content">
<div class="paragraph"><p>These documents are Copyright (c) 2009-2012 by Nick Mathewson, and are made
available under the Creative Commons Attribution-Noncommercial-Share Alike
license, version 3.0.  Future versions may be made available under a less
restrictive license.</p></div>
<div class="paragraph"><p>Additionally, the source code examples in these documents are also licensed
under the so-called "3-Clause" or "Modified" BSD license. See
<a href="license_bsd.html">the license_bsd file</a> distributed with these documents
for the full terms.</p></div>
<div class="paragraph"><p>To get the source for the latest version of this document, install git
and run "git clone git://github.com/libevent/libevent-book.git"</p></div>
</div>
<div class="attribution">
</div></div>
<div class="paragraph"><p>Most beginning programmers start with blocking IO calls.
An IO call is <em>synchronous</em> if, when you call it, it does not return
until the operation is completed, or until enough time
has passed that your network stack gives up.  When you call "connect()" on a TCP
connection, for example, your operating system queues a SYN packet to
the host on the other side of the TCP connection.  It does not return
control back to your application until either it has received a SYN ACK
packet from the opposite host, or until enough time has passed that it
decides to give up.</p><p class="translate">大多数初学者都是从阻塞IO调用开始的。一个IO调用是同步的，如果在你调用它时，它不会返回直到操作完成，或者直到过了足够的时间你的网络栈放弃为止。例如，当你在一个TCP链接上调用“connect()”时，你的操作系统会向TCP链接另一端的主机排队一个SYN包。它不会将控制权返回给你的应用程序，直到它从对面的主机收到一个SYN ACK包，或者直到过了足够的时间，它决定放弃为止。</p></div>
<div class="paragraph"><p>Here’s an example of a really simple client using blocking network
calls.  It opens a connection to www.google.com, sends it a simple
HTTP request, and prints the response to stdout.</p><p class="translate">这里有一个使用阻塞网络调用的非常简单的客户端示例。它打开一个到www.google.com的链接，向其发送一个简单的HTTP请求，并将响应打印到标准输出。</p></div>
<div class="listingblock">
<div class="title">Example: A simple blocking HTTP client</div>
<div class="content">
<pre><code><i>/* For sockaddr_in */</i>
#include &lt;netinet/in.h&gt;
<i>/* For socket functions */</i>
#include &lt;sys/socket.h&gt;
<i>/* For gethostbyname */</i>
#include &lt;netdb.h&gt;

#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

<strong>int</strong> main(<strong>int</strong> c, <strong>char</strong> **v)
{
    <strong>const</strong> <strong>char</strong> query[] =
        "GET / HTTP/1.0\r\n"
        "Host: www.google.com\r\n"
        "\r\n";
    <strong>const</strong> <strong>char</strong> hostname[] = "www.google.com";
    <strong>struct</strong> sockaddr_in sin;
    <strong>struct</strong> hostent *h;
    <strong>const</strong> <strong>char</strong> *cp;
    <strong>int</strong> fd;
    ssize_t n_written, remaining;
    <strong>char</strong> buf[1024];

<i>    /* Look up the IP address for the hostname.   Watch out; this isn't</i>
<i>       threadsafe on most platforms. */</i>
    h = gethostbyname(hostname);
    <strong>if</strong> (!h) {
        fprintf(stderr, "Couldn't lookup %s: %s", hostname, hstrerror(h_errno));
        <strong>return</strong> 1;
    }
    <strong>if</strong> (h-&gt;h_addrtype != AF_INET) {
        fprintf(stderr, "No ipv6 support, sorry.");
        <strong>return</strong> 1;
    }

<i>    /* Allocate a new socket */</i>
    fd = socket(AF_INET, SOCK_STREAM, 0);
    <strong>if</strong> (fd &lt; 0) {
        perror("socket");
        <strong>return</strong> 1;
    }

<i>    /* Connect to the remote host. */</i>
    sin.sin_family = AF_INET;
    sin.sin_port = htons(80);
    sin.sin_addr = *(<strong>struct</strong> in_addr*)h-&gt;h_addr;
    <strong>if</strong> (connect(fd, (<strong>struct</strong> sockaddr*) &amp;sin, <strong>sizeof</strong>(sin))) {
        perror("connect");
        close(fd);
        <strong>return</strong> 1;
    }

<i>    /* Write the query. */</i>
<i>    /* XXX Can send succeed partially? */</i>
    cp = query;
    remaining = strlen(query);
    <strong>while</strong> (remaining) {
      n_written = send(fd, cp, remaining, 0);
      <strong>if</strong> (n_written &lt;= 0) {
        perror("send");
        <strong>return</strong> 1;
      }
      remaining -= n_written;
      cp += n_written;
    }

<i>    /* Get an answer back. */</i>
    <strong>while</strong> (1) {
        ssize_t result = recv(fd, buf, <strong>sizeof</strong>(buf), 0);
        <strong>if</strong> (result == 0) {
            <strong>break</strong>;
        } <strong>else</strong> <strong>if</strong> (result &lt; 0) {
            perror("recv");
            close(fd);
            <strong>return</strong> 1;
        }
        fwrite(buf, 1, result, stdout);
    }

    close(fd);
    <strong>return</strong> 0;
}</code></pre>
</div></div>
<div class="paragraph"><p>All of the network calls in the code above are <em>blocking</em>: the
gethostbyname does not return until it has succeeded or failed in
resolving www.google.com; the connect does not return until it has
connected; the recv calls do not return until they have received data
or a close; and the send call does not return until it has at least
flushed its output to the kernel’s write buffers.</p><p class="translate">上面代码中的所有网络调用都是阻塞的：gethostbyname在成功(或失败)解析www.google.com之前不会返回；connect在链接上之前不会返回；recv调用在接收到数据或关闭之前不会返回；send调用在将数据刷新到内核的写缓冲区之前不会返回。</p></div>
<div class="paragraph"><p>Now, blocking IO is not necessarily evil.  If there’s nothing else you
wanted your program to do in the meantime, blocking IO will work fine
for you.  But suppose that you need to write a program to handle
multiple connections at once.  To make our example concrete: suppose
that you want to read input from two connections, and you don’t know
which connection will get input first.  You can’t say</p><p class="translate">并不是说阻塞IO就一定是坏事。如果你的程序暂时没有其他事情要做，阻塞IO对你来说会工作得很好。但假设你需要编写一个程序来同时处理多个链接。为了使我们的例子更具体：假设你想从两个链接中读取输入，而你不知道哪个链接会首先获得输入。你不能像下面这样：</p></div>
<div class="listingblock">
<div class="title">Bad Example</div>
<div class="content">
<pre><code><i>/* This won't work. */</i>
<strong>char</strong> buf[1024];
<strong>int</strong> i, n;
<strong>while</strong> (i_still_want_to_read()) {
    <strong>for</strong> (i=0; i&lt;n_sockets; ++i) {
        n = recv(fd[i], buf, <strong>sizeof</strong>(buf), 0);
        <strong>if</strong> (n==0)
            handle_close(fd[i]);
        <strong>else</strong> <strong>if</strong> (n&lt;0)
            handle_error(fd[i], errno);
        <strong>else</strong>
            handle_input(fd[i], buf, n);
    }
}</code></pre>
</div></div>
<div class="paragraph"><p>because if data arrives on fd[2] first, your program won’t even try
reading from fd[2] until the reads from fd[0] and fd[1] have gotten some
data and finished.</p><p class="translate">因为如果fd[2]的数据首先到达，你的程序甚至不会尝试从fd[2]读取，直到从fd[0]和fd[1]读取到一些数据并完成为止。</p></div>
<div class="paragraph"><p>Sometimes people solve this problem with multithreading, or with
multi-process servers.  One of the simplest ways to do multithreading
is with a separate process (or thread) to deal with each connection.
Since each connection has its own process, a blocking IO call that
waits for one connection won’t make any of the other connections'
processes block.</p><p class="translate">有时人们解决这个问题是通过多线程，或者多进程服务器。进行多线程的最简单方法之一是使用一个单独的进程（或线程）来处理每个链接。由于每个链接都有自己的进程，所以在等待一个链接时的阻塞IO调用不会使其他链接的进程阻塞。</p></div>
<div class="paragraph"><p>Here’s another example program.  It is a trivial server that listens
for TCP connections on port 40713, reads data from its input one line
at a time, and writes out the ROT13 obfuscation of line each as it
arrives.  It uses the Unix fork() call to create a new process for
each incoming connection.</p><p class="translate">这是另一个示例程序。这是一个简单的服务器，它在端口40713上监听TCP链接，一次从输入中读取一行数据，然后写出每行数据的ROT13加密版本。它使用Unix的fork()为每个新链接创建一个新线程。</p></div>
<div class="listingblock">
<div class="title">Example: Forking ROT13 server</div>
<div class="content">
<pre><code><i>/* For sockaddr_in */</i>
#include &lt;netinet/in.h&gt;
<i>/* For socket functions */</i>
#include &lt;sys/socket.h&gt;

#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAX_LINE 16384

<strong>char</strong>
rot13_char(<strong>char</strong> c)
{
<i>    /* We don't want to use isalpha here; setting the locale would change</i>
<i>     * which characters are considered alphabetical. */</i>
    <strong>if</strong> ((c &gt;= 'a' &amp;&amp; c &lt;= 'm') || (c &gt;= 'A' &amp;&amp; c &lt;= 'M'))
        <strong>return</strong> c + 13;
    <strong>else</strong> <strong>if</strong> ((c &gt;= 'n' &amp;&amp; c &lt;= 'z') || (c &gt;= 'N' &amp;&amp; c &lt;= 'Z'))
        <strong>return</strong> c - 13;
    <strong>else</strong>
        <strong>return</strong> c;
}

<strong>void</strong>
child(<strong>int</strong> fd)
{
    <strong>char</strong> outbuf[MAX_LINE+1];
    size_t outbuf_used = 0;
    ssize_t result;

    <strong>while</strong> (1) {
        <strong>char</strong> ch;
        result = recv(fd, &amp;ch, 1, 0);
        <strong>if</strong> (result == 0) {
            <strong>break</strong>;
        } <strong>else</strong> <strong>if</strong> (result == -1) {
            perror("read");
            <strong>break</strong>;
        }

<i>        /* We do this test to keep the user from overflowing the buffer. */</i>
        <strong>if</strong> (outbuf_used &lt; <strong>sizeof</strong>(outbuf)) {
            outbuf[outbuf_used++] = rot13_char(ch);
        }

        <strong>if</strong> (ch == '\n') {
            send(fd, outbuf, outbuf_used, 0);
            outbuf_used = 0;
            <strong>continue</strong>;
        }
    }
}

<strong>void</strong>
run(<strong>void</strong>)
{
    <strong>int</strong> listener;
    <strong>struct</strong> sockaddr_in sin;

    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = 0;
    sin.sin_port = htons(40713);

    listener = socket(AF_INET, SOCK_STREAM, 0);

#ifndef WIN32
    {
        <strong>int</strong> one = 1;
        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;one, <strong>sizeof</strong>(one));
    }
#endif

    <strong>if</strong> (bind(listener, (<strong>struct</strong> sockaddr*)&amp;sin, <strong>sizeof</strong>(sin)) &lt; 0) {
        perror("bind");
        <strong>return</strong>;
    }

    <strong>if</strong> (listen(listener, 16)&lt;0) {
        perror("listen");
        <strong>return</strong>;
    }



    <strong>while</strong> (1) {
        <strong>struct</strong> sockaddr_storage ss;
        socklen_t slen = <strong>sizeof</strong>(ss);
        <strong>int</strong> fd = accept(listener, (<strong>struct</strong> sockaddr*)&amp;ss, &amp;slen);
        <strong>if</strong> (fd &lt; 0) {
            perror("accept");
        } <strong>else</strong> {
            <strong>if</strong> (fork() == 0) {
                child(fd);
                exit(0);
            }
        }
    }
}

<strong>int</strong>
main(<strong>int</strong> c, <strong>char</strong> **v)
{
    run();
    <strong>return</strong> 0;
}</code></pre>
</div></div>
<div class="paragraph"><p>So, do we have the perfect solution for handling multiple connections
at once?  Can I stop writing this book and go work on something else
now?  Not quite.  First off, process creation (and even thread
creation) can be pretty expensive on some platforms.  In real life,
you’d want to use a thread pool instead of creating new processes.
But more fundamentally, threads won’t scale as much as you’d like.  If
your program needs to handle thousands or tens of thousands of
connections at a time, dealing with tens of thousands of threads will
not be as efficient as trying to have only a few threads per CPU.</p><p class="translate">那么，我们是否已经找到了一种完美的解决方案处理多连接？我现在可以停止写这本书，去做其他事情了吗？并不完全是。首先，进程创建（甚至线程创建）在某些平台上可能相当耗资源。在现实生活中，你会想使用线程池。但是更根本的是，线程的数量不如你想象的那样。如果你的程序需要同时处理数千个或数万个连接，处理数万个线程的效率不会像仅在每个CPU上只有几个线程那样高效。</p></div>
<div class="paragraph"><p>But if threading isn’t the answer to having multiple connections, what is?
In the Unix paradigm, you make your sockets <em>nonblocking</em>.  The Unix
call to do this is:</p><p class="translate">但是，如果线程不是处理多链接的答案，那么什么是呢？在Unix范例中，你会使你的socket变为非阻塞。Unix下的调用是：</p></div>
<div class="listingblock">
<div class="content">
<pre><code>fcntl(fd, F_SETFL, O_NONBLOCK);</code></pre>
</div></div>
<div class="paragraph"><p>where fd is the file descriptor for the socket.  <span class="footnote"><br>[A file descriptor is
the number the kernel assigns to the socket when you open it. You use
this number to make Unix calls referring to the socket.]<br></span>  Once you’ve
made fd (the socket) nonblocking, from then on, whenever you make a
network call to fd the call will either complete the operation
immediately or return with a special error code to indicate "I
couldn’t make any progress now, try again."  So our two-socket example
might be naively written as:</p><p class="translate">其中fd是socket的文件描述符。[1] 一旦你将fd（socket）设置为非阻塞，每当你对fd进行网络调用时，调用要么立即完成操作，要么返回一个特殊的错误码以指示“我现在无法取得任何进展，请再试一次。”所以我们的两个socket示例可能写成：</p></div>
<div class="listingblock">
<div class="title">Bad Example: busy-polling all sockets</div>
<div class="content">
<pre><code><i>/* This will work, but the performance will be unforgivably bad. */</i>
<strong>int</strong> i, n;
<strong>char</strong> buf[1024];
<strong>for</strong> (i=0; i &lt; n_sockets; ++i)
    fcntl(fd[i], F_SETFL, O_NONBLOCK);

<strong>while</strong> (i_still_want_to_read()) {
    <strong>for</strong> (i=0; i &lt; n_sockets; ++i) {
        n = recv(fd[i], buf, <strong>sizeof</strong>(buf), 0);
        <strong>if</strong> (n == 0) {
            handle_close(fd[i]);
        } <strong>else</strong> <strong>if</strong> (n &lt; 0) {
            <strong>if</strong> (errno == EAGAIN)
                 ; /* The kernel didn't have any data <strong>for</strong> us to read. */
            <strong>else</strong>
                 handle_error(fd[i], errno);
         } <strong>else</strong> {
            handle_input(fd[i], buf, n);
         }
    }
}</code></pre>
</div></div>
<div class="paragraph"><p>Now that we’re using nonblocking sockets, the code above would
<em>work</em>… but only barely.  The performance will be awful, for two
reasons.  First, when there is no data to read on either connection
the loop will spin indefinitely, using up all your CPU cycles.
Second, if you try to handle more than one or two connections with
this approach you’ll do a kernel call for each one, whether it has
any data for you or not.  So what we need is a way to tell the kernel
"wait until one of these sockets is ready to give me some data, and
tell me which ones are ready."</p><p class="translate">现在我们开始使用非阻塞套接字，上面的代码会工作……但仅仅是勉强可行。性能会非常糟糕，原因有二。首先，如果两个链接都没有数据可读，循环将无限运行，耗尽你所有的CPU周期。其次，如果你尝试用这种方法处理超过一两个连接，你会发现不管是否有数据，每个连接都会执行一个内核调用。所以我们需要的是一种方法，告诉内核“等待，直到这些socket中的一个准备好给我一些数据，并告诉我是哪个准备好了。”</p></div>
<div class="paragraph"><p>The oldest solution that people still use for this problem is
select().  The select() call takes three sets of fds (implemented as
bit arrays): one for reading, one for writing, and one for
"exceptions".  It waits until a socket from one of the sets is ready
and alters the sets to contain only the sockets ready for use.</p><p class="translate">人们仍然使用的解决这个问题的最古老方法是select()。select()调用接收三组fds（实现为位数组）：一组用于读取，一组用于写入，一组用于“异常”。它等待直到来自其中一组的socket准备就绪，并更改集合以只包含准备使用的socket。</p></div>
<div class="paragraph"><p>Here is our example again, using select:</p></div>
<div class="listingblock">
<div class="title">Example: Using select</div>
<div class="content">
<pre><code><i>/* If you only have a couple dozen fds, this version won't be awful */</i>
fd_set readset;
<strong>int</strong> i, n;
<strong>char</strong> buf[1024];

<strong>while</strong> (i_still_want_to_read()) {
    <strong>int</strong> maxfd = -1;
    FD_ZERO(&amp;readset);

<i>    /* Add all of the interesting fds to readset */</i>
    <strong>for</strong> (i=0; i &lt; n_sockets; ++i) {
         <strong>if</strong> (fd[i]&gt;maxfd) maxfd = fd[i];
         FD_SET(fd[i], &amp;readset);
    }

<i>    /* Wait until one or more fds are ready to read */</i>
    select(maxfd+1, &amp;readset, NULL, NULL, NULL);

<i>    /* Process all of the fds that are still set in readset */</i>
    <strong>for</strong> (i=0; i &lt; n_sockets; ++i) {
        <strong>if</strong> (FD_ISSET(fd[i], &amp;readset)) {
            n = recv(fd[i], buf, <strong>sizeof</strong>(buf), 0);
            <strong>if</strong> (n == 0) {
                handle_close(fd[i]);
            } <strong>else</strong> <strong>if</strong> (n &lt; 0) {
                <strong>if</strong> (errno == EAGAIN)
                     ; /* The kernel didn't have any data <strong>for</strong> us to read. */
                <strong>else</strong>
                     handle_error(fd[i], errno);
             } <strong>else</strong> {
                handle_input(fd[i], buf, n);
             }
        }
    }
}</code></pre>
</div></div>
<div class="paragraph"><p>And here’s a reimplementation of our ROT13 server, using select() this
time.</p></div>
<div class="listingblock">
<div class="title">Example: select()-based ROT13 server</div>
<div class="content">
<pre><code><i>/* For sockaddr_in */</i>
#include &lt;netinet/in.h&gt;
<i>/* For socket functions */</i>
#include &lt;sys/socket.h&gt;
<i>/* For fcntl */</i>
#include &lt;fcntl.h&gt;
<i>/* for select */</i>
#include &lt;sys/select.h&gt;

#include &lt;assert.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;

#define MAX_LINE 16384

<strong>char</strong>
rot13_char(<strong>char</strong> c)
{
<i>    /* We don't want to use isalpha here; setting the locale would change</i>
<i>     * which characters are considered alphabetical. */</i>
    <strong>if</strong> ((c &gt;= 'a' &amp;&amp; c &lt;= 'm') || (c &gt;= 'A' &amp;&amp; c &lt;= 'M'))
        <strong>return</strong> c + 13;
    <strong>else</strong> <strong>if</strong> ((c &gt;= 'n' &amp;&amp; c &lt;= 'z') || (c &gt;= 'N' &amp;&amp; c &lt;= 'Z'))
        <strong>return</strong> c - 13;
    <strong>else</strong>
        <strong>return</strong> c;
}

<strong>struct</strong> fd_state {
    <strong>char</strong> buffer[MAX_LINE];
    size_t buffer_used;

    <strong>int</strong> writing;
    size_t n_written;
    size_t write_upto;
};

<strong>struct</strong> fd_state *
alloc_fd_state(<strong>void</strong>)
{
    <strong>struct</strong> fd_state *state = malloc(<strong>sizeof</strong>(<strong>struct</strong> fd_state));
    <strong>if</strong> (!state)
        <strong>return</strong> NULL;
    state-&gt;buffer_used = state-&gt;n_written = state-&gt;writing =
        state-&gt;write_upto = 0;
    <strong>return</strong> state;
}

<strong>void</strong>
free_fd_state(<strong>struct</strong> fd_state *state)
{
    free(state);
}

<strong>void</strong>
make_nonblocking(<strong>int</strong> fd)
{
    fcntl(fd, F_SETFL, O_NONBLOCK);
}

<strong>int</strong>
do_read(<strong>int</strong> fd, <strong>struct</strong> fd_state *state)
{
    <strong>char</strong> buf[1024];
    <strong>int</strong> i;
    ssize_t result;
    <strong>while</strong> (1) {
        result = recv(fd, buf, <strong>sizeof</strong>(buf), 0);
        <strong>if</strong> (result &lt;= 0)
            <strong>break</strong>;

        <strong>for</strong> (i=0; i &lt; result; ++i)  {
            <strong>if</strong> (state-&gt;buffer_used &lt; <strong>sizeof</strong>(state-&gt;buffer))
                state-&gt;buffer[state-&gt;buffer_used++] = rot13_char(buf[i]);
            <strong>if</strong> (buf[i] == '\n') {
                state-&gt;writing = 1;
                state-&gt;write_upto = state-&gt;buffer_used;
            }
        }
    }

    <strong>if</strong> (result == 0) {
        <strong>return</strong> 1;
    } <strong>else</strong> <strong>if</strong> (result &lt; 0) {
        <strong>if</strong> (errno == EAGAIN)
            <strong>return</strong> 0;
        <strong>return</strong> -1;
    }

    <strong>return</strong> 0;
}

<strong>int</strong>
do_write(<strong>int</strong> fd, <strong>struct</strong> fd_state *state)
{
    <strong>while</strong> (state-&gt;n_written &lt; state-&gt;write_upto) {
        ssize_t result = send(fd, state-&gt;buffer + state-&gt;n_written,
                              state-&gt;write_upto - state-&gt;n_written, 0);
        <strong>if</strong> (result &lt; 0) {
            <strong>if</strong> (errno == EAGAIN)
                <strong>return</strong> 0;
            <strong>return</strong> -1;
        }
        assert(result != 0);

        state-&gt;n_written += result;
    }

    <strong>if</strong> (state-&gt;n_written == state-&gt;buffer_used)
        state-&gt;n_written = state-&gt;write_upto = state-&gt;buffer_used = 0;

    state-&gt;writing = 0;

    <strong>return</strong> 0;
}

<strong>void</strong>
run(<strong>void</strong>)
{
    <strong>int</strong> listener;
    <strong>struct</strong> fd_state *state[FD_SETSIZE];
    <strong>struct</strong> sockaddr_in sin;
    <strong>int</strong> i, maxfd;
    fd_set readset, writeset, exset;

    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = 0;
    sin.sin_port = htons(40713);

    <strong>for</strong> (i = 0; i &lt; FD_SETSIZE; ++i)
        state[i] = NULL;

    listener = socket(AF_INET, SOCK_STREAM, 0);
    make_nonblocking(listener);

#ifndef WIN32
    {
        <strong>int</strong> one = 1;
        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;one, <strong>sizeof</strong>(one));
    }
#endif

    <strong>if</strong> (bind(listener, (<strong>struct</strong> sockaddr*)&amp;sin, <strong>sizeof</strong>(sin)) &lt; 0) {
        perror("bind");
        <strong>return</strong>;
    }

    <strong>if</strong> (listen(listener, 16)&lt;0) {
        perror("listen");
        <strong>return</strong>;
    }

    FD_ZERO(&amp;readset);
    FD_ZERO(&amp;writeset);
    FD_ZERO(&amp;exset);

    <strong>while</strong> (1) {
        maxfd = listener;

        FD_ZERO(&amp;readset);
        FD_ZERO(&amp;writeset);
        FD_ZERO(&amp;exset);

        FD_SET(listener, &amp;readset);

        <strong>for</strong> (i=0; i &lt; FD_SETSIZE; ++i) {
            <strong>if</strong> (state[i]) {
                <strong>if</strong> (i &gt; maxfd)
                    maxfd = i;
                FD_SET(i, &amp;readset);
                <strong>if</strong> (state[i]-&gt;writing) {
                    FD_SET(i, &amp;writeset);
                }
            }
        }

        <strong>if</strong> (select(maxfd+1, &amp;readset, &amp;writeset, &amp;exset, NULL) &lt; 0) {
            perror("select");
            <strong>return</strong>;
        }

        <strong>if</strong> (FD_ISSET(listener, &amp;readset)) {
            <strong>struct</strong> sockaddr_storage ss;
            socklen_t slen = <strong>sizeof</strong>(ss);
            <strong>int</strong> fd = accept(listener, (<strong>struct</strong> sockaddr*)&amp;ss, &amp;slen);
            <strong>if</strong> (fd &lt; 0) {
                perror("accept");
            } <strong>else</strong> <strong>if</strong> (fd &gt; FD_SETSIZE) {
                close(fd);
            } <strong>else</strong> {
                make_nonblocking(fd);
                state[fd] = alloc_fd_state();
                assert(state[fd]);/*XXX*/
            }
        }

        <strong>for</strong> (i=0; i &lt; maxfd+1; ++i) {
            <strong>int</strong> r = 0;
            <strong>if</strong> (i == listener)
                <strong>continue</strong>;

            <strong>if</strong> (FD_ISSET(i, &amp;readset)) {
                r = do_read(i, state[i]);
            }
            <strong>if</strong> (r == 0 &amp;&amp; FD_ISSET(i, &amp;writeset)) {
                r = do_write(i, state[i]);
            }
            <strong>if</strong> (r) {
                free_fd_state(state[i]);
                state[i] = NULL;
                close(i);
            }
        }
    }
}

<strong>int</strong>
main(<strong>int</strong> c, <strong>char</strong> **v)
{
    setvbuf(stdout, NULL, _IONBF, 0);

    run();
    <strong>return</strong> 0;
}</code></pre>
</div></div>
<div class="paragraph"><p>But we’re still not done.  Because generating and reading the select()
bit arrays takes time proportional to the largest fd that you provided
for select(), the select() call scales terribly when the number of
sockets is high.  <span class="footnote"><br>[On the userspace side, generating and
reading the bit arrays can be made to take time proportional to the
number of fds that you provided for select().  But on the kernel side,
reading the bit arrays takes time proportional to the largest fd in the
bit array, which tends to be around <em>the total number of fds in use in
the whole program</em>, regardless of how many fds are added to the sets in
select().]<br></span></p><p class="translate">但我们还没有完成。因为生成和读取select()位数组所需的时间与你为select()提供的最大fd成正比，当socket数量很高时，select()调用的扩展性非常糟糕。</p></div>
<div class="paragraph"><p>Different operating systems have provided different replacement
functions for select.  These include poll(), epoll(), kqueue(),
evports, and /dev/poll.  All of these give better performance than
select(), and all but poll() give O(1) performance for adding a socket,
removing a socket, and for noticing
that a socket is ready for IO.</p><p class="translate">不同的操作系统提供了select的不同替代函数。这些包括poll()、epoll()、kqueue()、evports和/dev/poll。所有这些都比select()提供了更好的性能，在移除socket或socket的读写方面。(除了poll()在添加socket时的性能是O(1))。</p></div>
<div class="paragraph"><p>Unfortunately, none of the efficient interfaces is a ubiquitous
standard.  Linux has epoll(), the BSDs (including Darwin) have
kqueue(), Solaris has evports and /dev/poll… <em>and none of these
operating systems has any of the others</em>.  So if you want to write a
portable high-performance asynchronous application, you’ll need an
abstraction that wraps all of these interfaces, and provides whichever
one of them is the most efficient.</p><p class="translate">不幸的是，这些都不是普遍标准。Linux有epoll()，BSDs（包括Darwin）有kqueue()，Solaris有evports和/dev/poll……这些操作系统都没有其他的。因此，如果你想要编写一个可移植的高性能异步应用程序，你将需要一个抽象层，它包装了所有这些接口，并提供了最高效的一个。</p></div>
<div class="paragraph"><p>And that’s what the lowest level of the Libevent API does for you.  It
provides a consistent interface to various select() replacements,
using the most efficient version available on the computer where it’s
running.</p><p class="translate">这正是Libevent API最底层为你所做的。它为各种select()替代品提供了一个一致的接口，使用在其运行的计算机上可用的最高效版本。</p></div>
<div class="paragraph"><p>Here’s yet another version of our non-blocking ROT13 server.  This
time, it uses Libevent 2 instead of select().  Note that the fd_sets
are gone now: instead, we associate and disassociate events with a
struct event_base, which might be implemented in terms of select(),
poll(), epoll(), kqueue(), etc.</p><p class="translate">这是我们非阻塞ROT13的又一个版本。这次，它使用的是Libevent 2而不是select()。请注意，fd_sets现在已经消失了：相反，我们使用struct event_base关联和解除事件，它可能在select()、poll()、epoll()、kqueue()等方面得到了实现。</p></div>
<div class="listingblock">
<div class="title">Example: A low-level ROT13 server with Libevent</div>
<div class="content">
<pre><code><i>/* For sockaddr_in */</i>
#include &lt;netinet/in.h&gt;
<i>/* For socket functions */</i>
#include &lt;sys/socket.h&gt;
<i>/* For fcntl */</i>
#include &lt;fcntl.h&gt;

#include &lt;event2/event.h&gt;

#include &lt;assert.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;

#define MAX_LINE 16384

<strong>void</strong> do_read(evutil_socket_t fd, <strong>short</strong> events, <strong>void</strong> *arg);
<strong>void</strong> do_write(evutil_socket_t fd, <strong>short</strong> events, <strong>void</strong> *arg);

<strong>char</strong>
rot13_char(<strong>char</strong> c)
{
<i>    /* We don't want to use isalpha here; setting the locale would change</i>
<i>     * which characters are considered alphabetical. */</i>
    <strong>if</strong> ((c &gt;= 'a' &amp;&amp; c &lt;= 'm') || (c &gt;= 'A' &amp;&amp; c &lt;= 'M'))
        <strong>return</strong> c + 13;
    <strong>else</strong> <strong>if</strong> ((c &gt;= 'n' &amp;&amp; c &lt;= 'z') || (c &gt;= 'N' &amp;&amp; c &lt;= 'Z'))
        <strong>return</strong> c - 13;
    <strong>else</strong>
        <strong>return</strong> c;
}

<strong>struct</strong> fd_state {
    <strong>char</strong> buffer[MAX_LINE];
    size_t buffer_used;

    size_t n_written;
    size_t write_upto;

    <strong>struct</strong> event *read_event;
    <strong>struct</strong> event *write_event;
};

<strong>struct</strong> fd_state *
alloc_fd_state(<strong>struct</strong> event_base *base, evutil_socket_t fd)
{
    <strong>struct</strong> fd_state *state = malloc(<strong>sizeof</strong>(<strong>struct</strong> fd_state));
    <strong>if</strong> (!state)
        <strong>return</strong> NULL;
    state-&gt;read_event = event_new(base, fd, EV_READ|EV_PERSIST, do_read, state);
    <strong>if</strong> (!state-&gt;read_event) {
        free(state);
        <strong>return</strong> NULL;
    }
    state-&gt;write_event =
        event_new(base, fd, EV_WRITE|EV_PERSIST, do_write, state);

    <strong>if</strong> (!state-&gt;write_event) {
        event_free(state-&gt;read_event);
        free(state);
        <strong>return</strong> NULL;
    }

    state-&gt;buffer_used = state-&gt;n_written = state-&gt;write_upto = 0;

    assert(state-&gt;write_event);
    <strong>return</strong> state;
}

<strong>void</strong>
free_fd_state(<strong>struct</strong> fd_state *state)
{
    event_free(state-&gt;read_event);
    event_free(state-&gt;write_event);
    free(state);
}

<strong>void</strong>
do_read(evutil_socket_t fd, <strong>short</strong> events, <strong>void</strong> *arg)
{
    <strong>struct</strong> fd_state *state = arg;
    <strong>char</strong> buf[1024];
    <strong>int</strong> i;
    ssize_t result;
    <strong>while</strong> (1) {
        assert(state-&gt;write_event);
        result = recv(fd, buf, <strong>sizeof</strong>(buf), 0);
        <strong>if</strong> (result &lt;= 0)
            <strong>break</strong>;

        <strong>for</strong> (i=0; i &lt; result; ++i)  {
            <strong>if</strong> (state-&gt;buffer_used &lt; <strong>sizeof</strong>(state-&gt;buffer))
                state-&gt;buffer[state-&gt;buffer_used++] = rot13_char(buf[i]);
            <strong>if</strong> (buf[i] == '\n') {
                assert(state-&gt;write_event);
                event_add(state-&gt;write_event, NULL);
                state-&gt;write_upto = state-&gt;buffer_used;
            }
        }
    }

    <strong>if</strong> (result == 0) {
        free_fd_state(state);
    } <strong>else</strong> <strong>if</strong> (result &lt; 0) {
        <strong>if</strong> (errno == EAGAIN) <i>// XXXX use evutil macro</i>
            <strong>return</strong>;
        perror("recv");
        free_fd_state(state);
    }
}

<strong>void</strong>
do_write(evutil_socket_t fd, <strong>short</strong> events, <strong>void</strong> *arg)
{
    <strong>struct</strong> fd_state *state = arg;

    <strong>while</strong> (state-&gt;n_written &lt; state-&gt;write_upto) {
        ssize_t result = send(fd, state-&gt;buffer + state-&gt;n_written,
                              state-&gt;write_upto - state-&gt;n_written, 0);
        <strong>if</strong> (result &lt; 0) {
            <strong>if</strong> (errno == EAGAIN) <i>// XXX use evutil macro</i>
                <strong>return</strong>;
            free_fd_state(state);
            <strong>return</strong>;
        }
        assert(result != 0);

        state-&gt;n_written += result;
    }

    <strong>if</strong> (state-&gt;n_written == state-&gt;buffer_used)
        state-&gt;n_written = state-&gt;write_upto = state-&gt;buffer_used = 0;

    event_del(state-&gt;write_event);
}

<strong>void</strong>
do_accept(evutil_socket_t listener, <strong>short</strong> event, <strong>void</strong> *arg)
{
    <strong>struct</strong> event_base *base = arg;
    <strong>struct</strong> sockaddr_storage ss;
    socklen_t slen = <strong>sizeof</strong>(ss);
    <strong>int</strong> fd = accept(listener, (<strong>struct</strong> sockaddr*)&amp;ss, &amp;slen);
    <strong>if</strong> (fd &lt; 0) { <i>// XXXX eagain??</i>
        perror("accept");
    } <strong>else</strong> <strong>if</strong> (fd &gt; FD_SETSIZE) {
        close(fd); <i>// XXX replace all closes with EVUTIL_CLOSESOCKET */</i>
    } <strong>else</strong> {
        <strong>struct</strong> fd_state *state;
        evutil_make_socket_nonblocking(fd);
        state = alloc_fd_state(base, fd);
        assert(state); /*XXX err*/
        assert(state-&gt;write_event);
        event_add(state-&gt;read_event, NULL);
    }
}

<strong>void</strong>
run(<strong>void</strong>)
{
    evutil_socket_t listener;
    <strong>struct</strong> sockaddr_in sin;
    <strong>struct</strong> event_base *base;
    <strong>struct</strong> event *listener_event;

    base = event_base_new();
    <strong>if</strong> (!base)
        <strong>return</strong>; /*XXXerr*/

    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = 0;
    sin.sin_port = htons(40713);

    listener = socket(AF_INET, SOCK_STREAM, 0);
    evutil_make_socket_nonblocking(listener);

#ifndef WIN32
    {
        <strong>int</strong> one = 1;
        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;one, <strong>sizeof</strong>(one));
    }
#endif

    <strong>if</strong> (bind(listener, (<strong>struct</strong> sockaddr*)&amp;sin, <strong>sizeof</strong>(sin)) &lt; 0) {
        perror("bind");
        <strong>return</strong>;
    }

    <strong>if</strong> (listen(listener, 16)&lt;0) {
        perror("listen");
        <strong>return</strong>;
    }

    listener_event = event_new(base, listener, EV_READ|EV_PERSIST, do_accept, (<strong>void</strong>*)base);
<i>    /*XXX check it */</i>
    event_add(listener_event, NULL);

    event_base_dispatch(base);
}

<strong>int</strong>
main(<strong>int</strong> c, <strong>char</strong> **v)
{
    setvbuf(stdout, NULL, _IONBF, 0);

    run();
    <strong>return</strong> 0;
}</code></pre>
</div></div>
<div class="paragraph"><p>(Other things to note in the code: instead of typing the sockets as
"int", we’re using the type evutil_socket_t.  Instead of calling
fcntl(O_NONBLOCK) to make the sockets nonblocking, we’re calling
evutil_make_socket_nonblocking.  These changes make our code compatible
with the divergent parts of the Win32 networking API.)</p><p class="translate">（代码中的其他需要注意的事项：我们没有将socket类型定义为"int"，而是使用了类型evutil_socket_t。我们没有调用fcntl(O_NONBLOCK)来使socket非阻塞，而是调用了evutil_make_socket_nonblocking。这些更改使我们的代码与Win32网络API不同的部分做到了兼容。）</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_what_about_convenience_and_what_about_windows">What about convenience?  (and what about Windows?)</h2>
<div class="sectionbody">
<div class="paragraph"><p>You’ve probably noticed that as our code has gotten more efficient,
it has also gotten more complex.  Back when we were forking, we didn’t
have to manage a buffer for each connection: we just had a separate
stack-allocated buffer for each process.  We didn’t need to explicitly
track whether each socket was reading or writing: that was implicit in
our location in the code.  And we didn’t need a structure to track how
much of each operation had completed: we just used loops and stack
variables.</p><p class="translate">你可能已经注意到了，随着我们的代码变得更高效，它也变得更复杂。回到我们使用fork时，我们不需要为每个链接管理一个缓冲区：我们为每个进程分配了一个栈缓冲区。我们不需要明确地跟踪每个socket是在读还是写：这在我们的代码位置中是隐含的。我们也不需要一个结构来跟踪每个操作完成了多少：我们只是使用循环和栈变量。</p></div>
<div class="paragraph"><p>Moreover, if you’re deeply experienced with networking on Windows,
you’ll realize that Libevent probably isn’t getting optimal
performance when it’s used as in the example above.  On Windows, the
way you do fast non-blocking IO is not with a select()-like interface:
it’s by using the IOCP (IO Completion Ports) API.  Unlike all the
fast networking APIs, IOCP does not alert your program when a socket
is <em>ready</em> for an operation that your program then has to perform.
Instead, the program tells the Windows networking stack to <em>start</em> a
network operation, and IOCP tells the program when the operation has
finished.</p><p class="translate">此外，如果你对Windows上的网络编程有深入的了解，你会意识到当Libevent像上面的例子那样使用时，可能无法获得最佳性能。在Windows上，进行非阻塞IO的方式不是使用类似select()的接口：而是使用IOCP（输入输出完成端口）API。与所有快速网络API不同，IOCP不会在socket准备好进行操作时通知你的程序，然后你的程序必须执行该操作。相反，程序告诉Windows网络栈开始一个网络操作，而IOCP会告诉程序该操作何时完成。</p></div>
<div class="paragraph"><p>Fortunately, the Libevent 2 "bufferevents" interface solves both of
these issues: it makes programs much simpler to write, and provides
an interface that Libevent can implement efficiently on Windows <em>and</em>
on Unix.</p><p class="translate">幸运的是，Libevent 2的"bufferevents"接口解决了这两个问题：它使程序编写得更简单，并提供了一个接口，Libevent可以在Windows和Unix上高效实现。</p></div>
<div class="paragraph"><p>Here’s our ROT13 server one last time, using the bufferevents API.</p><p class="translate">这是我们ROT13服务器的最后一次演示，使用bufferevents API。</p></div>
<div class="listingblock">
<div class="title">Example: A simpler ROT13 server with Libevent</div>
<div class="content">
<pre><code><i>/* For sockaddr_in */</i>
#include &lt;netinet/in.h&gt;
<i>/* For socket functions */</i>
#include &lt;sys/socket.h&gt;
<i>/* For fcntl */</i>
#include &lt;fcntl.h&gt;

#include &lt;event2/event.h&gt;
#include &lt;event2/buffer.h&gt;
#include &lt;event2/bufferevent.h&gt;

#include &lt;assert.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;

#define MAX_LINE 16384

<strong>void</strong> do_read(evutil_socket_t fd, <strong>short</strong> events, <strong>void</strong> *arg);
<strong>void</strong> do_write(evutil_socket_t fd, <strong>short</strong> events, <strong>void</strong> *arg);

<strong>char</strong>
rot13_char(<strong>char</strong> c)
{
<i>    /* We don't want to use isalpha here; setting the locale would change</i>
<i>     * which characters are considered alphabetical. */</i>
    <strong>if</strong> ((c &gt;= 'a' &amp;&amp; c &lt;= 'm') || (c &gt;= 'A' &amp;&amp; c &lt;= 'M'))
        <strong>return</strong> c + 13;
    <strong>else</strong> <strong>if</strong> ((c &gt;= 'n' &amp;&amp; c &lt;= 'z') || (c &gt;= 'N' &amp;&amp; c &lt;= 'Z'))
        <strong>return</strong> c - 13;
    <strong>else</strong>
        <strong>return</strong> c;
}

<strong>void</strong>
readcb(<strong>struct</strong> bufferevent *bev, <strong>void</strong> *ctx)
{
    <strong>struct</strong> evbuffer *input, *output;
    <strong>char</strong> *line;
    size_t n;
    <strong>int</strong> i;
    input = bufferevent_get_input(bev);
    output = bufferevent_get_output(bev);

    <strong>while</strong> ((line = evbuffer_readln(input, &amp;n, EVBUFFER_EOL_LF))) {
        <strong>for</strong> (i = 0; i &lt; n; ++i)
            line[i] = rot13_char(line[i]);
        evbuffer_add(output, line, n);
        evbuffer_add(output, "\n", 1);
        free(line);
    }

    <strong>if</strong> (evbuffer_get_length(input) &gt;= MAX_LINE) {
<i>        /* Too long; just process what there is and go on so that the buffer</i>
<i>         * doesn't grow infinitely long. */</i>
        <strong>char</strong> buf[1024];
        <strong>while</strong> (evbuffer_get_length(input)) {
            <strong>int</strong> n = evbuffer_remove(input, buf, <strong>sizeof</strong>(buf));
            <strong>for</strong> (i = 0; i &lt; n; ++i)
                buf[i] = rot13_char(buf[i]);
            evbuffer_add(output, buf, n);
        }
        evbuffer_add(output, "\n", 1);
    }
}

<strong>void</strong>
errorcb(<strong>struct</strong> bufferevent *bev, <strong>short</strong> error, <strong>void</strong> *ctx)
{
    <strong>if</strong> (error &amp; BEV_EVENT_EOF) {
<i>        /* connection has been closed, do any clean up here */</i>
<i>        /* ... */</i>
    } <strong>else</strong> <strong>if</strong> (error &amp; BEV_EVENT_ERROR) {
<i>        /* check errno to see what error occurred */</i>
<i>        /* ... */</i>
    } <strong>else</strong> <strong>if</strong> (error &amp; BEV_EVENT_TIMEOUT) {
<i>        /* must be a timeout event handle, handle it */</i>
<i>        /* ... */</i>
    }
    bufferevent_free(bev);
}

<strong>void</strong>
do_accept(evutil_socket_t listener, <strong>short</strong> event, <strong>void</strong> *arg)
{
    <strong>struct</strong> event_base *base = arg;
    <strong>struct</strong> sockaddr_storage ss;
    socklen_t slen = <strong>sizeof</strong>(ss);
    <strong>int</strong> fd = accept(listener, (<strong>struct</strong> sockaddr*)&amp;ss, &amp;slen);
    <strong>if</strong> (fd &lt; 0) {
        perror("accept");
    } <strong>else</strong> <strong>if</strong> (fd &gt; FD_SETSIZE) {
        close(fd);
    } <strong>else</strong> {
        <strong>struct</strong> bufferevent *bev;
        evutil_make_socket_nonblocking(fd);
        bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);
        bufferevent_setcb(bev, readcb, NULL, errorcb, NULL);
        bufferevent_setwatermark(bev, EV_READ, 0, MAX_LINE);
        bufferevent_enable(bev, EV_READ|EV_WRITE);
    }
}

<strong>void</strong>
run(<strong>void</strong>)
{
    evutil_socket_t listener;
    <strong>struct</strong> sockaddr_in sin;
    <strong>struct</strong> event_base *base;
    <strong>struct</strong> event *listener_event;

    base = event_base_new();
    <strong>if</strong> (!base)
        <strong>return</strong>; /*XXXerr*/

    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = 0;
    sin.sin_port = htons(40713);

    listener = socket(AF_INET, SOCK_STREAM, 0);
    evutil_make_socket_nonblocking(listener);

#ifndef WIN32
    {
        <strong>int</strong> one = 1;
        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;one, <strong>sizeof</strong>(one));
    }
#endif

    <strong>if</strong> (bind(listener, (<strong>struct</strong> sockaddr*)&amp;sin, <strong>sizeof</strong>(sin)) &lt; 0) {
        perror("bind");
        <strong>return</strong>;
    }

    <strong>if</strong> (listen(listener, 16)&lt;0) {
        perror("listen");
        <strong>return</strong>;
    }

    listener_event = event_new(base, listener, EV_READ|EV_PERSIST, do_accept, (<strong>void</strong>*)base);
<i>    /*XXX check it */</i>
    event_add(listener_event, NULL);

    event_base_dispatch(base);
}

<strong>int</strong>
main(<strong>int</strong> c, <strong>char</strong> **v)
{
    setvbuf(stdout, NULL, _IONBF, 0);

    run();
    <strong>return</strong> 0;
}</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_how_efficient_is_all_of_this_really">How efficient is all of this, really?</h2>
<div class="sectionbody">
<div class="paragraph"><p>XXXX write an efficiency section here.  The benchmarks on the libevent
page are really out of date.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr></div>
<div id="footer">
<div id="footer-text">
Last updated
 2024-02-18 20:10:44 UTC
</div>
</div>


</body></html>