<!--?xml version="1.0" encoding="UTF-8"?--><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8">
<meta name="generator" content="AsciiDoc 10.1.2">
<title>Setting up the Libevent library</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overridden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-M3CEY418LQ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-M3CEY418LQ');
</script>
<style id="translation-style">
      .translate {
        background-color: #f0f0f0; /* 浅灰色背景 */
        color: black;             /* 黑色文本 */
        font-weight: bold;        /* 加粗字体 */
      }
    </style></head>
<body class="article">
<div id="header">
<h1>Setting up the Libevent library</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="quoteblock">
<div class="content">
<div class="paragraph"><p>These documents are Copyright (c) 2009-2012 by Nick Mathewson, and are made
available under the Creative Commons Attribution-Noncommercial-Share Alike
license, version 3.0.  Future versions may be made available under a less
restrictive license.</p></div>
<div class="paragraph"><p>Additionally, the source code examples in these documents are also licensed
under the so-called "3-Clause" or "Modified" BSD license. See
<a href="license_bsd.html">the license_bsd file</a> distributed with these documents
for the full terms.</p></div>
<div class="paragraph"><p>To get the source for the latest version of this document, install git
and run "git clone git://github.com/libevent/libevent-book.git"</p></div>
</div>
<div class="attribution">
</div></div>
<div class="paragraph"><p>Libevent has a few global settings that are shared across the entire
process.  These affect the entire library.</p><p class="translate">Libevent有少量全局设置，这些设置在整个进程中是共享的。它们会影响整个库。</p></div>
<div class="paragraph"><p>You <strong>must</strong> make any changes to these settings before you call any
other part of the Libevent library.  If you don’t, Libevent could wind
up in an inconsistent state.</p><p class="translate">在调用Libevent库之前，您必须对这些设置进行更改。如果你不这样做，Libevent可能结束时会处于不一致的状态。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_log_messages_in_libevent">Log messages in Libevent</h2>
<div class="sectionbody">
<div class="paragraph"><p>Libevent can log internal errors and warnings.  It also logs debugging
messages if it was compiled with logging support.  By default, these
messages are written to stderr.  You can override this behavior by
providing your own logging function.</p><p class="translate">Libevent可以记录内部错误和警告。如果它是在编译时包含了日志支持，它还会记录debug信息。默认情况下，这些消息会被写入到stderr。你可以通过提供你自己的日志函数来覆盖这种行为。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code>#define EVENT_LOG_DEBUG 0
#define EVENT_LOG_MSG   1
#define EVENT_LOG_WARN  2
#define EVENT_LOG_ERR   3

<i>/* Deprecated; see note at the end of this section */</i>
#define _EVENT_LOG_DEBUG EVENT_LOG_DEBUG
#define _EVENT_LOG_MSG   EVENT_LOG_MSG
#define _EVENT_LOG_WARN  EVENT_LOG_WARN
#define _EVENT_LOG_ERR   EVENT_LOG_ERR

<strong>typedef</strong> <strong>void</strong> (*event_log_cb)(<strong>int</strong> severity, <strong>const</strong> <strong>char</strong> *msg);

<strong>void</strong> event_set_log_callback(event_log_cb cb);</code></pre>
</div></div>
<div class="paragraph"><p>To override Libevent’s logging behavior, write your own function
matching the signature of event_log_cb, and pass it as an argument to
event_set_log_callback().  Whenever Libevent wants to log a message, it
will pass it to the function you provided.  You can have Libevent return
to its default behavior by calling event_set_log_callback() again with
NULL as an argument.</p><p class="translate">要覆盖Libevent的日志记录行为，编写一个符合event_log_cb签名的函数，并将其作为参数传递给event_set_log_callback。每当Libevent想要记录一条消息时，它将调用你提供的函数。你可以通过再次调用event_set_log_callback并将NULL作为参数传递，让Libevent返回到其默认行为。</p></div>
<div class="listingblock">
<div class="title">Examples</div>
<div class="content">
<pre><code>#include &lt;event2/event.h&gt;
#include &lt;stdio.h&gt;

<strong>static</strong> <strong>void</strong> discard_cb(<strong>int</strong> severity, <strong>const</strong> <strong>char</strong> *msg)
{
<i>    /* This callback does nothing. */</i>
}

<strong>static</strong> FILE *logfile = NULL;
<strong>static</strong> <strong>void</strong> write_to_file_cb(<strong>int</strong> severity, <strong>const</strong> <strong>char</strong> *msg)
{
    <strong>const</strong> <strong>char</strong> *s;
    <strong>if</strong> (!logfile)
        <strong>return</strong>;
    <strong>switch</strong> (severity) {
        <strong>case</strong> _EVENT_LOG_DEBUG: s = "debug"; <strong>break</strong>;
        <strong>case</strong> _EVENT_LOG_MSG:   s = "msg";   <strong>break</strong>;
        <strong>case</strong> _EVENT_LOG_WARN:  s = "warn";  <strong>break</strong>;
        <strong>case</strong> _EVENT_LOG_ERR:   s = "error"; <strong>break</strong>;
        <strong>default</strong>:               s = "?";     <strong>break</strong>; /* never reached */
    }
    fprintf(logfile, "[%s] %s\n", s, msg);
}

<i>/* Turn off all logging from Libevent. */</i>
<strong>void</strong> suppress_logging(<strong>void</strong>)
{
    event_set_log_callback(discard_cb);
}

<i>/* Redirect all Libevent log messages to the C stdio file 'f'. */</i>
<strong>void</strong> set_logfile(FILE *f)
{
    logfile = f;
    event_set_log_callback(write_to_file_cb);
}</code></pre>
</div></div>
<div class="paragraph"><div class="title">NOTE</div><p>It is not safe to invoke Libevent functions from within a user-provided
event_log_cb callback!  For instance, if you try to write a log callback that
uses bufferevents to send warning messages to a network socket, you are
likely to run into strange and hard-to-diagnose bugs.  This restriction may
be removed for some functions in a future version of Libevent.</p><p class="translate">在用户提供的event_log_cb()回调函数中调用Libevent函数是不安全的！例如，如果你尝试编写一个日志回调，使用bufferevents将警告消息发送到网络socket，你很可能遇到奇怪且难以诊断的错误。在未来版本的Libevent中，对于某些函数可能会移除这一限制。</p></div>
<div class="paragraph"><p>Ordinarily, debug logs are not enabled, and are not sent to the logging
callback.  You can turn them on manually, if Libevent was built to support
them.</p><p class="translate">通常，debug日志不启用，并且不会发送到日志回调。当编译Libevent时，你可以手动开启它们。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code>#define EVENT_DBG_NONE 0
#define EVENT_DBG_ALL 0xffffffffu

<strong>void</strong> event_enable_debug_logging(ev_uint32_t which);</code></pre>
</div></div>
<div class="paragraph"><p>Debugging logs are verbose, and not necessarily useful under most
circumstances.  Calling event_enable_debug_logging() with EVENT_DBG_NONE gets
default behavior; calling it with EVENT_DBG_ALL turns on all the supported
debugging logs.  More fine-grained options may be supported in future
versions.</p><p class="translate">调试日志非常详细，并且在大多数情况下可能并不有用。使用EVENT_DBG_NONE作为参数调用event_enable_debug_logging()会得到默认行为；使用EVENT_DBG_ALL作为参数调用它会打开所有支持的调试日志。未来版本可能会支持更细粒度的选项。</p></div>
<div class="paragraph"><p>These functions are declared in &lt;event2/event.h&gt;.  They first appeared in
Libevent 1.0c, except for event_enable_debug_logging(), which first appeared
in Libevent 2.1.1-alpha.</p><p class="translate">这些函数在<event2 event.h="">中声明。它们最早出现在Libevent 1.0c中，除了event_enable_debug_logging()，最早出现在Libevent 2.1.1-alpha中。</event2></p></div>
<div class="paragraph"><div class="title">COMPATIBILITY NOTE</div><p>Before Libevent 2.0.19-stable, the EVENT_LOG_* macros had names that began
with an underscore: _EVENT_LOG_DEBUG, _EVENT_LOG_MSG, _EVENT_LOG_WARN, and
_EVENT_LOG_ERR.  These older names are deprecated, and should only be used
for backward compatibility with Libevent 2.0.18-stable and earlier.  They may
be removed in a future version of Libevent.</p><p class="translate">在Libevent 2.0.19-stable之前，EVENT_LOG_*宏的名称以下划线开头：_EVENT_LOG_DEBUG、_EVENT_LOG_MSG、_EVENT_LOG_WARN和_EVENT_LOG_ERR。这些较旧的名称已被弃用，仅应用于与Libevent 2.0.18-stable及更早版本的向后兼容。它们可能会在未来版本的Libevent中被移除。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_handling_fatal_errors">Handling fatal errors</h2>
<div class="sectionbody">
<div class="paragraph"><p>When Libevent detects a non-recoverable internal error (such as a corrupted
data structure), its default behavior is to call exit() or abort() to leave the
currently running process.  These errors almost always mean that there is a
bug somewhere: either in your code, or in Libevent itself.</p><p class="translate">当Libevent检测到不可恢复的内部错误（如数据结构损坏）时，其默认行为是调用`exit()`或`abort()`来终止当前正在运行的进程。这些错误几乎总是意味着某处存在错误：要么是在你的代码中，要么是在Libevent本身中。</p></div>
<div class="paragraph"><p>You can override Libevent’s behavior if you want your application to handle
fatal errors more gracefully, by providing a function that Libevent should
call in lieu of exiting.</p><p class="translate">如果你希望你的应用程序能够更优雅地处理致命错误，你可以给Libevent提供回调而不是退出。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>typedef</strong> <strong>void</strong> (*event_fatal_cb)(<strong>int</strong> err);
<strong>void</strong> event_set_fatal_callback(event_fatal_cb cb);</code></pre>
</div></div>
<div class="paragraph"><p>To use these functions, you first define a new function that Libevent should
call upon encountering a fatal error, then you pass it to
event_set_fatal_callback().  Later, if Libevent encounters a fatal error, it
will call the function you provided.</p><p class="translate">你首先需要定义一个新的函数，将其传递给`event_set_fatal_callback()`。之后，如果Libevent遇到致命错误，它将调用你提供的函数。</p></div>
<div class="paragraph"><p>Your function <strong>should not</strong> return control to Libevent; doing so may cause
undefined behavior, and Libevent might exit anyway to avoid crashing.  Once
your function has been called, you should not call any other Libevent
function.</p><p class="translate">你的函数不应该将控制权返回给Libevent；这样做可能会导致未定义的行为，并且Libevent可能仍会选择退出以避免崩溃。一旦你的函数被调用，你就不应该调用任何其他Libevent函数。</p></div>
<div class="paragraph"><p>These functions are declared in &lt;event2/event.h&gt;.  They first appeared
in Libevent 2.0.3-alpha.</p><p class="translate">这些函数在`<event2 event.h="">中声明，最早出现在Libevent 2.0.3-alpha中。</event2></p></div>
</div>
</div>
<div class="sect1">
<h2 id="_memory_management">Memory management</h2>
<div class="sectionbody">
<div class="paragraph"><p>By default, Libevent uses the C library’s memory management functions to
allocate memory from the heap.  You can have Libevent use another memory
manager by providing your own replacements for malloc, realloc, and
free.  You might want to do this if you have a more efficient allocator
that you want Libevent to use, or if you have an instrumented allocator
that you want Libevent to use in order to look for memory leaks.</p><p class="translate">默认情况下，Libevent使用C函数从堆上分配内存。你可以让Libevent使用你提供的malloc、realloc和free的替代函数。如果你有一个更高效的分配器希望Libevent使用，或者如果你有一个带有检测工具的分配器，希望Libevent使用它来寻找内存泄漏，你可能会想这样做。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>void</strong> event_set_mem_functions(<strong>void</strong> *(*malloc_fn)(size_t sz),
                             <strong>void</strong> *(*realloc_fn)(<strong>void</strong> *ptr, size_t sz),
                             <strong>void</strong> (*free_fn)(<strong>void</strong> *ptr));</code></pre>
</div></div>
<div class="paragraph"><p>Here’s a simple example that replaces Libevent’s allocation functions
with variants that count the total number of bytes that are allocated.
In reality, you’d probably want to add locking here to prevent errors
when Libevent is running in multiple threads.</p><p class="translate">这里有一个简单的例子，它用来替换Libevent的分配函数，这些函数能够计算分配的总字节数。实际上，如果Libevent在多线程中运行，你可能还会希望增加锁定机制来防止错误。</p></div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre><code>#include &lt;event2/event.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;stdlib.h&gt;

<i>/* This union's purpose is to be as big as the largest of all the</i>
<i> * types it contains. */</i>
<strong>union</strong> alignment {
    size_t sz;
    <strong>void</strong> *ptr;
    <strong>double</strong> dbl;
};
<i>/* We need to make sure that everything we return is on the right</i>
<i>   alignment to hold anything, including a double. */</i>
#define ALIGNMENT <strong>sizeof</strong>(<strong>union</strong> alignment)

<i>/* We need to do this cast-to-char* trick on our pointers to adjust</i>
<i>   them; doing arithmetic on a void* is not standard. */</i>
#define OUTPTR(ptr) (((<strong>char</strong>*)ptr)+ALIGNMENT)
#define INPTR(ptr) (((<strong>char</strong>*)ptr)-ALIGNMENT)

<strong>static</strong> size_t total_allocated = 0;
<strong>static</strong> <strong>void</strong> *replacement_malloc(size_t sz)
{
    <strong>void</strong> *chunk = malloc(sz + ALIGNMENT);
    <strong>if</strong> (!chunk) <strong>return</strong> chunk;
    total_allocated += sz;
    *(size_t*)chunk = sz;
    <strong>return</strong> OUTPTR(chunk);
}
<strong>static</strong> <strong>void</strong> *replacement_realloc(<strong>void</strong> *ptr, size_t sz)
{
    size_t old_size = 0;
    <strong>if</strong> (ptr) {
        ptr = INPTR(ptr);
        old_size = *(size_t*)ptr;
    }
    ptr = realloc(ptr, sz + ALIGNMENT);
    <strong>if</strong> (!ptr)
        <strong>return</strong> NULL;
    *(size_t*)ptr = sz;
    total_allocated = total_allocated - old_size + sz;
    <strong>return</strong> OUTPTR(ptr);
}
<strong>static</strong> <strong>void</strong> replacement_free(<strong>void</strong> *ptr)
{
    ptr = INPTR(ptr);
    total_allocated -= *(size_t*)ptr;
    free(ptr);
}
<strong>void</strong> start_counting_bytes(<strong>void</strong>)
{
    event_set_mem_functions(replacement_malloc,
                            replacement_realloc,
                            replacement_free);
}</code></pre>
</div></div>
<div class="ulist"><div class="title">NOTES</div><ul>
<li>
<p>
Replacing the memory management functions affects all future calls to
  allocate, resize, or free memory from Libevent.  Therefore, you
  need to make sure that you replace the functions <em>before</em> you call any
  other Libevent functions.  Otherwise, Libevent will use your version
  of free to deallocate memory returned from the C library’s version of
  malloc.
</p>
</li>
<li>
<p>
Your malloc and realloc functions need to return memory chunks with
  the same alignment as the C library.
</p>
</li>
<li>
<p>
Your realloc function needs to handle realloc(NULL, sz) correctly
  (that is, by treating it as malloc(sz)).
</p>
</li>
<li>
<p>
Your realloc function needs to handle realloc(ptr, 0) correctly
  (that is, by treating it as free(ptr)).
</p>
</li>
<li>
<p>
Your free function does not need to handle free(NULL).
</p>
</li>
<li>
<p>
Your malloc function does not need to handle malloc(0).
</p>
</li>
<li>
<p>
The replaced memory management functions need to be threadsafe if you
  are using Libevent from more than one thread.
</p>
</li>
<li>
<p>
Libevent will use these functions to allocate memory that it returns to
  you.  Thus, if you want to free memory that is allocated and returned by a
  Libevent function, and you have replaced the malloc and realloc functions,
  then you will probably have to use your replacement free function to free
  it.
</p><p class="translate">注意事项<br>1.替换内存管理函数会影响所有未来的Libevent内存分配、调整大小或释放操作。因此，你需要确保在调用任何Libevent函数之前调用这些函数。否则，Libevent将使用你版本的free函数来释放从C库的malloc版本返回的内存。<br>2.你的malloc和realloc函数需要返回与C库相同对齐的内存块。<br>3.你的realloc函数需要正确处理realloc(NULL, sz)（即，把它当作malloc(sz)来处理）。<br>4.你的realloc函数需要正确处理realloc(ptr, 0)（即，把它当作free(ptr)来处理）。<br>5.你的free函数不需要处理free(NULL)。<br>6.你的malloc函数不需要处理malloc(0)。<br>7.如果你在多个线程中使用Libevent，替换后的内存管理函数需要是线程安全的。<br>8.Libevent将使用这些函数来分配它返回给你的内存。因此，如果你想要释放由Libevent函数分配并返回的内存，并且你已经替换了malloc和realloc函数，那么你可能必须使用你的替换free函数来释放它。</p>
</li>
</ul></div>
<div class="paragraph"><p>The event_set_mem_functions() function is declared in &lt;event2/event.h&gt;.
It first appeared in Libevent 2.0.1-alpha.</p><p class="translate">event_set_mem_functions()函数在<event2 event.h="">中声明,最初出现在Libevent 2.0.1-alpha中。</event2></p></div>
<div class="paragraph"><p>Libevent can be built with event_set_mem_functions() disabled.  If it
is, then programs using event_set_mem_functions will not compile or link.
In Libevent 2.0.2-alpha and later, you can detect the presence of
event_set_mem_functions() by checking whether the
EVENT_SET_MEM_FUNCTIONS_IMPLEMENTED macro is defined.</p><p class="translate">Libevent可以构建时禁用event_set_mem_functions()。如果是这样的话，使用event_set_mem_functions的程序将无法编译或链接。在Libevent 2.0.2-alpha及更高版本中，你可以通过检查EVENT_SET_MEM_FUNCTIONS_IMPLEMENTED宏是否已定义来检测event_set_mem_functions()是否存在。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_locks_and_threading">Locks and threading</h2>
<div class="sectionbody">
<div class="paragraph"><p>As you probably know if you’re writing multithreaded programs, it isn’t
always safe to access the same data from multiple threads at the same
time.</p><p class="translate">如果你正在编写多线程程序，你可能知道，从多个线程同时访问同一数据并不总是安全的。</p></div>
<div class="paragraph"><p>Libevent structures can generally work three ways with multithreading.</p></div>
<div class="ulist"><ul>
<li>
<p>
Some structures are inherently single-threaded: it is never safe to use
  them from more than one thread at the same time.
</p>
</li>
<li>
<p>
Some structures are optionally locked: you can tell Libevent for each
  object whether you need to use it from multiple threads at once.
</p>
</li>
<li>
<p>
Some structures are always locked: if Libevent is running with lock
  support, then they are always safe to use from multiple threads at
  once.
</p><p class="translate">Libevent结构在多线程中通常有三种工作方式。<br>1.一些结构本质上是单线程的：从多个线程同时使用它们永远不是安全的。<br>2.一些结构是可锁的：你可以告诉Libevent，对于每个对象，你是否需要同时从多个线程中使用它。<br>3.一些结构总是被锁定的：如果Libevent在支持锁定的情况下运行，那么它们总是可以安全地同时从多个线程中使用。</p>
</li>
</ul></div>
<div class="paragraph"><p>To get locking in Libevent, you must tell Libevent which locking
functions to use.  You need to do this before you call any Libevent
function that allocates a structure that needs to be shared between
threads.</p><p class="translate">要在Libevent中获得锁定，你必须告知Libevent要使用的锁定函数。你需要在调用使用了共享内存的libevent函数前做这件事。</p></div>
<div class="paragraph"><p>If you are using the pthreads library, or the native Windows threading
code, you’re in luck.  There are pre-defined functions that will set Libevent
up to use the right pthreads or Windows functions for you.</p><p class="translate">如果你正在使用pthreads库，或者是原生Windows线程代码，那么你很幸运。有预定义的函数能够设置Libevent，让其为你正确地使用pthreads或Windows函数。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code>#ifdef WIN32
<strong>int</strong> evthread_use_windows_threads(<strong>void</strong>);
#define EVTHREAD_USE_WINDOWS_THREADS_IMPLEMENTED
#endif
#ifdef _EVENT_HAVE_PTHREADS
<strong>int</strong> evthread_use_pthreads(<strong>void</strong>);
#define EVTHREAD_USE_PTHREADS_IMPLEMENTED
#endif</code></pre>
</div></div>
<div class="paragraph"><p>Both functions return 0 on success, and -1 on failure.</p><p class="translate">这两个函数在成功时返回0，在失败时返回-1。</p></div>
<div class="paragraph"><p>If you need to use a different threading library, then you have a little
more work ahead of you.  You need to define functions that use your
library to implement:</p><p class="translate">如果你需要使用不同的线程库，那么你要额外做些工作。你需要函数实现以下功能：</p></div>
<div class="ulist"><ul>
<li>
<p>
Locks
</p>
</li>
<li>
<p>
locking
</p>
</li>
<li>
<p>
unlocking
</p>
</li>
<li>
<p>
lock allocation
</p>
</li>
<li>
<p>
lock destruction
</p>
</li>
<li>
<p>
Conditions
</p>
</li>
<li>
<p>
condition variable creation
</p>
</li>
<li>
<p>
condition variable destruction
</p>
</li>
<li>
<p>
waiting on a condition variable
</p>
</li>
<li>
<p>
signaling/broadcasting to a condition variable
</p>
</li>
<li>
<p>
Threads
</p>
</li>
<li>
<p>
thread ID detection
</p>
</li>
</ul></div>
<div class="paragraph"><p>Then you tell Libevent about these functions, using the
evthread_set_lock_callbacks and evthread_set_id_callback interfaces.</p><p class="translate">然后你使用evthread_set_lock_callbacks和evthread_set_id_callback接口告诉Libevent这些函数。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code>#define EVTHREAD_WRITE  0x04
#define EVTHREAD_READ   0x08
#define EVTHREAD_TRY    0x10

#define EVTHREAD_LOCKTYPE_RECURSIVE 1
#define EVTHREAD_LOCKTYPE_READWRITE 2

#define EVTHREAD_LOCK_API_VERSION 1

<strong>struct</strong> evthread_lock_callbacks {
       <strong>int</strong> lock_api_version;
       <strong>unsigned</strong> supported_locktypes;
       <strong>void</strong> *(*alloc)(<strong>unsigned</strong> locktype);
       <strong>void</strong> (*free)(<strong>void</strong> *lock, <strong>unsigned</strong> locktype);
       <strong>int</strong> (*lock)(<strong>unsigned</strong> mode, <strong>void</strong> *lock);
       <strong>int</strong> (*unlock)(<strong>unsigned</strong> mode, <strong>void</strong> *lock);
};

<strong>int</strong> evthread_set_lock_callbacks(<strong>const</strong> <strong>struct</strong> evthread_lock_callbacks *);

<strong>void</strong> evthread_set_id_callback(<strong>unsigned</strong> <strong>long</strong> (*id_fn)(<strong>void</strong>));

<strong>struct</strong> evthread_condition_callbacks {
        <strong>int</strong> condition_api_version;
        <strong>void</strong> *(*alloc_condition)(<strong>unsigned</strong> condtype);
        <strong>void</strong> (*free_condition)(<strong>void</strong> *cond);
        <strong>int</strong> (*signal_condition)(<strong>void</strong> *cond, <strong>int</strong> broadcast);
        <strong>int</strong> (*wait_condition)(<strong>void</strong> *cond, <strong>void</strong> *lock,
            <strong>const</strong> <strong>struct</strong> timeval *timeout);
};

<strong>int</strong> evthread_set_condition_callbacks(
        <strong>const</strong> <strong>struct</strong> evthread_condition_callbacks *);</code></pre>
</div></div>
<div class="paragraph"><p>The evthread_lock_callbacks structure describes your locking callbacks
and their abilities.  For the version described above, the
lock_api_version field must be set to EVTHREAD_LOCK_API_VERSION.  The
supported_locktypes field must be set to a bitmask of the
EVTHREAD_LOCKTYPE_* constants to describe which lock types you can
support.  (As of 2.0.4-alpha, EVTHREAD_LOCK_RECURSIVE is mandatory and
EVTHREAD_LOCK_READWRITE is unused.)
The <em>alloc</em> function must return a new lock of the specified type.  The
<em>free</em> function must release all resources held by a lock of the
specified type.  The <em>lock</em> function must try to acquire the lock in the
specified mode, returning 0 on success and nonzero on failure.  The
<em>unlock</em> function must try to unlock the lock, returning 0 on success
and nonzero on failure.</p><p class="translate">evthread_lock_callbacks结构描述了你的锁回调函数及其能力。对于上文的描述，lock_api_version字段必须设置为EVTHREAD_LOCK_API_VERSION。 supported_locktypes字段必须设置为EVTHREAD_LOCKTYPE_*的位掩码，以描述你可以支持哪些类型的锁。（截至2.0.4-alpha版本，EVTHREAD_LOCK_RECURSIVE是强制性的，而EVTHREAD_LOCK_READWRITE未使用。）alloc函数必须返回指定类型的新锁。free函数必须释放由指定类型的锁持有的所有资源。lock函数必须尝试以指定模式获取锁，成功时返回0，失败时返回非零值。unlock函数必须尝试解锁，成功时返回0，失败时返回非零值。</p></div>
<div class="paragraph"><p>Recognized lock types are:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
0
</dt>
<dd>
<p>
        A regular, not-necessarily recursive lock.
</p>
</dd>
<dt class="hdlist1">
EVTHREAD_LOCKTYPE_RECURSIVE
</dt>
<dd>
<p>
        A lock that does not block a thread already holding it from
        requiring it again.  Other threads can acquire the lock once
        the thread holding it has unlocked it as many times as it was
        initially locked.
</p>
</dd>
<dt class="hdlist1">
EVTHREAD_LOCKTYPE_READWRITE
</dt>
<dd>
<p>
        A lock that allows multiple threads to hold it at once for
        reading, but only one thread at a time to hold it for writing.
        A writer excludes all readers.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Recognized lock modes are:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
EVTHREAD_READ
</dt>
<dd>
<p>
        For READWRITE locks only: acquire or release the lock for
        reading.
</p>
</dd>
<dt class="hdlist1">
EVTHREAD_WRITE
</dt>
<dd>
<p>
        For READWRITE locks only: acquire or release the lock for
        writing.
</p>
</dd>
<dt class="hdlist1">
EVTHREAD_TRY
</dt>
<dd>
<p>
        For locking only: acquire the lock only if the lock can be
        acquired immediately.
</p><p class="translate">被识别的锁类型包括：<br>0<br>常规的，不必是递归锁。<br>EVTHREAD_LOCKTYPE_RECURSIVE<br>对于已经持有该锁的线程，不会阻止它再次请求该锁。（同递归锁）<br>EVTHREAD_LOCKTYPE_READWRITE<br>允许多个线程同时为了读取持有它的锁，但一次只允许一个线程为了写入而持有它。写操作会排除所有读操作。<br>被识别的锁模式包括：<br>EVTHREAD_READ<br>仅限于READWRITE锁：为了读取而获取或释放锁。<br>EVTHREAD_WRITE<br>仅限于READWRITE锁：为了写入而获取或释放锁。<br>EVTHREAD_TRY<br>仅限于锁定：仅在锁可以立即获取时才获取锁。</p>
</dd>
</dl></div>
<div class="paragraph"><p>The id_fn argument must be a function returning an unsigned long
identifying what thread is calling the function.  It must always return
the same number for the same thread, and must not ever return the same
number for two different threads if they are both executing at the same
time.</p><p class="translate">id_fn函数必须返回unsigned long，用于识别哪个线程正在调用该函数。相同的线程总是返回相同的数字，并且如果两个线程同时执行，则决不能为两个不同的线程返回相同的数字。</p></div>
<div class="paragraph"><p>The evthread_condition_callbacks structure describes callbacks related to
condition variables.  For the version described above, the condition_api_version
field must be set to EVTHREAD_CONDITION_API_VERSION.  The alloc_condition
function must return a pointer to a new condition variable.  It receives 0 as
its argument.  The free_condition function must release storage and resources
held by a condition variable.  The wait_condition function takes three
arguments: a condition allocated by alloc_condition, a lock allocated by the
evthread_lock_callbacks.alloc function you provided, and an optional timeout.
The lock will be held whenever the function is called; the function must
release the lock, and wait until the condition becomes signalled or until the
(optional) timeout has elapsed.  The wait_condition function should return -1
on an error, 0 if the condition is signalled, and 1 on a timeout.  Before it
returns, it should make sure it holds the lock again.  Finally, the
signal_condition function should cause <em>one</em> thread waiting on the condition
to wake up (if its broadcast argument is false) and <em>all</em> threads currently
waiting on the condition to wake up (if its broadcast argument is true).  It
will only be held while holding the lock associated with the condition.</p><p class="translate">evthread_condition_callbacks结构描述了与条件变量相关的回调函数。对于上文描述，condition_api_version字段必须设置为EVTHREAD_CONDITION_API_VERSION。alloc_condition函数必须返回一个指针指向新条件变量。它接收0作为参数。free_condition函数必须释放由条件变量持有的存储和资源。wait_condition函数接受三个参数：由alloc_condition分配的条件、由你提供的evthread_lock_callbacks.alloc函数分配的锁，以及一个可选的超时时间。每当调用该函数时，锁将被持有；该函数必须释放锁，并等待直到条件变量发出信号或者（可选的）超时时间已过。wait_condition函数在错误时应返回-1，在条件发出信号时返回0，在超时时返回1。在返回之前，它应确保再次持有锁。最后，signal_condition函数应使得等待条件的一个线程醒来（如果它的broadcast参数为假）并使得所有当前等待条件的线程醒来（如果它的broadcast参数为真）。只有在持有与条件相关联的锁时才能持有。</p></div>
<div class="paragraph"><p>For more information on condition variables, look at the documentation for
pthreads’s pthread_cond_* functions, or Windows’s CONDITION_VARIABLE
functions.</p><p class="translate">要获取更多有关条件变量的信息，请查看pthreads的pthread_cond_*函数或Windows的CONDITION_VARIABLE函数的文档。</p></div>
<div class="listingblock">
<div class="title">Examples</div>
<div class="content">
<pre><code>For an example of how to use these functions, see evthread_pthread.c and
evthread_win32.c in the Libevent source distribution.</code></pre>
</div></div>
<div class="paragraph"><p>The functions in this section are declared in &lt;event2/thread.h&gt;.  Most of
them first
appeared in Libevent 2.0.4-alpha.  Libevent versions from 2.0.1-alpha through
2.0.3-alpha used an older interface to set locking functions.  The
event_use_pthreads() function requires you to link your program against the
event_pthreads library.</p><p class="translate">本节中的函数在 <event2 thread.h=""> 中声明。它们中的大多数首次出现于Libevent 2.0.4-alpha版本。Libevent从2.0.1-alpha到2.0.3-alpha版本使用的是旧的接口来设置锁定函数。event_use_pthreads()函数要求您在编译程序时链接event_pthreads库。</event2></p></div>
<div class="paragraph"><p>The condition-variable functions were new in Libevent 2.0.7-rc; they were
added to solve some otherwise intractable deadlock problems.</p><p class="translate">条件变量函数是在Libevent 2.0.7-rc中新增的；它们被添加进来是为了解决一些其他方式难以克服的死锁问题。</p></div>
<div class="paragraph"><p>Libevent can be built with locking support disabled.  If it is, then
programs built to use the above thread-related functions will not
run.</p><p class="translate">Libevent可以构建时禁用锁支持。如果这样做了，那么上述线程相关函数将无法运行。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_debugging_lock_usage">Debugging lock usage</h2>
<div class="sectionbody">
<div class="paragraph"><p>To help debug lock usage, Libevent has an optional "lock debugging"
feature that wraps its locking calls in order to catch typical lock
errors, including:</p></div>
<div class="ulist"><ul>
<li>
<p>
unlocking a lock that we don’t actually hold
</p>
</li>
<li>
<p>
re-locking a non-recursive lock
</p>
</li>
</ul></div>
<div class="paragraph"><p>If one of these lock errors occurs, Libevent exits with an assertion failure.</p><p class="translate">为了帮助调试锁的使用情况，Libevent有一个可选的“锁调试”功能，它封装了它的锁调用以捕获典型的锁错误，包括：<br>- 解锁一个实际上我们并未持有的锁<br>- 重新锁定一个非递归锁<br>如果出现这些锁错误之一，Libevent将会因断言失败而退出。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>void</strong> evthread_enable_lock_debugging(<strong>void</strong>);
#define evthread_enable_lock_debuging() evthread_enable_lock_debugging()</code></pre>
</div></div>
<div class="admonitionblock">
<table><tbody><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">This function MUST be called before any locks are created or used.  To
be safe, call it just after you set your threading functions.</td>
</tr></tbody></table>
</div>
<div class="paragraph"><p>This function was new in Libevent 2.0.4-alpha with the misspelled name
"evthread_enable_lock_debuging()."  The spelling was fixed to
evthread_enable_lock_debugging() in 2.1.2-alpha; both names are currently
supported.</p><p class="translate">这个函数引入于Libevent 2.0.4-alpha，最初拼写错误为 evthread_enable_lock_debuging()。在2.1.2-alpha版本中修正为正确的拼写 evthread_enable_lock_debugging()；目前两个名称都得到支持。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_debugging_event_usage">Debugging event usage</h2>
<div class="sectionbody">
<div class="paragraph"><p>There are some common errors in using events that Libevent can detect and
report for you.  They include:</p></div>
<div class="ulist"><ul>
<li>
<p>
Treating an uninitialized struct event as though it were initialized.
</p>
</li>
<li>
<p>
Try to reinitialize a pending struct event.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Tracking which events are initialized requires that Libevent use extra memory
and CPU, so you should only enable debug mode when actually debugging your
program.</p><p class="translate">在使用事件时存在一些常见错误，Libevent可以为您检测并报告这些错误。它们包括：<br>- 将一个未初始化的 struct event 当作已经初始化的来处理。<br>- 尝试重新初始化一个正在等待的 struct event。<br>追踪哪些事件已经初始化需要Libevent使用额外的内存和CPU，因此您应当只在调试程序时才启用调试模式。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>void</strong> event_enable_debug_mode(<strong>void</strong>);</code></pre>
</div></div>
<div class="paragraph"><p>This function must only be called before any event_base is created.</p><p class="translate">这个函数必须在创建任何 event_base 之前调用。</p></div>
<div class="paragraph"><p>When using debug mode, you might run out of memory if your program uses a
large number of events created with event_assign() [not event_new()].  This
happens because Libevent has no way of telling when an event created with
event_assign() will no longer be used.  (It can tell that an event_new()
event has become invalid when you call event_free() on it.)  If you want to
avoid running out of memory while debugging, you can explicitly tell Libevent
that such events are no longer to be treated as assigned:</p><p class="translate">在使用调试模式时，如果你的程序使用了大量通过 event_assign() 创建的event（而不是 event_new()），你可能会耗尽内存。这是因为 Libevent 无法知道何时不再使用通过 event_assign() 创建的event。（当你对 event_new() 创建的event调用 event_free() 时，它能知道该事件已经无效了。）如果你想在调试时避免内存耗尽，你可以明确告诉 Libevent 这些事件不再被当作已分配处理：</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>void</strong> event_debug_unassign(<strong>struct</strong> event *ev);</code></pre>
</div></div>
<div class="paragraph"><p>Calling event_debug_unassign() has no effect when debugging is not enabled.</p><p class="translate">当未启用调试时，调用 event_debug_unassign() 不会有任何效果。</p></div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre><code>#include &lt;event2/event.h&gt;
#include &lt;event2/event_struct.h&gt;

#include &lt;stdlib.h&gt;

<strong>void</strong> cb(evutil_socket_t fd, <strong>short</strong> what, <strong>void</strong> *ptr)
{
<i>    /* We pass 'NULL' as the callback pointer for the heap allocated</i>
<i>     * event, and we pass the event itself as the callback pointer</i>
<i>     * for the stack-allocated event. */</i>
    <strong>struct</strong> event *ev = ptr;

    <strong>if</strong> (ev)
        event_debug_unassign(ev);
}

<i>/* Here's a simple mainloop that waits until fd1 and fd2 are both</i>
<i> * ready to read. */</i>
<strong>void</strong> mainloop(evutil_socket_t fd1, evutil_socket_t fd2, <strong>int</strong> debug_mode)
{
    <strong>struct</strong> event_base *base;
    <strong>struct</strong> event event_on_stack, *event_on_heap;

    <strong>if</strong> (debug_mode)
       event_enable_debug_mode();

    base = event_base_new();

    event_on_heap = event_new(base, fd1, EV_READ, cb, NULL);
    event_assign(&amp;event_on_stack, base, fd2, EV_READ, cb, &amp;event_on_stack);

    event_add(event_on_heap, NULL);
    event_add(&amp;event_on_stack, NULL);

    event_base_dispatch(base);

    event_free(event_on_heap);
    event_base_free(base);
}</code></pre>
</div></div>
<div class="paragraph"><p>Detailed event debugging is a feature which can only be enabled at compile-time using
the CFLAGS environment variable "-DUSE_DEBUG". With this flag enabled, any program compiled
against Libevent will output a very verbose log detailing low-level activity on the back-end.
These logs include, but not limited to, the following:</p></div>
<div class="ulist"><ul>
<li>
<p>
event additions
</p>
</li>
<li>
<p>
event deletions
</p>
</li>
<li>
<p>
platform specific event notification information
</p>
</li>
</ul></div>
<div class="paragraph"><p>This feature cannot be enabled or disabled via an API call so it must only be
used in developer builds.</p><p class="translate">详细的event调试是一个特性，它只能在编译时通过使用 CFLAGS 环境变量“-DUSE_DEBUG”来启用。启用此标志后，任何针对 Libevent 编译的程序都会输出一个非常详细的日志，详细记录后端的low-level活动。这些日志包括但不限于以下内容：<br>- 事件添加<br>- 事件删除<br>- 平台特定的事件通知信息<br>这个特性不能通过 API 调用来启用或禁用，因此它只能在开发者构建中使用。</p></div>
<div class="paragraph"><p>These debugging functions were added in Libevent 2.0.4-alpha.</p><p class="translate">这些调试函数引入于 Libevent 2.0.4-alpha。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_detecting_the_version_of_libevent">Detecting the version of Libevent</h2>
<div class="sectionbody">
<div class="paragraph"><p>New versions of Libevent can add features and remove bugs.  Sometimes
you’ll want to detect the Libevent version, so that you can:</p></div>
<div class="ulist"><ul>
<li>
<p>
Detect whether the installed version of Libevent is good enough to
  build your program.
</p>
</li>
<li>
<p>
Display the Libevent version for debugging.
</p>
</li>
<li>
<p>
Detect the version of Libevent so that you can warn the user about
  bugs, or work around them.
</p><p class="translate">Libevent 的新版本增加功能和修复错误。有时候你会想要检测 Libevent 的版本，这样你可以：<br>- 检测安装的 Libevent 版本是否足够好，以构建你的程序。<br>- 显示 Libevent 版本以便调试。<br>- 检测 Libevent 的版本，以便你可以警告用户关于错误，或者绕过它们。</p>
</li>
</ul></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code>#define LIBEVENT_VERSION_NUMBER 0x02000300
#define LIBEVENT_VERSION "2.0.3-alpha"
<strong>const</strong> <strong>char</strong> *event_get_version(<strong>void</strong>);
ev_uint32_t event_get_version_number(<strong>void</strong>);</code></pre>
</div></div>
<div class="paragraph"><p>The macros make available the compile-time version of the Libevent
library; the functions return the run-time version.  Note that if you
have dynamically linked your program against Libevent, these versions
may be different.</p><p class="translate">宏提供了 Libevent 库的编译时版本；函数返回运行时版本。请注意，如果你的程序是与 Libevent 动态链接的，这些版本可能会有所不同。</p></div>
<div class="paragraph"><p>You can get a Libevent version in two formats: as a string suitable for
displaying to users, or as a 4-byte integer suitable for numerical
comparison.  The integer format uses the high byte for the major version,
the second byte for the minor version, the third byte for the patch version, and
the low byte to indicate release status (0 for release, nonzero for a
development series after a given release).</p><p class="translate">你可以以两种格式获取 Libevent 的版本：一种是适合向用户显示的字符串，另一种是适合进行数值比较的4字节整数。整数格式使用高字节表示主版本号，第二个字节表示次版本号，第三个字节表示修补版本号，低字节表示发布状态（0 表示正式发布，非零表示在给定发布版本之后的开发系列）。</p></div>
<div class="paragraph"><p>Thus, the released Libevent 2.0.1-alpha has the version number of [02 00
01 00], or 0x02000100.  A development versions between 2.0.1-alpha and
2.0.2-alpha might have a version number of [02 00 01 08], or 0x02000108.</p><p class="translate">因此，发布的 Libevent 2.0.1-alpha 的版本号为 [02 00 01 00]，或 0x02000100。在 2.0.1-alpha 和 2.0.2-alpha 之间的开发版本可能有一个版本号为 [02 00 01 08]，或 0x02000108。</p></div>
<div class="listingblock">
<div class="title">Example: Compile-time checks</div>
<div class="content">
<pre><code>#include &lt;event2/event.h&gt;

#<strong>if</strong> !defined(LIBEVENT_VERSION_NUMBER) || LIBEVENT_VERSION_NUMBER &lt; 0x02000100
#error "This version of Libevent is not supported; Get 2.0.1-alpha or later."
#endif

<strong>int</strong>
make_sandwich(<strong>void</strong>)
{
<i>        /* Let's suppose that Libevent 6.0.5 introduces a make-me-a</i>
<i>           sandwich function. */</i>
#<strong>if</strong> LIBEVENT_VERSION_NUMBER &gt;= 0x06000500
        evutil_make_me_a_sandwich();
        <strong>return</strong> 0;
#<strong>else</strong>
        <strong>return</strong> -1;
#endif
}</code></pre>
</div></div>
<div class="listingblock">
<div class="title">Example: Run-time checks</div>
<div class="content">
<pre><code>#include &lt;event2/event.h&gt;
#include &lt;string.h&gt;

<strong>int</strong>
check_for_old_version(<strong>void</strong>)
{
    <strong>const</strong> <strong>char</strong> *v = event_get_version();
<i>    /* This is a dumb way to do it, but it is the only thing that works</i>
<i>       before Libevent 2.0. */</i>
    <strong>if</strong> (!strncmp(v, "0.", 2) ||
        !strncmp(v, "1.1", 3) ||
        !strncmp(v, "1.2", 3) ||
        !strncmp(v, "1.3", 3)) {

        printf("Your version of Libevent is very old.  If you run into bugs,"
               " consider upgrading.\n");
        <strong>return</strong> -1;
    } <strong>else</strong> {
        printf("Running with Libevent version %s\n", v);
        <strong>return</strong> 0;
    }
}

<strong>int</strong>
check_version_match(<strong>void</strong>)
{
    ev_uint32_t v_compile, v_run;
    v_compile = LIBEVENT_VERSION_NUMBER;
    v_run = event_get_version_number();
    <strong>if</strong> ((v_compile &amp; 0xffff0000) != (v_run &amp; 0xffff0000)) {
        printf("Running with a Libevent version (%s) very different from the "
               "one we were built with (%s).\n", event_get_version(),
               LIBEVENT_VERSION);
        <strong>return</strong> -1;
    }
    <strong>return</strong> 0;
}</code></pre>
</div></div>
<div class="paragraph"><p>The macros and functions in this section are defined in
&lt;event2/event.h&gt;.  The event_get_version() function first appeared in
Libevent 1.0c; the others first appeared in Libevent 2.0.1-alpha.</p><p class="translate">本节中的宏和函数定义在 <event2 event.h=""> 中。`event_get_version()` 函数最初出现在 Libevent 1.0c 中；其他的则首次出现在 Libevent 2.0.1-alpha 中。</event2></p></div>
</div>
</div>
<div class="sect1">
<h2 id="_freeing_global_libevent_structures">Freeing global Libevent structures</h2>
<div class="sectionbody">
<div class="paragraph"><p>Even when you’ve freed all the objects that you allocated with Libevent,
there will be a few globally allocated structures left over.  This isn’t
usually a problem: once the process exits, they will all get cleaned up
anyway.  But having these structures can confuse some debugging tools into
thinking that Libevent is leaking resources.  If you need to make sure that
Libevent has released all internal library-global data structures, you can
call:</p><p class="translate">即使你已经释放了所有使用 Libevent 分配的对象，仍然会有一些全局分配的结构剩余。这通常不是问题：一旦进程退出，这些结构最终都会被清理掉。但是这些结构可能会让一些调试工具误以为 Libevent 正在泄漏资源。如果你需要确保 Libevent 已经释放了所有全局数据，你可以调用：</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>void</strong> libevent_global_shutdown(<strong>void</strong>);</code></pre>
</div></div>
<div class="paragraph"><p>This function doesn’t free any structures that were returned to you by a
Libevent function.  If you want to free everything before exiting, you’ll
need to free all events, event_bases, bufferevents, and so on yourself.</p><p class="translate">这个函数不会释放任何由 Libevent 函数返回给你的结构。如果你想在退出前释放所有内容，你需要自己释放所有事件、event_bases、bufferevents 等。</p></div>
<div class="paragraph"><p>Calling libevent_global_shutdown() will make other Libevent functions behave
unpredictably; don’t call it except as the last Libevent function your
program invokes.  One exception is that libevent_global_shutdown() is
idempotent: it is okay to call it even if it has already been called.</p><p class="translate">调用 libevent_global_shutdown() 将使其他 Libevent 函数的行为变得不可预测；除非作为程序调用的最后一个 Libevent 函数，否则不要调用它。一个例外是 libevent_global_shutdown() 是幂等的：即使它已经被调用过，再次调用它也是可以的。</p></div>
<div class="paragraph"><p>This function is declared in &lt;event2/event.h&gt;. It was introduced in Libevent
2.1.1-alpha.</p><p class="translate">这个函数在 <event2 event.h=""> 中声明。它在 Libevent 2.1.1-alpha 中引入。</event2></p></div>
</div>
</div>
</div>
<div id="footnotes"><hr></div>
<div id="footer">
<div id="footer-text">
Last updated
 2024-02-18 20:10:44 UTC
</div>
</div>


</body></html>