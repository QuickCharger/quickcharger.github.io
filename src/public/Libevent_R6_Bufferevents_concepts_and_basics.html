<!--?xml version="1.0" encoding="UTF-8"?--><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8">
<meta name="generator" content="AsciiDoc 10.1.2">
<title>Bufferevents: concepts and basics</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overridden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-M3CEY418LQ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-M3CEY418LQ');
</script>
<style id="translation-style">
      .translate {
        background-color: #f0f0f0; /* 浅灰色背景 */
        color: black;             /* 黑色文本 */
        font-weight: bold;        /* 加粗字体 */
      }
    </style></head>
<body class="article">
<div id="header">
<h1>Bufferevents: concepts and basics</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="quoteblock">
<div class="content">
<div class="paragraph"><p>These documents are Copyright (c) 2009-2012 by Nick Mathewson, and are made
available under the Creative Commons Attribution-Noncommercial-Share Alike
license, version 3.0.  Future versions may be made available under a less
restrictive license.</p></div>
<div class="paragraph"><p>Additionally, the source code examples in these documents are also licensed
under the so-called "3-Clause" or "Modified" BSD license. See
<a href="license_bsd.html">the license_bsd file</a> distributed with these documents
for the full terms.</p></div>
<div class="paragraph"><p>To get the source for the latest version of this document, install git
and run "git clone git://github.com/libevent/libevent-book.git"</p></div>
</div>
<div class="attribution">
</div></div>
<div class="paragraph"><p>Most of the time, an application wants to perform some amount of data
buffering in addition to just responding to events.  When we want to
write data, for example, the usual pattern runs something like:</p></div>
<div class="ulist"><ul>
<li>
<p>
Decide that we want to write some data to a connection; put that
  data in a buffer.
</p>
</li>
<li>
<p>
Wait for the connection to become writable
</p>
</li>
<li>
<p>
Write as much of the data as we can
</p>
</li>
<li>
<p>
Remember how much we wrote, and if we still have more data to write,
  wait for the connection to become writable again.
</p><p class="translate">大部分时间，应用程序除了简单地响应event外，还希望进行一定量的数据缓冲。例如，当我们想要写入数据时，通常的模式是这样的：<br>- 我们想要向一个连接写入一些数据；将那些数据放入一个缓冲区（buffer）中。<br>- 等待连接变得可写入。<br>- 写入尽可能多的数据。<br>- 记住我们写入了多少，并且如果我们还有更多数据要写入，等待连接再次变得可写入。</p>
</li>
</ul></div>
<div class="paragraph"><p>This buffered IO pattern is common enough that Libevent provides a
generic mechanism for it.  A "bufferevent" consists of an
underlying transport (like a socket), a read buffer, and a write
buffer.  Instead of regular events, which give callbacks when the
underlying transport is ready to be read or written, a bufferevent
invokes its user-supplied callbacks when it has read or written enough
data.</p><p class="translate">这种缓冲式 IO 模式足够常见，以至于 Libevent 提供了一个通用机制。一个 "bufferevent" 包含了一个底层传输（比如一个socket）、一个读buffer和一个写buffer。与普通event不同，普通event在底层传输准备好读取或写入时给出回调，bufferevent 在它读取或写入足够数据时调用用户提供的回调函数。</p></div>
<div class="paragraph"><p>There are multiple types of bufferevent that all share a common
interface.  As of this writing, the following types exist:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
socket-based bufferevents
</dt>
<dd>
<p>
    A bufferevent that sends and receives data from an underlying
    stream socket, using the event_* interface as its backend.
</p>
</dd>
<dt class="hdlist1">
asynchronous-IO bufferevents
</dt>
<dd>
<p>
    A bufferevent that uses the Windows IOCP interface to send and
    receive data to an underlying stream socket.  (Windows only;
    experimental.)
</p>
</dd>
<dt class="hdlist1">
filtering bufferevents
</dt>
<dd>
<p>
    A bufferevent that processes incoming and outgoing data before
    passing it to an underlying bufferevent object—for example, to
    compress or translate data.
</p>
</dd>
<dt class="hdlist1">
paired bufferevents
</dt>
<dd>
<p>
    Two bufferevents that transmit data to one another.
</p><p class="translate">bufferevent 有多种类型，它们共享一个通用接口。在本文撰写之时，以下类型存在：<br>基于socket的 bufferevents<br>  一个从底层流socket发送和接收数据的 bufferevent，使用 event_* 接口作为它的后端。<br>异步 IO bufferevents<br>  使用 Windows IOCP 接口向底层流socket发送和接收数据的 bufferevent。（仅限 Windows；实验性的。）<br>过滤 bufferevents<br>  在将数据传递给底层 bufferevent 对象之前处理传入和传出数据的 bufferevent——例如，压缩或转换数据。<br>配对的 bufferevents<br>  两个互相传输数据的 bufferevent。</p>
</dd>
</dl></div>
<div class="paragraph"><div class="title">NOTE</div><p>As of Libevent 2.0.2-alpha, the bufferevents interfaces here are still
not fully orthogonal across all bufferevent types.  In other words,
not every interface described below will work on all bufferevent types.
The Libevent developers intend to correct this in future versions.</p><p class="translate">截至 Libevent 2.0.2-alpha 版本，这里的 bufferevents 接口在所有 bufferevent 类型之间仍然不是完全正交的。换句话说，并非下面描述的每个接口都适用于所有类型的 bufferevent。Libevent 的开发者计划在未来的版本中纠正这一点。</p></div>
<div class="paragraph"><div class="title">NOTE ALSO</div><p>Bufferevents currently only work for stream-oriented protocols like TCP.
There may in the future be support for datagram-oriented protocols like UDP.</p><p class="translate">Bufferevents 当前只适用于像 TCP 这样的流式协议。将来可能会支持UDP 这样的数据报协议。</p></div>
<div class="paragraph"><p>All of the functions and types in this section are declared in
event2/bufferevent.h.  Functions specifically related to evbuffers are
declared in event2/buffer.h; see the next chapter for information on
those.</p><p class="translate">这一部分中的所有函数和类型都声明在 event2/bufferevent.h 中。特别与 evbuffers 相关的函数在 event2/buffer.h 中声明；有关这些内容的信息请参阅下一章。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_bufferevents_and_evbuffers">Bufferevents and evbuffers</h2>
<div class="sectionbody">
<div class="paragraph"><p>Every bufferevent has an input buffer and an output buffer.  These are
of type "struct evbuffer".  When you have data to write on a
bufferevent, you add it to the output buffer; when a bufferevent has
data for you to read, you drain it from the input buffer.</p><p class="translate">每个bufferevent都有一个输入buffer和一个输出buffer。它们都是"struct evbuffer"类型的。当你有数据需要通过bufferevent写入时，你将它添加到输出buffer；当一个bufferevent有数据供你读取时，你需要从输入buffer中将它取出。</p></div>
<div class="paragraph"><p>The evbuffer interface supports many operations; we discuss them in a
later section.</p><p class="translate">evbuffer接口支持许多操作；我们将在后面的章节中讨论这些操作。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_callbacks_and_watermarks">Callbacks and watermarks</h2>
<div class="sectionbody">
<div class="paragraph"><p>Every bufferevent has two data-related callbacks: a read callback
and a write callback.  By default, the read callback is called
whenever any data is read from the underlying transport, and the write
callback is called whenever enough data from the output buffer is emptied to
the underlying transport.  You can override the behavior of these functions
by adjusting the read and write "watermarks" of the bufferevent.</p><p class="translate">每个bufferevent都有两个与数据相关的回调函数：一个读回调和一个写回调。默认情况下，只要从底层传输读取到任何数据，读回调函数就会被调用；只要从输出buffer向底层传输并清空了足够的空间，写回调函数就被调用。你可以通过调整bufferevent的读写“水位标记”（水位标记）来改变这些函数的行为。</p></div>
<div class="paragraph"><p>Every bufferevent has four watermarks:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Read low-water mark
</dt>
<dd>
<p>
   Whenever a read occurs that leaves the bufferevent’s input buffer
   at this level or higher, the bufferevent’s read callback is invoked.
   Defaults to 0, so that every read results in the read callback
   being invoked.
</p>
</dd>
<dt class="hdlist1">
Read high-water mark
</dt>
<dd>
<p>
   If the bufferevent’s input buffer ever gets to this level, the
   bufferevent stops reading until enough data is drained from the
   input buffer to take us below it again.  Defaults to unlimited, so
   that we never stop reading because of the size of the input buffer.
</p>
</dd>
<dt class="hdlist1">
Write low-water mark
</dt>
<dd>
<p>
   Whenever a write occurs that takes us to this level or below, we
   invoke the write callback.  Defaults to 0, so that a write callback
   is not invoked unless the output buffer is emptied.
</p>
</dd>
<dt class="hdlist1">
Write high-water mark
</dt>
<dd>
<p>
   Not used by a bufferevent directly, this watermark can have special
   meaning when a bufferevent is used as the underlying transport of
   another bufferevent.  See notes on filtering bufferevents below.
</p><p class="translate">每个bufferevent都有四个watermark：<br>Read low-water mark<br>  每当发生一次读取，使bufferevent的输入buffer达到或超过阈值，就会调用bufferevent的读取回调函数。默认值阈值为0，这样每次读取都会触发读取回调。<br>Read high-water mark<br>  如果bufferevent的输入buffer的数据量达到阈值，bufferevent就会停止读取，直到在输入buffer中清空足够的空间，使我们再次低于阈值。默认值阈值为无限制，因此我们不会因为输入buffer的大小而停止读取。<br>Write low-water mark<br>  每当发生一次写入操作，使空间达到或低于阈值，就会调用写回调函数。默认值为0，因此只有在输出buffer被清空时才会调用写回调函数。<br>Write high-water mark<br>  直接由bufferevent使用的写入高水位标记，当bufferevent被用作另一个bufferevent的底层传输时，这个水位标记可能有特殊的含义。请参阅下面关于过滤bufferevent的注释。</p>
</dd>
</dl></div>
<div class="paragraph"><p>A bufferevent also has an "error" or "event" callback that gets
invoked to tell the application about non-data-oriented events, like
when a connection is closed or an error occurs.  The following event
flags are defined:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
BEV_EVENT_READING
</dt>
<dd>
<p>
   An event occured during a read operation on the bufferevent.  See
   the other flags for which event it was.
</p>
</dd>
<dt class="hdlist1">
BEV_EVENT_WRITING
</dt>
<dd>
<p>
   An event occured during a write operation on the bufferevent.  See
   the other flags for which event it was.
</p>
</dd>
<dt class="hdlist1">
BEV_EVENT_ERROR
</dt>
<dd>
<p>
   An error occurred during a bufferevent operation.  For more
   information on what the error was, call EVUTIL_SOCKET_ERROR().
</p>
</dd>
<dt class="hdlist1">
BEV_EVENT_TIMEOUT
</dt>
<dd>
<p>
   A timeout expired on the bufferevent.
</p>
</dd>
<dt class="hdlist1">
BEV_EVENT_EOF
</dt>
<dd>
<p>
   We got an end-of-file indication on the bufferevent.
</p>
</dd>
<dt class="hdlist1">
BEV_EVENT_CONNECTED
</dt>
<dd>
<p>
   We finished a requested connection on the bufferevent.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>(The above event names are new in Libevent 2.0.2-alpha.)</p><p class="translate">bufferevent还有一个“错误”或“事件”回调函数，当发生非数据导向事件时会被调用，比如当连接关闭或发生错误时。以下事件标志被定义：<br>BEV_EVENT_READING<br>  在bufferevent的读操作期间发生了事件。看其他标志以确定是哪个事件。<br>BEV_EVENT_WRITING<br>  在bufferevent的写操作期间发生了事件。看其他标志以确定是哪个事件。<br>BEV_EVENT_ERROR<br>  在bufferevent操作期间发生错误。要获取更多错误信息，请调用EVUTIL_SOCKET_ERROR()。<br>BEV_EVENT_TIMEOUT<br>  bufferevent超时。<br>BEV_EVENT_EOF<br>  我们在bufferevent上得到了EOF。<br>BEV_EVENT_CONNECTED<br>  我们完成了在bufferevent上请求的连接。<br>（以上事件名称在Libevent 2.0.2-alpha中是新的。）</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_deferred_callbacks">Deferred callbacks</h2>
<div class="sectionbody">
<div class="paragraph"><p>By default, a bufferevent callbacks are executed <em>immediately</em> when
the corresponding condition happens.  (This is true of evbuffer
callbacks too; we’ll get to those later.)  This immediate invocation
can make trouble when dependencies get complex.  For example, suppose
that there is a callback that moves data into evbuffer A when it grows
empty, and another callback that processes data out of evbuffer A when
it grows full.  Since these calls are all happening on the stack, you
might risk a stack overflow if the dependency grows nasty enough.</p><p class="translate">默认情况下，bufferevent的回调会立即执行。（evbuffer的回调也是如此；我们稍后再讨论这些。）当依赖关系变得复杂时，这种立即调用可能会引起麻烦。例如，假设有一个回调函数在evbuffer A变空时将数据移入，另一个回调函数在evbuffer A变满时处理数据。由于这些调用都是在栈上进行的，如果依赖关系变得足够复杂，你可能会冒着栈溢出的风险。</p></div>
<div class="paragraph"><p>To solve this, you can tell a bufferevent (or an evbuffer) that its
callbacks should be <em>deferred</em>.  When the conditions are met for a
deferred callback, rather than invoking it immediately, it is queued
as part of the event_loop() call, and invoked after  the regular events'
callbacks.</p><p class="translate">为了解决这个问题，你可以告诉bufferevent（或evbuffer），其回调应该被延迟。当满足延迟回调的条件时，不会立即调用它，而是将其在event_loop()排队，并在常规event回调之后调用。</p></div>
<div class="paragraph"><p>(Deferred callbacks were introduced in Libevent 2.0.1-alpha.)</p><p class="translate">（延迟回调功能在Libevent 2.0.1-alpha中引入。）</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_option_flags_for_bufferevents">Option flags for bufferevents</h2>
<div class="sectionbody">
<div class="paragraph"><p>You can use one or more flags when creating a bufferevent to alter its
behavior.  Recognized flags are:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
BEV_OPT_CLOSE_ON_FREE
</dt>
<dd>
<p>
    When the bufferevent is freed, close the underlying transport.
    This will close an underlying socket, free an underlying
    bufferevent, etc.
</p>
</dd>
<dt class="hdlist1">
BEV_OPT_THREADSAFE
</dt>
<dd>
<p>
    Automatically allocate locks for the bufferevent, so that it’s
    safe to use from multiple threads.
</p>
</dd>
<dt class="hdlist1">
BEV_OPT_DEFER_CALLBACKS
</dt>
<dd>
<p>
    When this flag is set, the bufferevent defers all of its callbacks,
    as described above.
</p>
</dd>
<dt class="hdlist1">
BEV_OPT_UNLOCK_CALLBACKS
</dt>
<dd>
<p>
    By default, when the bufferevent is set up to be threadsafe, the
    bufferevent’s locks are held whenever the any user-provided
    callback is invoked.  Setting this option makes Libevent release
    the bufferevent’s lock when it’s invoking your callbacks.
</p><p class="translate">在创建bufferevent时，你可以使用一个或多个标志来改变其行为。被识别的标志包括：<br>BEV_OPT_CLOSE_ON_FREE<br>  当bufferevent被释放时，关闭底层传输。这将关闭底层socket，释放底层bufferevent等。<br>BEV_OPT_THREADSAFE<br>  为bufferevent自动分配锁，这样它就可以安全地在多个线程中使用。<br>BEV_OPT_DEFER_CALLBACKS<br>  设置此标志后，bufferevent会延迟其所有回调，如上所述。<br>BEV_OPT_UNLOCK_CALLBACKS<br>  默认情况下，当bufferevent设置为线程安全时，调用用户提供的回调时，bufferevent都会被上锁。设置这个选项会使Libevent在调用用户回调时释放bufferevent的锁。</p>
</dd>
</dl></div>
<div class="paragraph"><p>(Libevent 2.0.5-beta introduced BEV_OPT_UNLOCK_CALLBACKS.  The other options
above were new in Libevent 2.0.1-alpha.)</p><p class="translate">（Libevent 2.0.5-beta引入了BEV_OPT_UNLOCK_CALLBACKS。上面的其他选项在Libevent 2.0.1-alpha中是新的。）</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_working_with_socket_based_bufferevents">Working with socket-based bufferevents</h2>
<div class="sectionbody">
<div class="paragraph"><p>The simplest bufferevents to work with is the socket-based type.  A
socket-based bufferevent uses Libevent’s underlying event mechanism to
detect when an underlying network socket is ready for read and/or write
operations, and uses underlying network calls (like readv, writev,
WSASend, or WSARecv) to transmit and receive data.</p><p class="translate">bufferevent中最简单的是基于socket的操作。基于socket的bufferevent使用Libevent的底层事件机制来检测底层网络socket何时准备好进行读取和/或写入操作，并使用底层网络调用（如readv、writev、WSASend或WSARecv）来传输和接收数据。</p></div>
<div class="sect2">
<h3 id="_creating_a_socket_based_bufferevent">Creating a socket-based bufferevent</h3>
<div class="paragraph"><p>You can create a socket-based bufferevent using
bufferevent_socket_new():</p><p class="translate">你可以使用bufferevent_socket_new()创建一个基于socket的bufferevent：</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>struct</strong> bufferevent *bufferevent_socket_new(
    <strong>struct</strong> event_base *base,
    evutil_socket_t fd,
    <strong>enum</strong> bufferevent_options options);</code></pre>
</div></div>
<div class="paragraph"><p>The <em>base</em> is an event_base, and <em>options</em> is a bitmask of bufferevent
options (BEV_OPT_CLOSE_ON_FREE, etc).  The <em>fd</em> argument is an
optional file descriptor for a socket.  You can set fd to -1 if
you want to set the file descriptor later.</p><p class="translate">参数base是event_base，options是bufferevent的位掩码（BEV_OPT_CLOSE_ON_FREE等）。fd是可选的socket。如果你想稍后设置fd，可以将fd设置为-1。</p></div>
<div class="admonitionblock">
<table><tbody><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">[Make sure that the socket you provide to bufferevent_socket_new is
in non-blocking mode. Libevent provides the convenience method
evutil_make_socket_nonblocking for this.]</td>
</tr></tbody></table>
</div>
<div class="paragraph"><p>This function returns a bufferevent on success, and NULL on failure.</p><p class="translate">此函数在成功时返回bufferevent，在失败时返回NULL。</p></div>
<div class="paragraph"><p>The bufferevent_socket_new() function was introduced in Libevent 2.0.1-alpha.</p><p class="translate">bufferevent_socket_new()函数在Libevent 2.0.1-alpha中引入。</p></div>
</div>
<div class="sect2">
<h3 id="_launching_connections_on_socket_based_bufferevents">Launching connections on socket-based bufferevents</h3>
<div class="paragraph"><p>If the bufferevent’s socket is not yet connected, you can launch a new
connection.</p><p class="translate">如果bufferevent的socket尚未连接，你可以启动新的连接。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>int</strong> bufferevent_socket_connect(<strong>struct</strong> bufferevent *bev,
    <strong>struct</strong> sockaddr *address, <strong>int</strong> addrlen);</code></pre>
</div></div>
<div class="paragraph"><p>The address and addrlen arguments are as for the standard call
connect().  If the bufferevent does not already have a socket set,
calling this function allocates a new stream socket for it, and makes
it nonblocking.</p><p class="translate">address和addrlen参数与标准调用connect()的参数相同。如果bufferevent尚未设置socket，调用此函数会为其分配一个新的tcp socket，并使其非阻塞。</p></div>
<div class="paragraph"><p>If the bufferevent <strong>does</strong> have a socket already, calling
bufferevent_socket_connect() tells Libevent that the socket is not
connected, and no reads or writes should be done on the socket until
the connect operation has succeeded.</p><p class="translate">如果bufferevent已经有socket，调用bufferevent_socket_connect()会告诉Libevent socket未连接，在连接操作成功之前不应在socket上进行读取或写入操作。</p></div>
<div class="paragraph"><p>It is okay to add data to the output buffer before the connect is
done.</p><p class="translate">在连接完成之前向输出buffer添加数据是可以的 ！！！</p></div>
<div class="paragraph"><p>This function returns 0 if the connect was successfully launched, and
-1 if an error occurred.</p><p class="translate">如果连接成功启动，此函数返回0；如果发生错误，返回-1。</p></div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre><code>#include &lt;event2/event.h&gt;
#include &lt;event2/bufferevent.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;string.h&gt;

<strong>void</strong> eventcb(<strong>struct</strong> bufferevent *bev, <strong>short</strong> events, <strong>void</strong> *ptr)
{
    <strong>if</strong> (events &amp; BEV_EVENT_CONNECTED) {
<i>         /* We're connected to 127.0.0.1:8080.   Ordinarily we'd do</i>
<i>            something here, like start reading or writing. */</i>
    } <strong>else</strong> <strong>if</strong> (events &amp; BEV_EVENT_ERROR) {
<i>         /* An error occured while connecting. */</i>
    }
}

<strong>int</strong> main_loop(<strong>void</strong>)
{
    <strong>struct</strong> event_base *base;
    <strong>struct</strong> bufferevent *bev;
    <strong>struct</strong> sockaddr_in sin;

    base = event_base_new();

    memset(&amp;sin, 0, <strong>sizeof</strong>(sin));
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = htonl(0x7f000001); /* 127.0.0.1 */
    sin.sin_port = htons(8080); /* Port 8080 */

    bev = bufferevent_socket_new(base, -1, BEV_OPT_CLOSE_ON_FREE);

    bufferevent_setcb(bev, NULL, NULL, eventcb, NULL);

    <strong>if</strong> (bufferevent_socket_connect(bev,
        (<strong>struct</strong> sockaddr *)&amp;sin, <strong>sizeof</strong>(sin)) &lt; 0) {
<i>        /* Error starting connection */</i>
        bufferevent_free(bev);
        <strong>return</strong> -1;
    }

    event_base_dispatch(base);
    <strong>return</strong> 0;
}</code></pre>
</div></div>
<div class="paragraph"><p>The bufferevent_socket_connect() function was introduced in
Libevent-2.0.2-alpha.  Before then, you had to manually call
connect() on your socket yourself, and when the connection was
complete, the bufferevent would report it as a write.</p><p class="translate">bufferevent_socket_connect()函数在Libevent-2.0.2-alpha中引入。在此之前，你必须手动在你的socket上调用connect()，当连接完成时，bufferevent会将其报告为一个写入操作。</p></div>
<div class="paragraph"><p>Note that you only get a BEV_EVENT_CONNECTED event if you launch the
connect() attempt using bufferevent_socket_connect().  If you call
connect() on your own, the connection gets reported as a write.</p><p class="translate">请注意，只有在使用bufferevent_socket_connect()尝试connect()时，你才会收到BEV_EVENT_CONNECTED事件。如果你自己调用connect()，连接会被报告为一个写入操作。</p></div>
<div class="paragraph"><p>If you want to call connect() yourself, but still get receive a
BEV_EVENT_CONNECTED event when the connection succeeds, call
bufferevent_socket_connect(bev, NULL, 0) after connect() returns -1 with
errno equal to EAGAIN or EINPROGRESS.</p><p class="translate">如果你想自己调用connect()，但仍然希望在连接成功时收到BEV_EVENT_CONNECTED事件，请在connect()返回-1且errno等于EAGAIN或EINPROGRESS之后调用bufferevent_socket_connect(bev, NULL, 0)。</p></div>
<div class="paragraph"><p>This function was introduced in Libevent 2.0.2-alpha.</p><p class="translate">这个函数在 Libevent 2.0.2-alpha 中引入。</p></div>
</div>
<div class="sect2">
<h3 id="_launching_connections_by_hostname">Launching connections by hostname</h3>
<div class="paragraph"><p>Quite often, you’d like to combine resolving a hostname and connecting to it
into a single operation.  There’s an interface for that:</p><p class="translate">很多时候，你可能希望将解析主机名和连接到它合并为单个操作。有一个接口可以做到这一点：</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>int</strong> bufferevent_socket_connect_hostname(<strong>struct</strong> bufferevent *bev,
    <strong>struct</strong> evdns_base *dns_base, <strong>int</strong> family, <strong>const</strong> <strong>char</strong> *hostname,
    <strong>int</strong> port);
<strong>int</strong> bufferevent_socket_get_dns_error(<strong>struct</strong> bufferevent *bev);</code></pre>
</div></div>
<div class="paragraph"><p>This function resolves the DNS name <em>hostname</em>, looking for addresses of type
<em>family</em>.  (Allowable family types are AF_INET, AF_INET6, and AF_UNSPEC.)  If
the name resolution fails, it invokes the event callback with an error event.
If it succeeds, it launches a connection attempt just as bufferevent_connect
would.</p><p class="translate">这个函数解析DNS名称hostname，寻找类型为family的地址。（允许的family类型有AF_INET、AF_INET6和AF_UNSPEC。）如果解析失败，它会使用错误事件调用事件回调。如果成功，它会启动一个连接尝试，就像bufferevent_connect一样。</p></div>
<div class="paragraph"><p>The dns_base argument is optional.  If it is NULL, then Libevent blocks while
waiting for the name lookup to finish, which usually isn’t what you want.  If
it is provided, then Libevent uses it to look up the hostname asynchronously.
See <a href="Ref9_dns.html">chapter R9</a> for more info on DNS.</p><p class="translate">dns_base参数是可选的。如果它为NULL，那么Libevent在等待名称查找完成时会阻塞，这通常不是你想要的。如果提供了dns_base，则Libevent使用它来异步查找主机名。更多关于DNS的信息，请参见第R9章。</p></div>
<div class="paragraph"><p>As with bufferevent_socket_connect(), this function tells Libevent that any
existing socket on the bufferevent is not connected, and no reads or writes
should be done on the socket until the resolve is finished and the connect
operation has succeeded.</p><p class="translate">与bufferevent_socket_connect()一样，这个函数告诉Libevent，bufferevent上的任何现有socket都未连接，在解析完成和连接操作成功之前不应在socket上进行读取或写入操作。</p></div>
<div class="paragraph"><p>If an error occurs, it might be a DNS hostname lookup error.  You can find
out what the most recent error was by calling
bufferevent_socket_get_dns_error().  If the returned error code is 0, no DNS
error was detected.</p><p class="translate">如果发生错误，它可能是DNS主机名查找错误。你可以通过调用bufferevent_socket_get_dns_error()来查明错误。如果返回的错误代码是0，表示没有检测到DNS错误。</p></div>
<div class="listingblock">
<div class="title">Example: Trivial HTTP v0 client.</div>
<div class="content">
<pre><code><i>/* Don't actually copy this code: it is a poor way to implement an</i>
<i>   HTTP client.  Have a look at evhttp instead.</i>
<i>*/</i>
#include &lt;event2/dns.h&gt;
#include &lt;event2/bufferevent.h&gt;
#include &lt;event2/buffer.h&gt;
#include &lt;event2/util.h&gt;
#include &lt;event2/event.h&gt;

#include &lt;stdio.h&gt;

<strong>void</strong> readcb(<strong>struct</strong> bufferevent *bev, <strong>void</strong> *ptr)
{
    <strong>char</strong> buf[1024];
    <strong>int</strong> n;
    <strong>struct</strong> evbuffer *input = bufferevent_get_input(bev);
    <strong>while</strong> ((n = evbuffer_remove(input, buf, <strong>sizeof</strong>(buf))) &gt; 0) {
        fwrite(buf, 1, n, stdout);
    }
}

<strong>void</strong> eventcb(<strong>struct</strong> bufferevent *bev, <strong>short</strong> events, <strong>void</strong> *ptr)
{
    <strong>if</strong> (events &amp; BEV_EVENT_CONNECTED) {
         printf("Connect okay.\n");
    } <strong>else</strong> <strong>if</strong> (events &amp; (BEV_EVENT_ERROR|BEV_EVENT_EOF)) {
         <strong>struct</strong> event_base *base = ptr;
         <strong>if</strong> (events &amp; BEV_EVENT_ERROR) {
                 <strong>int</strong> err = bufferevent_socket_get_dns_error(bev);
                 <strong>if</strong> (err)
                         printf("DNS error: %s\n", evutil_gai_strerror(err));
         }
         printf("Closing\n");
         bufferevent_free(bev);
         event_base_loopexit(base, NULL);
    }
}

<strong>int</strong> main(<strong>int</strong> argc, <strong>char</strong> **argv)
{
    <strong>struct</strong> event_base *base;
    <strong>struct</strong> evdns_base *dns_base;
    <strong>struct</strong> bufferevent *bev;

    <strong>if</strong> (argc != 3) {
        printf("Trivial HTTP 0.x client\n"
               "Syntax: %s [hostname] [resource]\n"
               "Example: %s www.google.com /\n",argv[0],argv[0]);
        <strong>return</strong> 1;
    }

    base = event_base_new();
    dns_base = evdns_base_new(base, 1);

    bev = bufferevent_socket_new(base, -1, BEV_OPT_CLOSE_ON_FREE);
    bufferevent_setcb(bev, readcb, NULL, eventcb, base);
    bufferevent_enable(bev, EV_READ|EV_WRITE);
    evbuffer_add_printf(bufferevent_get_output(bev), "GET %s\r\n", argv[2]);
    bufferevent_socket_connect_hostname(
        bev, dns_base, AF_UNSPEC, argv[1], 80);
    event_base_dispatch(base);
    <strong>return</strong> 0;
}</code></pre>
</div></div>
<div class="paragraph"><p>The bufferevent_socket_connect_hostname() function was new in Libevent
2.0.3-alpha; bufferevent_socket_get_dns_error() was new in 2.0.5-beta.</p><p class="translate">bufferevent_socket_connect_hostname() 函数在 Libevent 2.0.3-alpha 版本中首次引入；bufferevent_socket_get_dns_error() 函数在 2.0.5-beta 版本中新增。</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_generic_bufferevent_operations">Generic bufferevent operations</h2>
<div class="sectionbody">
<div class="paragraph"><p>The functions in this section work with multiple bufferevent
implementations.</p><p class="translate">本节中的函数适用于多种bufferevent实现。</p></div>
<div class="sect2">
<h3 id="_freeing_a_bufferevent">Freeing a bufferevent</h3>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>void</strong> bufferevent_free(<strong>struct</strong> bufferevent *bev);</code></pre>
</div></div>
<div class="paragraph"><p>This function frees a bufferevent.  Bufferevents are internally
reference-counted, so if the bufferevent has pending deferred
callbacks when you free it, it won’t be deleted until the callbacks
are done.</p><p class="translate">这个函数释放bufferevent。Bufferevent在内部是通过引用计数的方式管理的，所以，如果在你释放它的时候bufferevent还有待处理的延迟回调，它不会被立即删除，直到这些回调处理完成。</p></div>
<div class="paragraph"><p>The bufferevent_free() function does, however, try to free the
bufferevent as soon as possible.  If there is pending data to write on
the bufferevent, it probably won’t be flushed before the bufferevent is
freed.</p><p class="translate">然而，bufferevent_free()函数确实尝试尽快释放bufferevent。如果bufferevent上还有待发送的数据，这些数据可能发不出去。</p></div>
<div class="paragraph"><p>If the BEV_OPT_CLOSE_ON_FREE flag was set, and this bufferevent has a
socket or underlying bufferevent associated with it as its transport,
that transport is closed when you free the bufferevent.</p><p class="translate">如果设置了BEV_OPT_CLOSE_ON_FREE标志，并且这个bufferevent拥有socket，释放bufferevent时，该传输方式将被关闭。</p></div>
<div class="paragraph"><p>This function was introduced in Libevent 0.8.</p><p class="translate">这个函数在Libevent 0.8版本中引入。</p></div>
</div>
<div class="sect2">
<h3 id="_manipulating_callbacks_watermarks_and_enabled_operations">Manipulating callbacks, watermarks, and enabled operations</h3>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>typedef</strong> <strong>void</strong> (*bufferevent_data_cb)(<strong>struct</strong> bufferevent *bev, <strong>void</strong> *ctx);
<strong>typedef</strong> <strong>void</strong> (*bufferevent_event_cb)(<strong>struct</strong> bufferevent *bev,
    <strong>short</strong> events, <strong>void</strong> *ctx);

<strong>void</strong> bufferevent_setcb(<strong>struct</strong> bufferevent *bufev,
    bufferevent_data_cb readcb, bufferevent_data_cb writecb,
    bufferevent_event_cb eventcb, <strong>void</strong> *cbarg);

<strong>void</strong> bufferevent_getcb(<strong>struct</strong> bufferevent *bufev,
    bufferevent_data_cb *readcb_ptr,
    bufferevent_data_cb *writecb_ptr,
    bufferevent_event_cb *eventcb_ptr,
    <strong>void</strong> **cbarg_ptr);</code></pre>
</div></div>
<div class="paragraph"><p>The bufferevent_setcb() function changes one or more of the callbacks
of a bufferevent.  The readcb, writecb, and eventcb functions are
called (respectively) when enough data is read, when enough data is
written, or when an event occurs.  The first argument of each is the
bufferevent that has had the event happen.  The last argument is the
value provided by the user in the <em>cbarg</em> parameter of
bufferevent_callcb(): You can use this to pass data to your
callbacks.  The <em>events</em> argument of the event callback is a bitmask
of event flags: see "callbacks and watermarks" above.</p><p class="translate">bufferevent_setcb()函数更改一个或多个bufferevent的回调。当读取到足够的数据、写入足够的数据，或发生某个事件时，分别调用readcb、writecb和eventcb函数。每个函数的第一个参数是发生事件的bufferevent。最后一个参数是用户在bufferevent_callcb()的cbarg参数中提供的值：你可以使用这个参数向回调传递数据。events参数是事件标志的位掩码：参见上文的“回调和水位”。</p></div>
<div class="paragraph"><p>You can disable a callback by passing NULL instead of the callback
function.  Note all the callback functions on a bufferevent share a
single <em>cbarg</em> value, so changing it will affect all of them.</p><p class="translate">你可以通过传递NULL来禁用回调，而不是传递回调函数。注意，bufferevent上的所有回调函数共享cbarg值，所以更改它会影响所有回调。</p></div>
<div class="paragraph"><p>You can retrieve the currently set callbacks for a bufferevent by passing
pointers to bufferevent_getcb(), which sets *readcb_ptr to the current read
callback, *writecb_ptr to the current write callback, *eventcb_ptr to the
current event callback, and *cbarg_ptr to the current callback argument
field.  Any of these pointers set to NULL will be ignored.</p><p class="translate">你可以通过向bufferevent_getcb()传递指针来检索bufferevent的当前设置的回调，该函数会设置*readcb_ptr为当前的读取回调，*writecb_ptr为当前的写入回调，*eventcb_ptr为当前的事件回调，*cbarg_ptr为当前的回调参数字段。任何设置为NULL的指针都将被忽略。</p></div>
<div class="paragraph"><p>The bufferevent_setcb() function was introduced in Libevent 1.4.4.  The type
names "bufferevent_data_cb" and "bufferevent_event_cb" were new in Libevent
2.0.2-alpha.  The bufferevent_getcb() function was added in 2.1.1-alpha.</p><p class="translate">bufferevent_setcb()函数在Libevent 1.4.4版本中引入。类型名“bufferevent_data_cb”和“bufferevent_event_cb”在Libevent 2.0.2-alpha版本中新增。bufferevent_getcb()函数在2.1.1-alpha中添加。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>void</strong> bufferevent_enable(<strong>struct</strong> bufferevent *bufev, <strong>short</strong> events);
<strong>void</strong> bufferevent_disable(<strong>struct</strong> bufferevent *bufev, <strong>short</strong> events);

<strong>short</strong> bufferevent_get_enabled(<strong>struct</strong> bufferevent *bufev);</code></pre>
</div></div>
<div class="paragraph"><p>You can enable or disable the events EV_READ, EV_WRITE, or
EV_READ|EV_WRITE on a bufferevent.  When reading or writing is not
enabled, the bufferevent will not try to read or write data.</p><p class="translate">你可以在bufferevent上启用或禁用EV_READ、EV_WRITE或EV_READ|EV_WRITE事件。当未启用读取或写入时，bufferevent不会尝试读取或写入数据。</p></div>
<div class="paragraph"><p>There is no need to disable writing when the output buffer is empty:
the bufferevent automatically stops writing, and restarts again
when there is data to write.</p><p class="translate">当输出buffer为空时，无需禁用写入：bufferevent会自动停止写入，并在有数据要写入时再次开始。</p></div>
<div class="paragraph"><p>Similarly, there is no need to disable reading when the input buffer
is up to its high-water mark: the bufferevent automatically stops
reading, and restarts again when there is space to read.</p><p class="translate">同样，当输入缓冲区达到high-water mark，无需禁用读取：bufferevent会自动停止读取，并在有空间可读时再次开始。</p></div>
<div class="paragraph"><p>By default, a newly created bufferevent has writing enabled, but not
reading.</p><p class="translate">默认情况下，新创建的bufferevent启用了写入，但未启用读取。</p></div>
<div class="paragraph"><p>You can call bufferevent_get_enabled() to see which events are currently
enabled on the bufferevent.</p><p class="translate">你可以调用bufferevent_get_enabled()来查看bufferevent上当前启用了哪些事件。</p></div>
<div class="paragraph"><p>These functions were introduced in Libevent 0.8, except for
bufferevent_get_enabled(), which was introduced in version 2.0.3-alpha.</p><p class="translate">这些函数在Libevent 0.8版本中引入，除了bufferevent_get_enabled()，它在2.0.3-alpha版本中引入。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>void</strong> bufferevent_setwatermark(<strong>struct</strong> bufferevent *bufev, <strong>short</strong> events,
    size_t lowmark, size_t highmark);</code></pre>
</div></div>
<div class="paragraph"><p>The bufferevent_setwatermark() function adjusts the read watermarks,
the write watermarks, or both, of a single bufferevent.  (If EV_READ
is set in the events field, the read watermarks are adjusted.  If
EV_WRITE is set in the events field, the write watermarks are adjusted.)</p><p class="translate">bufferevent_setwatermark()函数调整单个bufferevent的读水位、写水位或两者。如果在events字段中设置了EV_READ，就调整读水位。如果设置了EV_WRITE，就调整写水位。</p></div>
<div class="paragraph"><p>A high-water mark of 0 is equivalent to "unlimited".</p><p class="translate">高水位设置为0等同于“无限制”。</p></div>
<div class="paragraph"><p>This function was first exposed in Libevent 1.4.4.</p><p class="translate">这个函数最初在Libevent 1.4.4版本中公开。</p></div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre><code>#include &lt;event2/event.h&gt;
#include &lt;event2/bufferevent.h&gt;
#include &lt;event2/buffer.h&gt;
#include &lt;event2/util.h&gt;

#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

<strong>struct</strong> info {
    <strong>const</strong> <strong>char</strong> *name;
    size_t total_drained;
};

<strong>void</strong> read_callback(<strong>struct</strong> bufferevent *bev, <strong>void</strong> *ctx)
{
    <strong>struct</strong> info *inf = ctx;
    <strong>struct</strong> evbuffer *input = bufferevent_get_input(bev);
    size_t len = evbuffer_get_length(input);
    <strong>if</strong> (len) {
        inf-&gt;total_drained += len;
        evbuffer_drain(input, len);
        printf("Drained %lu bytes from %s\n",
             (<strong>unsigned</strong> <strong>long</strong>) len, inf-&gt;name);
    }
}

<strong>void</strong> event_callback(<strong>struct</strong> bufferevent *bev, <strong>short</strong> events, <strong>void</strong> *ctx)
{
    <strong>struct</strong> info *inf = ctx;
    <strong>struct</strong> evbuffer *input = bufferevent_get_input(bev);
    <strong>int</strong> finished = 0;

    <strong>if</strong> (events &amp; BEV_EVENT_EOF) {
        size_t len = evbuffer_get_length(input);
        printf("Got a close from %s.  We drained %lu bytes from it, "
            "and have %lu left.\n", inf-&gt;name,
            (<strong>unsigned</strong> <strong>long</strong>)inf-&gt;total_drained, (<strong>unsigned</strong> <strong>long</strong>)len);
        finished = 1;
    }
    <strong>if</strong> (events &amp; BEV_EVENT_ERROR) {
        printf("Got an error from %s: %s\n",
            inf-&gt;name, evutil_socket_error_to_string(EVUTIL_SOCKET_ERROR()));
        finished = 1;
    }
    <strong>if</strong> (finished) {
        free(ctx);
        bufferevent_free(bev);
    }
}

<strong>struct</strong> bufferevent *setup_bufferevent(<strong>void</strong>)
{
    <strong>struct</strong> bufferevent *b1 = NULL;
    <strong>struct</strong> info *info1;

    info1 = malloc(<strong>sizeof</strong>(<strong>struct</strong> info));
    info1-&gt;name = "buffer 1";
    info1-&gt;total_drained = 0;

<i>    /* ... Here we should set up the bufferevent and make sure it gets</i>
<i>       connected... */</i>

<i>    /* Trigger the read callback only whenever there is at least 128 bytes</i>
<i>       of data in the buffer. */</i>
    bufferevent_setwatermark(b1, EV_READ, 128, 0);

    bufferevent_setcb(b1, read_callback, NULL, event_callback, info1);

    bufferevent_enable(b1, EV_READ); /* Start reading. */
    <strong>return</strong> b1;
}</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_manipulating_data_in_a_bufferevent">Manipulating data in a bufferevent</h3>
<div class="paragraph"><p>Reading and writing data from the network does you no good if you
can’t look at it.  Bufferevents give you these methods to give them
data to write, and to get the data to read:</p><p class="translate">如果你无法查看网络中的数据，那么读取和写入数据就没有任何好处。缓冲事件为你提供了以下方法，用来传输要写入的数据，并获取要读取的数据：</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>struct</strong> evbuffer *bufferevent_get_input(<strong>struct</strong> bufferevent *bufev);
<strong>struct</strong> evbuffer *bufferevent_get_output(<strong>struct</strong> bufferevent *bufev);</code></pre>
</div></div>
<div class="paragraph"><p>These two functions are very powerful fundamental: they return the
input and output buffers respectively.  For full information on all
the operations you can perform on an evbuffer type, see the next
chapter.</p><p class="translate">这两个函数非常强大且基础：它们分别返回输入和输出buffer。要了解可以在evbuffer类型上执行的所有操作的完整信息，请参阅下一章。</p></div>
<div class="paragraph"><p>Note that the application may only remove (not add) data from the input
buffer, and may only add (not remove) data to the output buffer.</p><p class="translate">请注意，应用程序只能从输入buffer删除（而不是添加）数据，且只能向输出buffer添加（而不是删除）数据。</p></div>
<div class="paragraph"><p>If writing on the bufferevent was stalled because of too little data
(or if reading was stalled because of too much), then adding data to
the output buffer (or removing data from the input buffer) will
automatically restart it.</p><p class="translate">如果因为数据太少（或因为数据太多）而导致缓冲事件的写入被阻塞，那么向输出buffer添加数据（或从输入buffer移除数据）将自动重启它。</p></div>
<div class="paragraph"><p>These functions were introduced in Libevent 2.0.1-alpha.</p><p class="translate">这些功能在Libevent 2.0.1-alpha中引入。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>int</strong> bufferevent_write(<strong>struct</strong> bufferevent *bufev,
    <strong>const</strong> <strong>void</strong> *data, size_t size);
<strong>int</strong> bufferevent_write_buffer(<strong>struct</strong> bufferevent *bufev,
    <strong>struct</strong> evbuffer *buf);</code></pre>
</div></div>
<div class="paragraph"><p>These functions add data to a bufferevent’s output buffer.  Calling
bufferevent_write() adds <em>size</em> bytes from the memory at <em>data</em> to the
end of the output buffer.  Calling bufferevent_write_buffer() removes
the entire contents of <em>buf</em> and puts them at the end of the output
buffer.   Both return 0 if successful, or -1 if an error occurred.</p><p class="translate">这些功能向bufferevent的输出缓冲区添加数据。调用bufferevent_write()会将数据内存中的size字节添加到输出buffer的末尾。调用bufferevent_write_buffer()会移除buf的全部内容，并将它们放在输出缓冲区的末尾。如果成功，两者都返回0，如果发生错误，则返回-1。</p></div>
<div class="paragraph"><p>These functions have existed since Libevent 0.8.</p><p class="translate">这些功能自Libevent 0.8以来就存在。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code>size_t bufferevent_read(<strong>struct</strong> bufferevent *bufev, <strong>void</strong> *data, size_t size);
<strong>int</strong> bufferevent_read_buffer(<strong>struct</strong> bufferevent *bufev,
    <strong>struct</strong> evbuffer *buf);</code></pre>
</div></div>
<div class="paragraph"><p>These functions remove data from a bufferevent’s input buffer.  The
bufferevent_read() function removes up to <em>size</em> bytes from the input
buffer, storing them into the memory at <em>data</em>.  It returns the number
of bytes actually removed.  The bufferevent_read_buffer() function
drains the entire contents of the input buffer and places them into
<em>buf</em>; it returns 0 on success and -1 on failure.</p><p class="translate">这些函数从bufferevent的输入buffer中移除数据。bufferevent_read()函数最多从输入buffer移除size字节，将它们存储到data中。它返回实际移除的字节数。bufferevent_read_buffer()函数排空输入buffer的全部内容，并将它们放入buf中；成功返回0，失败返回-1。</p></div>
<div class="paragraph"><p>Note that with bufferevent_read(), the memory chunk at <em>data</em> must
actually have enough space to hold <em>size</em> bytes of data.</p><p class="translate">请注意，使用bufferevent_read()时，data必须有足够的空间来存储size字节的数据。</p></div>
<div class="paragraph"><p>The bufferevent_read() function has existed since Libevent 0.8;
bufferevent_read_buffer() was introduced in Libevent 2.0.1-alpha.</p><p class="translate">bufferevent_read()函数自Libevent 0.8以来就存在；bufferevent_read_buffer()是在Libevent 2.0.1-alpha中引入的。</p></div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre><code>#include &lt;event2/bufferevent.h&gt;
#include &lt;event2/buffer.h&gt;

#include &lt;ctype.h&gt;

<strong>void</strong>
read_callback_uppercase(<strong>struct</strong> bufferevent *bev, <strong>void</strong> *ctx)
{
<i>        /* This callback removes the data from bev's input buffer 128</i>
<i>           bytes at a time, uppercases it, and starts sending it</i>
<i>           back.</i>

<i>           (Watch out!  In practice, you shouldn't use toupper to implement</i>
<i>           a network protocol, unless you know for a fact that the current</i>
<i>           locale is the one you want to be using.)</i>
<i>         */</i>

        <strong>char</strong> tmp[128];
        size_t n;
        <strong>int</strong> i;
        <strong>while</strong> (1) {
                n = bufferevent_read(bev, tmp, <strong>sizeof</strong>(tmp));
                <strong>if</strong> (n &lt;= 0)
                        <strong>break</strong>; /* No more data. */
                <strong>for</strong> (i=0; i&lt;n; ++i)
                        tmp[i] = toupper(tmp[i]);
                bufferevent_write(bev, tmp, n);
        }
}

<strong>struct</strong> proxy_info {
        <strong>struct</strong> bufferevent *other_bev;
};
<strong>void</strong>
read_callback_proxy(<strong>struct</strong> bufferevent *bev, <strong>void</strong> *ctx)
{
<i>        /* You might use a function like this if you're implementing</i>
<i>           a simple proxy: it will take data from one connection (on</i>
<i>           bev), and write it to another, copying as little as</i>
<i>           possible. */</i>
        <strong>struct</strong> proxy_info *inf = ctx;

        bufferevent_read_buffer(bev,
            bufferevent_get_output(inf-&gt;other_bev));
}

<strong>struct</strong> count {
        <strong>unsigned</strong> <strong>long</strong> last_fib[2];
};

<strong>void</strong>
write_callback_fibonacci(<strong>struct</strong> bufferevent *bev, <strong>void</strong> *ctx)
{
<i>        /* Here's a callback that adds some Fibonacci numbers to the</i>
<i>           output buffer of bev.  It stops once we have added 1k of</i>
<i>           data; once this data is drained, we'll add more. */</i>
        <strong>struct</strong> count *c = ctx;

        <strong>struct</strong> evbuffer *tmp = evbuffer_new();
        <strong>while</strong> (evbuffer_get_length(tmp) &lt; 1024) {
                 <strong>unsigned</strong> <strong>long</strong> next = c-&gt;last_fib[0] + c-&gt;last_fib[1];
                 c-&gt;last_fib[0] = c-&gt;last_fib[1];
                 c-&gt;last_fib[1] = next;

                 evbuffer_add_printf(tmp, "%lu", next);
        }

<i>        /* Now we add the whole contents of tmp to bev. */</i>
        bufferevent_write_buffer(bev, tmp);

<i>        /* We don't need tmp any longer. */</i>
        evbuffer_free(tmp);
}</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_read_and_write_timeouts">Read- and write timeouts</h3>
<div class="paragraph"><p>As with other events, you can have a timeout get invoked if a certain
amount of time passes without any data having been successfully
written or read by a bufferevent.</p><p class="translate">与其他event一样，如果bufferevent在一定时间内没有成功写入或读取任何数据，你可以设置一个超时来触发。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>void</strong> bufferevent_set_timeouts(<strong>struct</strong> bufferevent *bufev,
    <strong>const</strong> <strong>struct</strong> timeval *timeout_read, <strong>const</strong> <strong>struct</strong> timeval *timeout_write);</code></pre>
</div></div>
<div class="paragraph"><p>Setting a timeout to NULL is supposed to remove it; however before Libevent
2.1.2-alpha this wouldn’t work with all event types.  (As a workaround for
older versions, you can try setting the timeout to a multi-day interval
and/or having your eventcb function ignore BEV_TIMEOUT events when you don’t
want them.)</p><p class="translate">设置超时为NULL应该是为了移除它；然而，在Libevent 2.1.2-alpha之前，这并不适用于所有事件类型。（作为旧版本的一种解决方法，你可以尝试将超时设置为多日间隔和/或让你的eventcb函数忽略你不想要的BEV_TIMEOUT事件。）</p></div>
<div class="paragraph"><p>The read timeout will trigger if the bufferevent waits at least
<em>timeout_read</em> seconds while trying to read data.  The write
timeout will trigger if the bufferevent waits at least <em>timeout_write</em>
seconds while trying to write data.</p><p class="translate">如果bufferevent尝试读取数据时至少等待了timeout_read秒，则会触发读取超时。如果bufferevent尝试写入数据时至少等待了timeout_write秒，则会触发写入超时。</p></div>
<div class="paragraph"><p>Note that the timeouts only count when the bufferevent would like to
read or write.  In other words, the read timeout is not enabled if
reading is disabled on the bufferevent, or if the input buffer is full
(at its high-water mark).  Similarly, the write timeout is not enabled
if writing is disabled, or if there is no data to write.</p><p class="translate">注意，只有当bufferevent想要读取或写入时，超时才会计算。换句话说，如果在bufferevent上禁用了读取，或者输入buffer已满（达到其高水位线），则不启用读取超时。同样，如果禁用了写入，或者没有数据可以写入，则不启用写入超时。</p></div>
<div class="paragraph"><p>When a read or write timeout occurs, the corresponding read or write
operation becomes disabled on the bufferevent.  The event callback is then
invoked with either BEV_EVENT_TIMEOUT|BEV_EVENT_READING or
BEV_EVENT_TIMEOUT|BEV_EVENT_WRITING.</p><p class="translate">当发生读取或写入超时时，对应的读取或写入操作在bufferevent上被禁用。然后将调用回调函数，参数为BEV_EVENT_TIMEOUT|BEV_EVENT_READING或BEV_EVENT_TIMEOUT|BEV_EVENT_WRITING。</p></div>
<div class="paragraph"><p>This functions has existed since Libevent 2.0.1-alpha.  It didn’t behave
consistently across bufferevent types until Libevent 2.0.4-alpha.</p><p class="translate">该功能自Libevent 2.0.1-alpha以来就存在。直到Libevent 2.0.4-alpha，它才在不同的缓冲事件类型之间表现一致。</p></div>
</div>
<div class="sect2">
<h3 id="_initiating_a_flush_on_a_bufferevent">Initiating a flush on a bufferevent</h3>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>int</strong> bufferevent_flush(<strong>struct</strong> bufferevent *bufev,
    <strong>short</strong> iotype, <strong>enum</strong> bufferevent_flush_mode state);</code></pre>
</div></div>
<div class="paragraph"><p>Flushing a bufferevent tells the bufferevent to force as many bytes
as possible to be read to or written from the underlying transport,
ignoring other restrictions that might otherwise keep them from
being written.  Its detailed function depends on the type of the
bufferevent.</p><p class="translate">刷新bufferevent将强制尽可能多的字节被读取到或从底层传输中写入，忽略其他可能会阻止它们被写入的限制。其详细功能取决于缓冲事件的类型。</p></div>
<div class="paragraph"><p>The iotype argument should be EV_READ, EV_WRITE, or EV_READ|EV_WRITE to
indicate whether bytes being read, written, or both should be
processed.  The state argument may be one of BEV_NORMAL,
BEV_FLUSH, or BEV_FINISHED.  BEV_FINISHED indicates that the other
side should be told that no more data will be sent; the distinction
between BEV_NORMAL and BEV_FLUSH depends on the type of the
bufferevent.</p><p class="translate">iotype参数应该是EV_READ、EV_WRITE或EV_READ|EV_WRITE，以指示是要处理正在读取、正在写入还是同时进行的字节。state参数可以是BEV_NORMAL、BEV_FLUSH或BEV_FINISHED之一。BEV_FINISHED指的是应该告诉对方不会再发送更多的数据；BEV_NORMAL与BEV_FLUSH之间的区别取决于bufferevent的类型。</p></div>
<div class="paragraph"><p>The bufferevent_flush() function returns -1 on failure, 0 if no data
was flushed, or 1 if some data was flushed.</p><p class="translate">bufferevent_flush()函数在失败时返回-1，在没有数据被刷新时返回0，如果有一些数据被刷新，则返回1。</p></div>
<div class="paragraph"><p>Currently (as of Libevent 2.0.5-beta), bufferevent_flush() is only
implemented for some bufferevent types.  In particular, socket-based
bufferevents don’t have it.</p><p class="translate">目前（截至Libevent 2.0.5-beta），bufferevent_flush()只针对某些类型的bufferevent实现。特别是，基于socket的bufferevent没有这个功能。</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_type_specific_bufferevent_functions">Type-specific bufferevent functions</h2>
<div class="sectionbody">
<div class="paragraph"><p>These bufferevent functions are not supported on all bufferevent
types.</p><p class="translate">这些函数并不支持所有类型的 bufferevent。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>int</strong> bufferevent_priority_set(<strong>struct</strong> bufferevent *bufev, <strong>int</strong> pri);
<strong>int</strong> bufferevent_get_priority(<strong>struct</strong> bufferevent *bufev);</code></pre>
</div></div>
<div class="paragraph"><p>This function adjusts the priority of the events used to implement
<em>bufev</em> to <em>pri</em>.  See event_priority_set() for more information on
priorities.</p><p class="translate">这个函数调整 bufev 的优先级为 pri。关于优先级的更多信息，请参阅 event_priority_set()。</p></div>
<div class="paragraph"><p>This function returns 0 on success, and -1 on failure.  It works on
socket-based bufferevents only.</p><p class="translate">这个函数成功时返回 0，在失败时返回 -1。它仅适用于基于socket的 bufferevents。</p></div>
<div class="paragraph"><p>The bufferevent_priority_set() function was introduced in Libevent 1.0;
bufferevent_get_priority() didn’t appear until Libevent 2.1.2-alpha.</p><p class="translate">bufferevent_priority_set() 函数在 Libevent 1.0 中引入；bufferevent_get_priority() 直到 Libevent 2.1.2-alpha 才出现。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>int</strong> bufferevent_setfd(<strong>struct</strong> bufferevent *bufev, evutil_socket_t fd);
evutil_socket_t bufferevent_getfd(<strong>struct</strong> bufferevent *bufev);</code></pre>
</div></div>
<div class="paragraph"><p>These functions set or return the file descriptor for a fd-based
event.  Only socket-based bufferevents support setfd().  Both return
-1 on failure; setfd() returns 0 on success.</p><p class="translate">这些函数为基于 fd 的事件设置或返回fd。只有基于socket的 bufferevents 支持 setfd()。两者在失败时都返回 -1；setfd() 在成功时返回 0。</p></div>
<div class="paragraph"><p>The bufferevent_setfd() function was introduced in Libevent 1.4.4;
the bufferevent_getfd() function was introduced in Libevent 2.0.2-alpha.</p><p class="translate">bufferevent_setfd() 函数在 Libevent 1.4.4 中引入；bufferevent_getfd() 函数在 Libevent 2.0.2-alpha 中引入。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>struct</strong> event_base *bufferevent_get_base(<strong>struct</strong> bufferevent *bev);</code></pre>
</div></div>
<div class="paragraph"><p>This function returns the event_base of a bufferevent.  It was introduced in
2.0.9-rc.</p><p class="translate">此函数返回 bufferevent 的 event_base。它在 2.0.9-rc 中引入。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>struct</strong> bufferevent *bufferevent_get_underlying(<strong>struct</strong> bufferevent *bufev);</code></pre>
</div></div>
<div class="paragraph"><p>This function returns the bufferevent that another bufferevent is
using as a transport, if any.  For information on when this situation
would occur, see notes on filtering bufferevents.</p><p class="translate">此函数返回另一个 bufferevent 正在用作传输的 bufferevent（如果有的话）。关于何时会发生这种情况的信息，请参见"filtering bufferevent"的注释。</p></div>
<div class="paragraph"><p>This function was introduced in Libevent 2.0.2-alpha.</p><p class="translate">这个函数在 Libevent 2.0.2-alpha 中引入。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_manually_locking_and_unlocking_a_bufferevent">Manually locking and unlocking a bufferevent</h2>
<div class="sectionbody">
<div class="paragraph"><p>As with evbuffers, sometimes you want to ensure that a number of operations
on a bufferevent are all performed atomically.  Libevent exposes functions
that you can use to manually lock and unlock a bufferevent.</p><p class="translate">就像对 evbuffers 一样，有时您希望确保对 bufferevent 的一系列操作都能原子性地执行。Libevent 提供了一些函数，您可以使用它们来手动锁定和解锁  bufferevent。</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>void</strong> bufferevent_lock(<strong>struct</strong> bufferevent *bufev);
<strong>void</strong> bufferevent_unlock(<strong>struct</strong> bufferevent *bufev);</code></pre>
</div></div>
<div class="paragraph"><p>Note that locking a bufferevent has no effect if the bufferevent was not
given the BEV_OPT_THREADSAFE thread on creation, or if Libevent’s threading
support wasn’t activated.</p><p class="translate">请注意，如果创建 bufferevent 时没有给予 BEV_OPT_THREADSAFE，或者如果没有激活 Libevent 的线程支持，锁定 bufferevent 是没有效果的。</p></div>
<div class="paragraph"><p>Locking the bufferevent with this function will lock its associated evbuffers
as well.  These functions are recursive: it is safe to lock a bufferevent for
which you already hold the lock.  You must, of course, call unlock once for
every time that you locked the bufferevent.</p><p class="translate">使用这个函数锁定 bufferevent 也会锁定其关联的 evbuffers。这些函数是递归的：对于已经持有锁再次对bufferevent上锁是安全的。当然，您必须为每次锁定 bufferevent 调用一次解锁。</p></div>
<div class="paragraph"><p>These functions were introduced in Libevent 2.0.6-rc.</p><p class="translate">这些函数在 Libevent 2.0.6-rc 中引入。</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_obsolete_bufferevent_functionality">Obsolete bufferevent functionality</h2>
<div class="sectionbody">
<div class="paragraph"><p>The bufferevent backend code underwent substantial revision between
Libevent 1.4 and Libevent 2.0.  In the old interface, it was sometimes
normal to build with access to the internals of the struct
bufferevent, and to use macros that relied on this access.</p><p class="translate">在 Libevent 1.4 到 Libevent 2.0 之间，bufferevent 后端代码经过了实质性的修订。在旧接口中，有时会正常构建对 struct bufferevent 内部的访问，并使用依赖此访问的宏。</p></div>
<div class="paragraph"><p>To make matters confusing, the old code sometimes used names for
bufferevent functionality that were prefixed with "evbuffer".</p><p class="translate">为了使问题变得复杂，旧代码有时会使用以 "evbuffer" 为前缀的 bufferevent 功能的名称。</p></div>
<div class="paragraph"><p>Here’s a brief guideline of what things used to be called before
Libevent 2.0:</p><p class="translate">以下是 Libevent 2.0 之前的简要指南：</p></div>
<div class="tableblock">
<table rules="all" width="90%" frame="border" cellspacing="0" cellpadding="4">
<colgroup><col width="50%">
<col width="50%">
</colgroup><thead>
<tr>
<th align="left" valign="top"> Current name               </th>
<th align="left" valign="top"> Old name</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">bufferevent_data_cb</p></td>
<td align="left" valign="top"><p class="table">evbuffercb</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">bufferevent_event_cb</p></td>
<td align="left" valign="top"><p class="table">everrorcb</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">BEV_EVENT_READING</p></td>
<td align="left" valign="top"><p class="table">EVBUFFER_READ</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">BEV_EVENT_WRITE</p></td>
<td align="left" valign="top"><p class="table">EVBUFFER_WRITE</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">BEV_EVENT_EOF</p></td>
<td align="left" valign="top"><p class="table">EVBUFFER_EOF</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">BEV_EVENT_ERROR</p></td>
<td align="left" valign="top"><p class="table">EVBUFFER_ERROR</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">BEV_EVENT_TIMEOUT</p></td>
<td align="left" valign="top"><p class="table">EVBUFFER_TIMEOUT</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">bufferevent_get_input(b)</p></td>
<td align="left" valign="top"><p class="table">EVBUFFER_INPUT(b)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">bufferevent_get_output(b)</p></td>
<td align="left" valign="top"><p class="table">EVBUFFER_OUTPUT(b)</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>The old functions were defined in event.h, not in event2/bufferevent.h.</p><p class="translate">旧函数是在 event.h 中定义的，而不是在 event2/bufferevent.h 中。</p></div>
<div class="paragraph"><p>If you still need access to the internals of the common parts of the
bufferevent struct, you can include event2/bufferevent_struct.h.  We
recommend against it: the contents of struct bufferevent WILL change between
versions of Libevent.  The macros and names in this section are available if
you include event2/bufferevent_compat.h.</p><p class="translate">如果您仍然需要访问 bufferevent struct 的公共部分的内部，您可以包含 event2/bufferevent_struct.h。我们不推荐这样做：struct bufferevent 的内容将在 Libevent 的不同版本之间改变。如果您包含了 event2/bufferevent_compat.h，本节中的宏和名称将可用。</p></div>
<div class="paragraph"><p>The interface to set up a bufferevent differed in older versions:</p><p class="translate">设置 bufferevent 在旧版本中有所不同：</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>struct</strong> bufferevent *bufferevent_new(evutil_socket_t fd,
    evbuffercb readcb, evbuffercb writecb, everrorcb errorcb, <strong>void</strong> *cbarg);
<strong>int</strong> bufferevent_base_set(<strong>struct</strong> event_base *base, <strong>struct</strong> bufferevent *bufev);</code></pre>
</div></div>
<div class="paragraph"><p>The bufferevent_new() function creates a socket bufferevent only, and does so
on the deprecated "default" event_base.  Calling bufferevent_base_set adjusts
the event_base of a socket bufferevent only.</p><p class="translate">bufferevent_new() 函数仅创建一个基于socket的 bufferevent，并且是基于不赞成使用的 event_base。调用 bufferevent_base_set 仅调整bufferevent 的 event_base。</p></div>
<div class="paragraph"><p>Instead of setting timeouts as struct timeval, they were set as
numbers of seconds:</p><p class="translate">超时设置为秒数而不是struct timeval：</p></div>
<div class="listingblock">
<div class="title">Interface</div>
<div class="content">
<pre><code><strong>void</strong> bufferevent_settimeout(<strong>struct</strong> bufferevent *bufev,
    <strong>int</strong> timeout_read, <strong>int</strong> timeout_write);</code></pre>
</div></div>
<div class="paragraph"><p>Finally, note that the underlying evbuffer implementation for Libevent
versions before 2.0 was pretty inefficient, to the point where using
bufferevents for high-performance apps was kind of questionable.</p><p class="translate">最后，请注意，Libevent 2.0 之前版本的底层 evbuffer 实现效率非常低下，以至于对于高性能应用程序使用 bufferevents 有点令人质疑。</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr></div>
<div id="footer">
<div id="footer-text">
Last updated
 2024-02-18 20:10:44 UTC
</div>
</div>


</body></html>