// 这个文件的作用是翻译 public/libevent的

const fs = require('fs')
const cheerio = require('cheerio')

function doTranslate (filename, translations) {
  fs.readFile(filename, 'utf8', (err, html) => {
    if (err) {
      console.error(err)
      return
    }

    const $ = cheerio.load(html)

    // 先删除所有class为translate的元素
    $('.translate').remove()

    translations.forEach(item => {
      // 使用contains选择器查找包含特定文本的段落
      const paragraph = $(`p:contains('${item.EN}')`)
      // 删除旧的翻译（如果存在）
      paragraph.next('.translate').remove()
      // 添加新的翻译
      paragraph.after(`<p class="translate">${item.CN}</p>`)
    })

    // 更新translate样式
    let styleTag = $('head style#translation-style')
    if (styleTag.length) {
      styleTag.remove()
    }
    $('head').append('<style id="translation-style"></style>')
    styleTag = $('head style#translation-style')
    styleTag.text(`
      .translate {
        background-color: #f0f0f0; /* 浅灰色背景 */
        color: black;             /* 黑色文本 */
        font-weight: bold;        /* 加粗字体 */
      }
    `)

    const updatedHtml = $.html()

    // 写入新的HTML文件
    fs.writeFile(filename, updatedHtml, 'utf8', (err) => {
      if (err) {
        console.error(filename, '写入失败！！！')
      } else {
        console.log(filename, '翻译完成')
      }
    })
  })
}


doTranslate(
  './public/Libevent_C0_About_this_document.html',
  [
    { EN: "This document will teach you how to use", CN: '这份文档将教你如何使用Libevent 2.0（及以后版本）来用C语言编写快速、可移植的非阻塞网络IO程序。我们假设：<br>1.你已经了解C语言。<br>2.你已经熟悉基本的C网络调用（socket()、connect()等）。' },
    { EN: "The examples in this document should work all right", CN: '本文档中的示例在Linux、FreeBSD、OpenBSD、NetBSD、Mac OS X、Solaris和Android上应该能够正常运行。部分示例可能无法在Windows上编译。' },
  ]
)


doTranslate(
  './public/Libevent_C1_A_tiny_introduction_to_synchronous_non-blocking_IO.html',
  [
    { EN: "Most beginning programmers start with blocking IO calls", CN: '大多数初学者都是从阻塞IO调用开始的。一个IO调用是同步的，如果在你调用它时，它不会返回直到操作完成，或者直到过了足够的时间你的网络栈放弃为止。例如，当你在一个TCP链接上调用“connect()”时，你的操作系统会向TCP链接另一端的主机排队一个SYN包。它不会将控制权返回给你的应用程序，直到它从对面的主机收到一个SYN ACK包，或者直到过了足够的时间，它决定放弃为止。' },
    { EN: "an example of a really simple client using blocking network", CN: '这里有一个使用阻塞网络调用的非常简单的客户端示例。它打开一个到www.google.com的链接，向其发送一个简单的HTTP请求，并将响应打印到标准输出。' },
    { EN: "All of the network calls in the code above are", CN: '上面代码中的所有网络调用都是阻塞的：gethostbyname在成功(或失败)解析www.google.com之前不会返回；connect在链接上之前不会返回；recv调用在接收到数据或关闭之前不会返回；send调用在将数据刷新到内核的写缓冲区之前不会返回。' },
    { EN: "Now, blocking IO is not necessarily evil", CN: '并不是说阻塞IO就一定是坏事。如果你的程序暂时没有其他事情要做，阻塞IO对你来说会工作得很好。但假设你需要编写一个程序来同时处理多个链接。为了使我们的例子更具体：假设你想从两个链接中读取输入，而你不知道哪个链接会首先获得输入。你不能像下面这样：' },
    { EN: "because if data arrives on fd[2] first", CN: '因为如果fd[2]的数据首先到达，你的程序甚至不会尝试从fd[2]读取，直到从fd[0]和fd[1]读取到一些数据并完成为止。' },
    { EN: "Sometimes people solve this problem with multithreading", CN: '有时人们解决这个问题是通过多线程，或者多进程服务器。进行多线程的最简单方法之一是使用一个单独的进程（或线程）来处理每个链接。由于每个链接都有自己的进程，所以在等待一个链接时的阻塞IO调用不会使其他链接的进程阻塞。' },
    { EN: "another example program", CN: '这是另一个示例程序。这是一个简单的服务器，它在端口40713上监听TCP链接，一次从输入中读取一行数据，然后写出每行数据的ROT13加密版本。它使用Unix的fork()为每个新链接创建一个新线程。' },
    { EN: "So, do we have the perfect solution for handling multiple connections", CN: '那么，我们是否已经找到了一种完美的解决方案处理多连接？我现在可以停止写这本书，去做其他事情了吗？并不完全是。首先，进程创建（甚至线程创建）在某些平台上可能相当耗资源。在现实生活中，你会想使用线程池。但是更根本的是，线程的数量不如你想象的那样。如果你的程序需要同时处理数千个或数万个连接，处理数万个线程的效率不会像仅在每个CPU上只有几个线程那样高效。' },
    { EN: "But if threading isn", CN: '但是，如果线程不是处理多链接的答案，那么什么是呢？在Unix范例中，你会使你的socket变为非阻塞。Unix下的调用是：' },
    { EN: "where fd is the file descriptor for the socket", CN: '其中fd是socket的文件描述符。[1] 一旦你将fd（socket）设置为非阻塞，每当你对fd进行网络调用时，调用要么立即完成操作，要么返回一个特殊的错误码以指示“我现在无法取得任何进展，请再试一次。”所以我们的两个socket示例可能写成：' },
    { EN: "Now that we", CN: '现在我们开始使用非阻塞套接字，上面的代码会工作……但仅仅是勉强可行。性能会非常糟糕，原因有二。首先，如果两个链接都没有数据可读，循环将无限运行，耗尽你所有的CPU周期。其次，如果你尝试用这种方法处理超过一两个连接，你会发现不管是否有数据，每个连接都会执行一个内核调用。所以我们需要的是一种方法，告诉内核“等待，直到这些socket中的一个准备好给我一些数据，并告诉我是哪个准备好了。”' },
    { EN: "The oldest solution that people still use for this problem is", CN: '人们仍然使用的解决这个问题的最古老方法是select()。select()调用接收三组fds（实现为位数组）：一组用于读取，一组用于写入，一组用于“异常”。它等待直到来自其中一组的socket准备就绪，并更改集合以只包含准备使用的socket。' },
    { EN: "still not done", CN: '但我们还没有完成。因为生成和读取select()位数组所需的时间与你为select()提供的最大fd成正比，当socket数量很高时，select()调用的扩展性非常糟糕。' },
    { EN: "Different operating systems", CN: '不同的操作系统提供了select的不同替代函数。这些包括poll()、epoll()、kqueue()、evports和/dev/poll。所有这些都比select()提供了更好的性能，在移除socket或socket的读写方面。(除了poll()在添加socket时的性能是O(1))。' },
    { EN: "none of the efficient interfaces is a ubiquitous", CN: '不幸的是，这些都不是普遍标准。Linux有epoll()，BSDs（包括Darwin）有kqueue()，Solaris有evports和/dev/poll……这些操作系统都没有其他的。因此，如果你想要编写一个可移植的高性能异步应用程序，你将需要一个抽象层，它包装了所有这些接口，并提供了最高效的一个。' },
    { EN: "what the lowest level of the Libevent", CN: '这正是Libevent API最底层为你所做的。它为各种select()替代品提供了一个一致的接口，使用在其运行的计算机上可用的最高效版本。' },
    { EN: "another version of our non-blocking ROT13 server", CN: '这是我们非阻塞ROT13的又一个版本。这次，它使用的是Libevent 2而不是select()。请注意，fd_sets现在已经消失了：相反，我们使用struct event_base关联和解除事件，它可能在select()、poll()、epoll()、kqueue()等方面得到了实现。' },
    { EN: "Other things to note in the code", CN: '（代码中的其他需要注意的事项：我们没有将socket类型定义为"int"，而是使用了类型evutil_socket_t。我们没有调用fcntl(O_NONBLOCK)来使socket非阻塞，而是调用了evutil_make_socket_nonblocking。这些更改使我们的代码与Win32网络API不同的部分做到了兼容。）' },
    { EN: "probably noticed that as our code has gotten more efficient", CN: '你可能已经注意到了，随着我们的代码变得更高效，它也变得更复杂。回到我们使用fork时，我们不需要为每个链接管理一个缓冲区：我们为每个进程分配了一个栈缓冲区。我们不需要明确地跟踪每个socket是在读还是写：这在我们的代码位置中是隐含的。我们也不需要一个结构来跟踪每个操作完成了多少：我们只是使用循环和栈变量。' },
    { EN: "Moreover", CN: '此外，如果你对Windows上的网络编程有深入的了解，你会意识到当Libevent像上面的例子那样使用时，可能无法获得最佳性能。在Windows上，进行非阻塞IO的方式不是使用类似select()的接口：而是使用IOCP（输入输出完成端口）API。与所有快速网络API不同，IOCP不会在socket准备好进行操作时通知你的程序，然后你的程序必须执行该操作。相反，程序告诉Windows网络栈开始一个网络操作，而IOCP会告诉程序该操作何时完成。' },
    { EN: "Fortunately, the Libevent 2 \"bufferevents\" interface solves both of", CN: '幸运的是，Libevent 2的"bufferevents"接口解决了这两个问题：它使程序编写得更简单，并提供了一个接口，Libevent可以在Windows和Unix上高效实现。' },
    { EN: "ROT13 server one last time", CN: '这是我们ROT13服务器的最后一次演示，使用bufferevents API。' },
  ]
)


doTranslate(
  './public/Libevent_R0_The_Libevent_Reference_Manual_Preliminaries.html',
  [
    { EN: "", CN: 'Libevent是一个用于编写快速、可移植的非阻塞IO的库。其设计目标包括：<br>Portability<br>  使用Libevent编写的程序应该在Libevent支持的所有平台上运行。即使没有真正好的方法进行非阻塞IO，Libevent也应该支持一般的方法，以便您的程序可以在受限制的环境中运行。<br>Speed<br>  Libevent尽量在每个平台上使用最快的可用非阻塞IO实现，并且在这样做时不引入太多开销。<br>Scalability<br>  Libevent设计成即使是需要拥有数万个活跃套接字的程序也能良好运行。<br>Convenience<br>  在可能的情况下，使用Libevent编写程序的最自然方式应该是稳定、可移植的方式。' },
    { EN: "", CN: 'Libevent分为以下几个组件：<br>evutil<br>  用于抽象不同平台间网络实现差异的通用功能。<br>event and event_base<br>  这是Libevent的核心。它提供了对各种平台特定、基于事件的非阻塞IO后端的抽象API。它可以让您知道套接字何时准备好读取或写入，执行基本的超时功能，并检测操作系统信号。<br>bufferevent<br>  这些函数提供了对Libevent基于事件的核心的更方便的封装。它们允许您的应用程序请求缓冲读取和写入，而不是在套接字准备好时通知您，而是在IO实际发生时通知您。<br>  bufferevent接口还具有多个后端，因此可以利用提供更快的非阻塞IO方式的系统，例如Windows IOCP API。<br>evbuffer<br>  该模块实现了bufferevents的底层缓冲区，并提供了用于高效和/或方便访问的函数。<br>evhttp<br>  一个简单的HTTP客户端/服务器实现。<br>evdns<br>  一个简单的DNS客户端/服务器实现。<br>evrpc<br>  一个简单的RPC实现。' },
    { EN: "", CN: '当构建Libevent时，默认情况下会安装以下库：<br>libevent_core<br>  所有核心事件和缓冲功能。该库包含所有的event_base、evbuffer、bufferevent和实用函数。<br>libevent_extra<br>  该库定义了特定协议的功能，这些功能可能与您的应用程序有关或无关，包括HTTP、DNS和RPC。<br>libevent<br>  由于历史原因存在这个库；它包含了libevent_core和libevent_extra的内容。您不应该使用它；在未来的Libevent版本中可能会被移除。' },
    { EN: "", CN: '以下库仅在某些平台上安装：<br>libevent_pthreads<br>  该库基于可移植的pthread线程库添加了线程和锁定实现。它与libevent_core分开，这样您就不需要链接pthread来使用Libevent，除非您实际上是以多线程方式使用Libevent。<br>libevent_openssl<br>  该库提供了使用bufferevents和OpenSSL库进行加密通信的支持。它与libevent_core分开，这样您就不需要链接OpenSSL来使用Libevent，除非您实际上是在使用加密连接。' },
    { EN: "", CN: '所有当前的公共Libevent头文件都安装在event2目录下。头文件可以分为三个广义的类别：<br>API headers<br>  API头文件定义了对Libevent的当前公共接口。这些头文件没有特殊的后缀。<br>Compatibility headers<br>  兼容性头文件包含了被弃用的函数的定义。除非你正在将程序从较旧的Libevent版本移植过来，否则不应该包含这些头文件。<br>Structure headers<br>  这些头文件定义了具有相对不稳定布局的结构。其中一些是为了在需要快速访问结构组件时提供的；一些则是出于历史原因而公开的。直接依赖头文件中的任何结构可能会破坏您的程序与其他版本的Libevent的二进制兼容性，有时很难调试。这些头文件的后缀是"_struct.h"。<br>  （还有一些没有event2目录的Libevent旧版本头文件。请参阅下面的"如果你必须使用旧版本的Libevent"。）' },
    { EN: "", CN: 'Libevent 2.0已经修订了其API，以更加合理和减少错误。如果可能的话，您应该编写新程序来使用Libevent 2.0的API。但是有时您可能需要使用较旧的API，无论是为了更新现有应用程序，还是为了支持某些原因无法安装Libevent 2.0或更高版本的环境。' },
    { EN: "", CN: '旧版本的Libevent拥有较少的头文件，并且没有将它们安装在"event2"目录下：' },
    { EN: "", CN: '在Libevent 2.0及更高版本中，旧的头文件仍然存在，作为新头文件的包装器。' },
    { EN: "", CN: '关于使用旧版本的其他注意事项：<br>  在1.4版本之前，只有一个名为"libevent"的库，其中包含目前分为libevent_core和libevent_extra的功能。<br>  在2.0版本之前，不支持锁定；Libevent可以是线程安全的，但前提是确保不同时从两个线程中使用相同的结构。' },
    { EN: "", CN: '下面的各个部分将讨论您可能在代码库的特定区域中遇到的已废弃的API。' },
    { EN: "", CN: '在1.4.7之前的Libevent版本应被视为完全过时。在1.3e之前的Libevent版本应被视为充满了严重错误。' },
    { EN: "", CN: '（此外，请不要为1.4.x或更早的版本向Libevent维护人员发送任何新功能---它应该保持作为一个稳定版本。如果您在1.3x或更早的版本中遇到了错误，请确保在报告之前确认它是否仍存在于最新的稳定版本中：后续的发布是有原因的。）' },
  ]
)


doTranslate(
  './public/Libevent_R1_Setting_up_the_Libevent_library.html',
  [
    { EN: "", CN: 'Libevent有少量全局设置，这些设置在整个进程中是共享的。它们会影响整个库。' },
    { EN: "", CN: '在调用Libevent库之前，您必须对这些设置进行更改。如果你不这样做，Libevent可能结束时会处于不一致的状态。' },
    { EN: "", CN: 'Libevent可以记录内部错误和警告。如果它是在编译时包含了日志支持，它还会记录debug信息。默认情况下，这些消息会被写入到stderr。你可以通过提供你自己的日志函数来覆盖这种行为。' },
    { EN: "", CN: '要覆盖Libevent的日志记录行为，编写一个符合event_log_cb签名的函数，并将其作为参数传递给event_set_log_callback。每当Libevent想要记录一条消息时，它将调用你提供的函数。你可以通过再次调用event_set_log_callback并将NULL作为参数传递，让Libevent返回到其默认行为。' },
    { EN: "", CN: '在用户提供的event_log_cb()回调函数中调用Libevent函数是不安全的！例如，如果你尝试编写一个日志回调，使用bufferevents将警告消息发送到网络套接字，你很可能遇到奇怪且难以诊断的错误。在未来版本的Libevent中，对于某些函数可能会移除这一限制。' },
    { EN: "", CN: '通常，debug日志不启用，并且不会发送到日志回调。当编译Libevent时，你可以手动开启它们。' },
    { EN: "", CN: '调试日志非常详细，并且在大多数情况下可能并不有用。使用EVENT_DBG_NONE作为参数调用event_enable_debug_logging()会得到默认行为；使用EVENT_DBG_ALL作为参数调用它会打开所有支持的调试日志。未来版本可能会支持更细粒度的选项。' },
    { EN: "", CN: '这些函数在<event2/event.h>中声明。它们最早出现在Libevent 1.0c中，除了event_enable_debug_logging()，最早出现在Libevent 2.1.1-alpha中。' },
    { EN: "", CN: '在Libevent 2.0.19-stable之前，EVENT_LOG_*宏的名称以下划线开头：_EVENT_LOG_DEBUG、_EVENT_LOG_MSG、_EVENT_LOG_WARN和_EVENT_LOG_ERR。这些较旧的名称已被弃用，仅应用于与Libevent 2.0.18-stable及更早版本的向后兼容。它们可能会在未来版本的Libevent中被移除。' },
    { EN: "", CN: '当Libevent检测到不可恢复的内部错误（如数据结构损坏）时，其默认行为是调用`exit()`或`abort()`来终止当前正在运行的进程。这些错误几乎总是意味着某处存在错误：要么是在你的代码中，要么是在Libevent本身中。' },
    { EN: "", CN: '如果你希望你的应用程序能够更优雅地处理致命错误，你可以给Libevent提供回调而不是退出。' },
    { EN: "", CN: '你首先需要定义一个新的函数，将其传递给`event_set_fatal_callback()`。之后，如果Libevent遇到致命错误，它将调用你提供的函数。' },
    { EN: "", CN: '你的函数不应该将控制权返回给Libevent；这样做可能会导致未定义的行为，并且Libevent可能仍会选择退出以避免崩溃。一旦你的函数被调用，你就不应该调用任何其他Libevent函数。' },
    { EN: "", CN: '这些函数在`<event2/event.h>中声明，最早出现在Libevent 2.0.3-alpha中。' },
    { EN: "", CN: '默认情况下，Libevent使用C函数从堆上分配内存。你可以让Libevent使用你提供的malloc、realloc和free的替代函数。如果你有一个更高效的分配器希望Libevent使用，或者如果你有一个带有检测工具的分配器，希望Libevent使用它来寻找内存泄漏，你可能会想这样做。' },
    { EN: "", CN: '这里有一个简单的例子，它用来替换Libevent的分配函数，这些函数能够计算分配的总字节数。实际上，如果Libevent在多线程中运行，你可能还会希望增加锁定机制来防止错误。' },
    { EN: "", CN: '注意事项<br>1.替换内存管理函数会影响所有未来的Libevent内存分配、调整大小或释放操作。因此，你需要确保在调用任何Libevent函数之前调用这些函数。否则，Libevent将使用你版本的free函数来释放从C库的malloc版本返回的内存。<br>2.你的malloc和realloc函数需要返回与C库相同对齐的内存块。<br>3.你的realloc函数需要正确处理realloc(NULL, sz)（即，把它当作malloc(sz)来处理）。<br>4.你的realloc函数需要正确处理realloc(ptr, 0)（即，把它当作free(ptr)来处理）。<br>5.你的free函数不需要处理free(NULL)。<br>6.你的malloc函数不需要处理malloc(0)。<br>7.如果你在多个线程中使用Libevent，替换后的内存管理函数需要是线程安全的。<br>8.Libevent将使用这些函数来分配它返回给你的内存。因此，如果你想要释放由Libevent函数分配并返回的内存，并且你已经替换了malloc和realloc函数，那么你可能必须使用你的替换free函数来释放它。' },
    { EN: "", CN: 'event_set_mem_functions()函数在<event2/event.h>中声明,最初出现在Libevent 2.0.1-alpha中。' },
    { EN: "", CN: 'Libevent可以构建时禁用event_set_mem_functions()。如果是这样的话，使用event_set_mem_functions的程序将无法编译或链接。在Libevent 2.0.2-alpha及更高版本中，你可以通过检查EVENT_SET_MEM_FUNCTIONS_IMPLEMENTED宏是否已定义来检测event_set_mem_functions()是否存在。' },
    { EN: "", CN: '如果你正在编写多线程程序，你可能知道，从多个线程同时访问同一数据并不总是安全的。' },
    { EN: "", CN: 'Libevent结构在多线程中通常有三种工作方式。<br>1.一些结构本质上是单线程的：从多个线程同时使用它们永远不是安全的。<br>2.一些结构是可锁的：你可以告诉Libevent，对于每个对象，你是否需要同时从多个线程中使用它。<br>3.一些结构总是被锁定的：如果Libevent在支持锁定的情况下运行，那么它们总是可以安全地同时从多个线程中使用。' },
    { EN: "", CN: '要在Libevent中获得锁定，你必须告知Libevent要使用的锁定函数。你需要在调用使用了共享内存的libevent函数前做这件事。' },
    { EN: "", CN: '如果你正在使用pthreads库，或者是原生Windows线程代码，那么你很幸运。有预定义的函数能够设置Libevent，让其为你正确地使用pthreads或Windows函数。' },
    { EN: "", CN: '这两个函数在成功时返回0，在失败时返回-1。' },
    { EN: "", CN: '如果你需要使用不同的线程库，那么你要额外做些工作。你需要函数实现以下功能：' },
    { EN: "", CN: '然后你使用evthread_set_lock_callbacks和evthread_set_id_callback接口告诉Libevent这些函数。' },
    { EN: "", CN: 'evthread_lock_callbacks结构描述了你的锁回调函数及其能力。对于上文的描述，lock_api_version字段必须设置为EVTHREAD_LOCK_API_VERSION。 supported_locktypes字段必须设置为EVTHREAD_LOCKTYPE_*的位掩码，以描述你可以支持哪些类型的锁。（截至2.0.4-alpha版本，EVTHREAD_LOCK_RECURSIVE是强制性的，而EVTHREAD_LOCK_READWRITE未使用。）alloc函数必须返回指定类型的新锁。free函数必须释放由指定类型的锁持有的所有资源。lock函数必须尝试以指定模式获取锁，成功时返回0，失败时返回非零值。unlock函数必须尝试解锁，成功时返回0，失败时返回非零值。' },
    { EN: "", CN: '被识别的锁类型包括：<br>0<br>常规的，不必是递归锁。<br>EVTHREAD_LOCKTYPE_RECURSIVE<br>对于已经持有该锁的线程，不会阻止它再次请求该锁。（同递归锁）<br>EVTHREAD_LOCKTYPE_READWRITE<br>允许多个线程同时为了读取持有它的锁，但一次只允许一个线程为了写入而持有它。写操作会排除所有读操作。<br>被识别的锁模式包括：<br>EVTHREAD_READ<br>仅限于READWRITE锁：为了读取而获取或释放锁。<br>EVTHREAD_WRITE<br>仅限于READWRITE锁：为了写入而获取或释放锁。<br>EVTHREAD_TRY<br>仅限于锁定：仅在锁可以立即获取时才获取锁。' },
    { EN: "", CN: 'id_fn函数必须返回unsigned long，用于识别哪个线程正在调用该函数。相同的线程总是返回相同的数字，并且如果两个线程同时执行，则决不能为两个不同的线程返回相同的数字。' },
    { EN: "", CN: 'evthread_condition_callbacks结构描述了与条件变量相关的回调函数。对于上文描述，condition_api_version字段必须设置为EVTHREAD_CONDITION_API_VERSION。alloc_condition函数必须返回一个指针指向新条件变量。它接收0作为参数。free_condition函数必须释放由条件变量持有的存储和资源。wait_condition函数接受三个参数：由alloc_condition分配的条件、由你提供的evthread_lock_callbacks.alloc函数分配的锁，以及一个可选的超时时间。每当调用该函数时，锁将被持有；该函数必须释放锁，并等待直到条件变量发出信号或者（可选的）超时时间已过。wait_condition函数在错误时应返回-1，在条件发出信号时返回0，在超时时返回1。在返回之前，它应确保再次持有锁。最后，signal_condition函数应使得等待条件的一个线程醒来（如果它的broadcast参数为假）并使得所有当前等待条件的线程醒来（如果它的broadcast参数为真）。只有在持有与条件相关联的锁时才能持有。' },
    { EN: "", CN: '要获取更多有关条件变量的信息，请查看pthreads的pthread_cond_*函数或Windows的CONDITION_VARIABLE函数的文档。' },
    { EN: "", CN: '本节中的函数在 <event2/thread.h> 中声明。它们中的大多数首次出现于Libevent 2.0.4-alpha版本。Libevent从2.0.1-alpha到2.0.3-alpha版本使用的是旧的接口来设置锁定函数。event_use_pthreads()函数要求您在编译程序时链接event_pthreads库。' },
    { EN: "", CN: '条件变量函数是在Libevent 2.0.7-rc中新增的；它们被添加进来是为了解决一些其他方式难以克服的死锁问题。' },
    { EN: "", CN: 'Libevent可以构建时禁用锁支持。如果这样做了，那么上述线程相关函数将无法运行。' },
    { EN: "", CN: '为了帮助调试锁的使用情况，Libevent有一个可选的“锁调试”功能，它封装了它的锁调用以捕获典型的锁错误，包括：<br>- 解锁一个实际上我们并未持有的锁<br>- 重新锁定一个非递归锁<br>如果出现这些锁错误之一，Libevent将会因断言失败而退出。' },
    { EN: "", CN: '这个函数必须在创建或调用锁前调用。为了安全起见，在你设置线程函数之后马上调用它。' },
    { EN: "", CN: '这个函数引入于Libevent 2.0.4-alpha，最初拼写错误为 evthread_enable_lock_debuging()。在2.1.2-alpha版本中修正为正确的拼写 evthread_enable_lock_debugging()；目前两个名称都得到支持。' },
    { EN: "", CN: '在使用事件时存在一些常见错误，Libevent可以为您检测并报告这些错误。它们包括：<br>- 将一个未初始化的 struct event 当作已经初始化的来处理。<br>- 尝试重新初始化一个正在等待的 struct event。' },
    { EN: "", CN: '追踪哪些事件已经初始化需要Libevent使用额外的内存和CPU，因此您应当只在调试程序时才启用调试模式。' },
    { EN: "", CN: '这个函数必须在创建任何 event_base 之前调用。' },
    { EN: "", CN: '在使用调试模式时，如果你的程序使用了大量通过 event_assign() 创建的event（而不是 event_new()），你可能会耗尽内存。这是因为 Libevent 无法知道何时不再使用通过 event_assign() 创建的event。（当你对 event_new() 创建的event调用 event_free() 时，它能知道该事件已经无效了。）如果你想在调试时避免内存耗尽，你可以明确告诉 Libevent 这些事件不再被当作已分配处理：' },
    { EN: "", CN: '当未启用调试时，调用 event_debug_unassign() 不会有任何效果。' },
    { EN: "", CN: '详细的event调试是一个特性，它只能在编译时通过使用 CFLAGS 环境变量“-DUSE_DEBUG”来启用。启用此标志后，任何针对 Libevent 编译的程序都会输出一个非常详细的日志，详细记录后端的low-level活动。这些日志包括但不限于以下内容：<br>- 事件添加<br>- 事件删除<br>- 平台特定的事件通知信息' },
    { EN: "", CN: '这个特性不能通过 API 调用来启用或禁用，因此它只能在开发者构建中使用。' },
    { EN: "", CN: '这些调试函数引入于 Libevent 2.0.4-alpha。' },
    { EN: "", CN: 'Libevent 的新版本增加功能和修复错误。有时候你会想要检测 Libevent 的版本，这样你可以：<br>- 检测安装的 Libevent 版本是否足够好，以构建你的程序。<br>- 显示 Libevent 版本以便调试。<br>- 检测 Libevent 的版本，以便你可以警告用户关于错误，或者绕过它们。' },
    { EN: "", CN: '宏提供了 Libevent 库的编译时版本；函数返回运行时版本。请注意，如果你的程序是与 Libevent 动态链接的，这些版本可能会有所不同。' },
    { EN: "", CN: '你可以以两种格式获取 Libevent 的版本：一种是适合向用户显示的字符串，另一种是适合进行数值比较的4字节整数。整数格式使用高字节表示主版本号，第二个字节表示次版本号，第三个字节表示修补版本号，低字节表示发布状态（0 表示正式发布，非零表示在给定发布版本之后的开发系列）。' },
    { EN: "", CN: '因此，发布的 Libevent 2.0.1-alpha 的版本号为 [02 00 01 00]，或 0x02000100。在 2.0.1-alpha 和 2.0.2-alpha 之间的开发版本可能有一个版本号为 [02 00 01 08]，或 0x02000108。' },
    { EN: "", CN: '本节中的宏和函数定义在 <event2/event.h> 中。`event_get_version()` 函数最初出现在 Libevent 1.0c 中；其他的则首次出现在 Libevent 2.0.1-alpha 中。' },
    { EN: "", CN: '即使你已经释放了所有使用 Libevent 分配的对象，仍然会有一些全局分配的结构剩余。这通常不是问题：一旦进程退出，这些结构最终都会被清理掉。但是这些结构可能会让一些调试工具误以为 Libevent 正在泄漏资源。如果你需要确保 Libevent 已经释放了所有全局数据，你可以调用：' },
    { EN: "", CN: '这个函数不会释放任何由 Libevent 函数返回给你的结构。如果你想在退出前释放所有内容，你需要自己释放所有事件、event_bases、bufferevents 等。' },
    { EN: "", CN: '调用 libevent_global_shutdown() 将使其他 Libevent 函数的行为变得不可预测；除非作为程序调用的最后一个 Libevent 函数，否则不要调用它。一个例外是 libevent_global_shutdown() 是幂等的：即使它已经被调用过，再次调用它也是可以的。' },
    { EN: "", CN: '这个函数在 <event2/event.h> 中声明。它在 Libevent 2.1.1-alpha 中引入。' },
  ]
)


doTranslate(
  './public/Libevent_R2_Creating_an_event_base.html',
  [
    { EN: "", CN: '在你能使用任何 Libevent 函数之前，你需要分配一个或多个 event_base 结构体。每个 event_base 结构体中包含了一组event，并且可以轮询来确定哪些事件是活跃的。' },
    { EN: "", CN: '如果一个 event_base 被设置为使用锁，在多个线程间访问它是安全的。然而，它的循环只能在单个线程中运行。如果你想要在多个线程中轮询 I/O，你需要为每个线程都分配一个 event_base。' },
    { EN: "", CN: 'Tip 【未来版本的 Libevent 可能会支持在多线程中运行 event_bases。】' },
    { EN: "", CN: '每个 event_base 都有一个“方法”，或者说是一个它用来确定哪些事件已准备就绪的后端。已识别的方法有：' },
    { EN: "", CN: '用户可以通过环境变量来禁用特定的后端。如果你想关闭 kqueue，设置 EVENT_NOKQUEUE 环境变量，等等。如果你想从程序内部关闭后端，请参阅下面关于 event_config_avoid_method() 的说明。' },
    { EN: "", CN: 'event_base_new() 函数使用默认设置分配并返回一个新的 event_base。它会检查环境变量并返回一个指向新 event_base 的指针。如果有错误发生，它会返回 NULL。' },
    { EN: "", CN: '在选择方法时，它会挑选操作系统支持的最快方法。' },
    { EN: "", CN: '对于大多数程序来说，这就是你所需要的。' },
    { EN: "", CN: 'event_base_new() 函数在 <event2/event.h> 中声明。它最初出现在 Libevent 1.4.3 版本中。' },
    { EN: "", CN: '如果你想对event_base 有更多控制权，你需要使用 event_config。event_config 是一个不透明结构，它保存了关于你对 event_base 的设置。当你需要一个 event_base 时，你可以将 event_config 传递给 event_base_new_with_config() 函数。' },
    { EN: "", CN: '要使用这些函数分配一个 event_base，你需要调用 event_config_new() 来分配一个新的 event_config。之后，你可以调用其他函数来告知 event_config 你的需求。最终，你调用 event_base_new_with_config() 来获得一个新的 event_base。当你完成后，你可以使用 event_config_free() 来释放 event_config。' },
    { EN: "", CN: '调用 event_config_avoid_method 告诉 Libevent 避免使用特定名称的可用后端。调用 event_config_require_features() 告诉 Libevent 使用一系列特定功能。调用 event_config_set_flag() 告诉 Libevent 在构建 event_base 时设置一个或多个下面的运行时标志。' },
    { EN: "", CN: 'event_config_require_features() 识别的值有：<br>EV_FEATURE_ET<br>  支持边缘触发（edge-triggered）。<br>EV_FEATURE_O1<br>  添加或删除event，或者event变为活动状态是 O(1) 操作。<br>EV_FEATURE_FDS<br>  要求支持任意文件描述符类型，而不仅仅是socket。<br>event_config_set_flag() 识别的值有：<br>EVENT_BASE_FLAG_NOLOCK<br>  不为 event_base 分配锁。设置此选项可能会节省一些锁定和释放 event_base 的时间，但会使其在多线程中访问时不安全且无法正常工作。<br>EVENT_BASE_FLAG_IGNORE_ENV<br>  在选择使用哪种方法时，不检查 EVENT_* 环境变量。在使用此标志之前，请仔细考虑：它可能会使用户难以调试程序与 Libevent 的交互。<br>EVENT_BASE_FLAG_STARTUP_IOCP<br>  仅Windows，此标志使 Libevent 在启动时启用任何必要的 IOCP 调度逻辑，而不是按需启用。<br>EVENT_BASE_FLAG_NO_CACHE_TIME<br>  不是每次执行超时回调时都检查当前时间，而是在每个超时回调之后检查。这可能会使用比你本意更多的 CPU，所以要注意！(PS:字面意思是不使用cachetime，但解释和cache没有关系，不明白)<br>EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST<br>  告诉 Libevent，如果它决定使用 epoll，使用基于changelist是更快并且安全的。<br>epoll-changelist可以避免不必要的系统调用（原文翻译：epoll-changelist后端可以避免在对后端的调度函数的调用之间多次修改同一个 fd 的状态的情况下，避免不必要的系统调用），但它可能触发一个内核错误，如果你给 Libevent 通过dup()克隆的fd 或 其他变体，可能会导致错误的结果。<br>如果你使用的是除 epoll 之外的其他后端，此标志无效。你也可以通过设置 EVENT_EPOLL_USE_CHANGELIST 环境变量来开启 epoll-changelist 选项。<br>EVENT_BASE_FLAG_PRECISE_TIMER<br>默认情况下，Libevent 会尝试使用操作系统提供的最快的定时机制。如果有一个较慢的定时机制提供了更精细的定时精度，这个标志会告诉 Libevent 使用那个定时机制。如果操作系统没有提供这样的慢但更精确的机制，此标志无效。<br>上述操作 event_config 的函数在成功时返回 0，在失败时返回 -1。' },
    { EN: "", CN: '很容易设置一个你的操作系统不支持的event_config。例如，截至 Libevent 2.0.1-alpha 版本，Windows 上没有 O(1) 后端，并且 Linux 上没有同时提供 EV_FEATURE_FDS 和 EV_FEATURE_O1 的后端。如果你制定了一个 Libevent 无法满足的配置，event_base_new_with_config() 将返回 NULL。' },
    { EN: "", CN: '这个函数目前只在使用 IOCP 的 Windows 上有用，尽管它可能在将来对其他平台也有用。调用它告诉 event_config 生成的 event_base 应该尝试很好地利用给定数量的 CPU 进行多线程处理。注意这只是一个提示：event_base 可能最终使用的 CPU 数量多于或少于你选择的。' },
    { EN: "", CN: '这个函数通过限制在检查更高优先级事件之前可以调用多少低优先级事件回调来防止优先级倒置。如果 max_interval 非空，事件循环将在每个回调后检查时间，并且如果已经过了 max_interval 就重新扫描高优先级事件。如果 max_callbacks 是非负数，事件循环也会在调用了 max_callbacks 回调后检查更多事件。这些规则适用于 min_priority 或更高的任何事件。' },
    { EN: "", CN: '这些函数和类型在<event2/event.h>中声明。' },
    { EN: "", CN: 'EVENT_BASE_FLAG_IGNORE_ENV 首次出现在 Libevent 2.0.2-alpha。 EVENT_BASE_FLAG_PRECISE_TIMER 首次出现在 Libevent 2.1.2-alpha。 event_config_set_num_cpus_hint() 函数是在 Libevent 2.0.7-rc 中新增的，event_config_set_max_dispatch_interval() 则在 2.1.1-alpha 中新增。本节中的其他内容都首次出现在 Libevent 2.0.1-alpha 中。' },
    { EN: "", CN: '有时你可能想要了解在一个event_base中实际可用的特性，或者它正在使用哪种方法。' },
    { EN: "", CN: 'event_get_supported_methods() 函数返回一个指针，指向一个字符串数组，这些字符串代表了这个版本的Libevent支持的方法的名称。该数组的最后一个元素是NULL。' },
    { EN: "", CN: '这个函数返回的是Libevent编译时支持的方法列表。实际上你的操作系统可能并不完全支持这些方法。例如，你可能使用的是OSX的一个版本，在这个版本上kqueue太多bug，不能使用。' },
    { EN: "", CN: 'event_base_get_method() 调用返回一个event_base实际使用的方法的名称。event_base_get_features()返回它支持的特性的位掩码。' },
    { EN: "", CN: '这些函数在<event2/event.h>中定义。event_base_get_method() 引入于Libevent 1.4.3。其他的首次出现在 Libevent 2.0.1-alpha。' },
    { EN: "", CN: '当你使用完一个event_base后，你可以通过event_base_free()来释放它。' },
    { EN: "", CN: '注意这个函数不会释放当前与event_base关联的任何event，也不会关闭它们的任何套接字，或者释放它们的任何指针。' },
    { EN: "", CN: 'event_base_free() 函数在<event2/event.h>中定义。它首次在Libevent 1.2中实现。' },
    { EN: "", CN: 'Libevent支持对event设置多个优先级。然而，默认情况下，一个event_base只支持单一的优先级层次。你可以通过调用event_base_priority_init()来设置优先级。' },
    { EN: "", CN: '这个函数在成功时返回0，在失败时返回-1。base参数是要修改的event_base，而n_priorities是要支持的优先级。它必须至少为1。新event的优先级将从0（最重要）编号到n_priorities-1（最不重要）。' },
    { EN: "", CN: '有一个常量EVENT_MAX_PRIORITIES，它设置了n_priorities值的上限。使用高于这个值的n_priorities调用这个函数是错误的。' },
    { EN: "", CN: '你必须在任何event变为活动状态之前调用这个函数。最好是在创建event_base后立即调用。' },
    { EN: "", CN: '要获取base当前支持的优先级数量，你可以调用event_base_get_npriorities()。' },
    { EN: "", CN: '返回值base中配置的优先级。例如event_base_get_npriorities()返回3，则允许的优先级值是0，1和2。' },
    { EN: "", CN: '默认情况下，与此base关联的所有新event将优先级初始化为n_priorities / 2。' },
    { EN: "", CN: 'event_base_priority_init函数在<event2/event.h>中定义。它自Libevent 1.0以来就可用。event_base_get_npriorities()函数是在Libevent 2.1.1-alpha中新增的。' },
    { EN: "", CN: '并非所有event在调用fork()后都能干净地持续运行。因此，如果你的程序使用fork()或相关的系统调用来启动一个新进程，并且你希望在fork后继续使用event_base，你可能需要重新初始化它。' },
    { EN: "", CN: '这个函数在成功时返回0，在失败时返回-1。' },
    { EN: "", CN: 'event_reinit()函数在<event2/event.h>中定义。它首次在Libevent 1.4.3-alpha中可用。' },
    { EN: "", CN: '早期版本的Libevent非常依赖于“当前”event_base的概念。“当前”的event_base是一个在所有线程之间共享的全局设置。如果你忘记指定你想要的event_base，你就会得到当前的那个。由于event_bases不是线程安全的，这可能会导致相当容易出错。' },
    { EN: "", CN: '替代event_base_new()的是：struct event_base *event_init(void);' },
    { EN: "", CN: '这个函数的工作方式类似于event_base_new()，并将当base设置为分配的base。没有其他方式可以更改当前base。' },
    { EN: "", CN: '本节中的一些event_base函数有操作当前base的变体。这些函数的行为与当前函数一样，除了它们不接受参数。' },
  ]
)


doTranslate(
  './public/Libevent_R3_Working_with_an_event_loop.html',
  [
    { EN: "", CN: '一旦你拥有了一个event_base并注册了一些event（关于如何创建和注册事件，请参阅下一节），你会希望Libevent能够等待并提醒你这些event。' },
    { EN: "", CN: '默认情况下，event_base_loop()函数会运行一个event_base，直到其中没有event注册。为了运行循环，它会重复检查是否有任何注册的event已经触发（例如，一个文件描述符准备好读取了，或者一个超时到期了）。一旦这种情况发生，它会将所有触发的event标记为“活动的”，并开始运行这些事件。' },
    { EN: "", CN: '你可以改变event_base_loop()的行为通过一些flags参数。如果设置了EVLOOP_ONCE，则循环会等待一些event变为活动状态，然后运行它们直到没有可运行的event，然后返回。如果设置了EVLOOP_NONBLOCK，则循环不会等待event触发：它只会检查是否有任何event准备好立即触发，并在是这种情况下运行它们的回调。' },
    { EN: "", CN: '通常，只要循环没有待处理的或活动的event，它就会退出。你可以通过传递EVLOOP_NO_EXIT_ON_EMPTY标志来覆盖这一行为——例如，如果你打算从其他线程添加事件。如果你设置了EVLOOP_NO_EXIT_ON_EMPTY，循环将持续运行，直到有人调用event_base_loopbreak()，或者调用event_base_loopexit()，或者发生错误。' },
    { EN: "", CN: '当它完成时，如果event_base_loop()正常退出，返回0；如果因为后端某些未处理的错误而退出，会返回-1；如果因为没有更多待处理或活动的event而退出，会返回1。' },
    { EN: "", CN: '为了便于理解，这里是event_base_loop算法的大致总结：' },
    { EN: "", CN: '为了方便起见，您还可以调用：' },
    { EN: "", CN: 'event_base_dispatch()与event_base_loop()相同，不设置任何标志。因此，它会一直运行，直到没有更多注册的event，或者直到调用了event_base_loopbreak()或event_base_loopexit()。' },
    { EN: "", CN: '这些函数定义在`<event2/event.h>`中。它们自Libevent 1.0以来就存在了。' },
    { EN: "", CN: '如果你希望一个活动的event循环在所有event被移除之前停止运行，你有两个略有不同的函数可以调用。' },
    { EN: "", CN: 'event_base_loopexit()函数指示一个event_base在给定时间过后停止循环。如果tv参数为NULL，那么event_base将会立即停止循环。如果event_base当前正在为任何活动的event运行回调，它将继续运行它们，并且直到所有的都运行完毕之后才退出。' },
    { EN: "", CN: 'event_base_loopbreak()函数告诉event_base立即退出循环。它与event_base_loopexit(base, NULL)的不同之处在于，如果event_base当前正在为活动的event运行回调，它将在完成当前event之后立即退出。' },
    { EN: "", CN: '还要注意，当没有event正在运行时，event_base_loopexit(base,NULL)和event_base_loopbreak(base)的行为不同：`loopexit`安排下一个event循环实例在运行下一轮回调后立即停止（就像使用`EVLOOP_ONCE`标志一样），而`loopbreak`只会停止当前正在运行的循环，如果没有event运行，则不起作用。' },
    { EN: "", CN: '这两种方法在成功时返回0，在失败时返回-1。' },
    { EN: "", CN: '有时候你可能想知道event_base_dispatch()或event_base_loop()是否正常退出，或者是因为调用了event_base_loopexit()或event_base_break()。你可以使用以下函数来判断是否调用了loopexit或break：' },
    { EN: "", CN: '如果循环是因为分别调用了event_base_loopexit()或event_base_break()而停止的，这两个函数将返回true，否则返回false。他们的值将在你下次启动事件循环时被重置。' },
    { EN: "", CN: '这些函数在`<event2/event.h>`中声明。event_base_got_exit()函数最早在Libevent 1.0c中实现；event_base_got_break()函数最早在Libevent 1.4.3中实现。' },
    { EN: "", CN: '通常情况下，Libevent会检查event，然后在所有活动的event中运行优先级最高的，如此循环。但有时你可能想在当前回调运行完毕后立即停止Libevent，并告诉它再次扫描。通过类比event_base_loopbreak()，你可以使用event_base_loopcontinue()函数来实现这一点。' },
    { EN: "", CN: '如果我们当前没有运行事件回调，调用event_base_loopcontinue()将没有效果。' },
    { EN: "", CN: '这个函数在Libevent 2.1.2-alpha中被引入。' },
    { EN: "", CN: '有时你可能想在事件回调中获取当前时间的大致情况，而且不希望调用gettimeofday()（gettimeofday()为系统调用，应避免系统调用的开销）。' },
    { EN: "", CN: '在回调函数内部，你可以询问Libevent当前时间：' },
    { EN: "", CN: '如果event_base当前正在执行回调，event_base_gettimeofday_cached()函数会将其tv_out参数的值设置为缓存时间。否则，它会调用evutil_gettimeofday()来获取实际的当前时间。它在成功时返回0，在失败时返回负值。' },
    { EN: "", CN: '请注意，由于时间值是在Libevent开始运行回调时缓存的，它有一点不准确。如果你的回调运行需要很长时间，它可能会非常不准确。要强制立即更新缓存，你可以调用这个函数：' },
    { EN: "", CN: '它在成功时返回0，在失败时返回-1，如果base没有运行其事件循环则没有效果。' },
    { EN: "", CN: 'event_base_gettimeofday_cached()函数在Libevent 2.0.4-alpha中是新引入的。Libevent 2.1.1-alpha添加了event_base_update_cache_time()。' },
    { EN: "", CN: '为了帮助调试程序（或调试Libevent!），你有时可能需要一个列表包含了event_base中所有的event及其状态。调用event_base_dump_events()会将此列表写入提供的stdio文件中。' },
    { EN: "", CN: '此列表旨在便于人读，其格式在Libevent的未来版本中将会改变。' },
    { EN: "", CN: '该函数在Libevent 2.0.1-alpha中引入。' },
    { EN: "", CN: '你可以使用event_base_foreach_event()来迭代与event_base()相关联的每个当前激活或待处理的event。提供的回调函数会按照未指定的顺序准确地对每个event调用一次。第三个参数将作为回调函数调用的第三个参数传递。' },
    { EN: "", CN: '回调函数必须返回0以继续迭代，或返回其他整数以停止迭代。回调函数最终返回的值将被event_base_foreach_function()返回。' },
    { EN: "", CN: '你的回调函数一定不能修改event，也不能添加或移除event base中的任何event，或以其他方式修改与event base相关的任何event，否则可能发生未定义的行为，包括崩溃和堆破坏。' },
    { EN: "", CN: '在调用event_base_foreach_event()期间，将持有event_base锁——这将阻止其他线程对event_base进行任何操作，因此请确保你的回调不会花费太长时间。' },
    { EN: "", CN: '该函数在Libevent 2.1.2-alpha中添加。' },
    { EN: "", CN: '如上所述，旧版的Libevent API对“当前”event_base有一个全局概念。' },
    { EN: "", CN: '本节中的一些事件循环函数有当前版本的变体。这些函数的行为与当前函数相同，除了它们不接受基础参数。' },
    { EN: "", CN: '由于event_base在Libevent 2.0之前不支持锁，这些函数不是线程安全的：不允许从执行event线程之外的线程中调用_loopbreak()或_loopexit()函数。' },
  ]
)


doTranslate(
  './public/Libevent_R4_Working_with_events.html',
  [
    { EN: "", CN: 'Libevent的基本操作单元是event。每个event代表一组条件，包括：<br>- fd准备好读取或写入。<br>- fd变得准备好读取或写入（仅限边缘触发IO）。<br>- 超时到期。<br>- 发生信号。<br>- 用户触发的事件。' },
    { EN: "", CN: 'event具有相似的生命周期。一旦你调用Libevent函数来设置一个event并将其与事件基础关联，它就变成了已初始化的状态。在这个点上，你可以添加事件，这样它就变为pending(待处理状态)。当事件处于pending时，如果触发事件的条件发生（例如，它的fd状态改变或超时到期），event变为active(活动状态)，其（用户提供的）回调函数将被运行。如果event被配置为持久的(persistent)，它将保持pending。如果它不是持久的，那么当其回调函数运行时，它就不再是pending状态。你可以删除event来使pending变为non-pending，也可以添加event使non-pending其再次变为pending。' },
    { EN: "", CN: '创建新的event，你可以使用：' },
    { EN: "", CN: 'event_new()函数尝试通过base分配和构造一个新的event。`what`参数是上面列出的一组标志。（它们的语义将在下面描述。）如果`fd`是非负数，它就是我们将观察读或写事件的文件。当event变为active，Libevent将调用提供的`cb`函数，并向它传递参数：文件描述符`fd`，触发事件的位字段，以及`arg`。' },
    { EN: "", CN: '如果内部错误，或者参数无效，event_new()将返回NULL。' },
    { EN: "", CN: '所有新event都是已初始化且non-pending。要使event成为pending，请调用event_add()（下面有文档说明）。' },
    { EN: "", CN: '要释放一个event，请调用event_free()。在一个event处于pending或active时调用event_free()是安全的：这样做会在释放event之前使之变为non-pending和inactive。' },
    { EN: "", CN: '上述函数在 `<event2/event.h>` 文件中定义，并首次出现在 Libevent 2.0.1-alpha 版本中。`event_callback_fn` 类型首次出现在 Libevent 2.0.4-alpha 版本中。' },
    { EN: "", CN: `EV_TIMEOUT<br>  此标志表示event超时后变为active。<br>  构造event时会忽略此标志：你可以在添加event时设置超时(或者不设置)。当超时发生时，它会在回调函数的 'what' 参数中被设置。<br>EV_READ<br>  此标志表示fd准备好读取时变为active。<br>EV_WRITE<br>  此标志表示fd准备好写入时变为active。<br>EV_SIGNAL<br>  用于实现信号检测。请参见下面的"Constructing signal events"。<br>EV_PERSIST<br>  持久的。请参见下面的"About Event Persistence"。<br>EV_ET<br>  如果底层的 event_base 后端支持边缘触发，则该事件应该是边缘触发的。这会影响 EV_READ 和 EV_WRITE 的语义。` },
    { EN: "", CN: '自 Libevent 2.0.1-alpha 版本以来，任何数量的event可能会同时因相同的条件而处于pending。例如，你可能有两个event，如果给定的 fd 准备好读取，它们将变为active。它们的回调执行顺序是未定义的。' },
    { EN: "", CN: '这些标志在<event2/event.h>文件中定义。Libevent 1.0 之前的所有版本都有这些标志，除了 EV_ET，它是在 Libevent 2.0.1-alpha 版本中引入的。' },
    { EN: "", CN: '默认情况下，每当pending变为active（因为它的 fd 准备好读取或写入，或者因为超时到期），它在执行回调之前就变成non-pending。因此，如果你想让event再次变为pending，你可以在回调函数内部再次调用 event_add()。' },
    { EN: "", CN: '然而，如果event设置了 EV_PERSIST 标志，则该event是持久的。这意味着即使其回调被激活，event仍然为pending。如果你想在它的回调内部让它变为non-pending，你可以对它调用 event_del()。' },
    { EN: "", CN: '持久事件上的超时会在event回调运行时重置。因此，如果你有一个具有标志 EV_READ|EV_PERSIST 和五秒超时的event，该event将变为活动状态：<br>- 每当socket准备好读取时。<br>- 每当event变为active后的五秒。' },
    { EN: "", CN: '通常，你可能想要创建一个event，并将其自身作为回调参数。但是你不能将event的指针作为参数传递给 event_new()，因为它此时还不存在。为了解决这个问题，你可以使用 event_self_cbarg()。' },
    { EN: "", CN: 'event_self_cbarg() 函数返回一个“魔法”指针，当作为event回调参数传递时，它告诉 event_new() 创建一个event，并将自身作为其回调参数。' },
    { EN: "", CN: '该函数还可以与 `event_new()`、`evtimer_new()`、`evsignal_new()`、`event_assign()`、`evtimer_assign()` 和 `evsignal_assign()` 一起使用。然而，它不适用于非事件的回调参数。' },
    { EN: "", CN: 'event_self_cbarg() 函数是在 Libevent 2.1.1-alpha 版本中引入的。' },
    { EN: "", CN: '为了方便，有一组以 evtimer_ 开头的宏，你可以使用这些宏来代替 `event_*` 分配和操作纯超时事件。使用这些宏除了提高代码清晰度外，没有其他好处。' },
    { EN: "", CN: '这些宏自 Libevent 0.6 起就存在，除了 evtimer_new()，它是在 Libevent 2.0.1-alpha 版本中首次出现的。' },
    { EN: "", CN: 'Libevent 也可以监控 POSIX 风格的信号。要为信号构造一个处理程序，请使用：' },
    { EN: "", CN: '参数与 `event_new` 的一样，除了我们提供一个信号编号而不是fd。' },
    { EN: "", CN: '请注意，信号回调是在信号发生后在事件循环中运行的，所以它们可以安全地调用那些你不应该在常规 POSIX 信号处理程序中调用的函数。' },
    { EN: "", CN: '还有一组方便的宏，你可以在处理信号事件时使用它们。' },
    { EN: "", CN: '`evsignal_*` 宏自 Libevent 2.0.1-alpha 起就存在。之前的版本将它们称为 `signal_add()`、`signal_del()` 等。' },
    { EN: "", CN: '在当前版本的 Libevent 中，对于大多数后端，每次只能有一个event_base在进程中监听信号。如果你同时向两个 event_bases 添加信号事件 ---即使信号不同！--- 只有一个 event_base 将接收到信号。' },
    { EN: "", CN: 'kqueue 后端没有这个限制。' },
    { EN: "", CN: '有时，创建用户触发的event是有用的，它可以在所有更高优先级的event完成后激活并运行。任何类型的清理或垃圾回收都是这样的。参见“Events with priorities”了解如何设置低优先级。' },
    { EN: "", CN: '用户触发的event可以如下创建：' },
    { EN: "", CN: '请注意，不需要 `event_add()`。然后，它通过如下方式触发：' },
    { EN: "", CN: '第三个参数对于非信号事件来说并不重要。' },
    { EN: "", CN: '出于性能和其他原因，一些人喜欢将event作为更大结构的一部分进行分配。对于每次使用事件，这能节省了：<br>- 在堆上分配小对象时内存分配器的开销。<br>- 解引用指向 struct event 的指针的时间开销。<br>- 如果event不在缓存中，缓存未命中的时间开销。' },
    { EN: "", CN: '使用这种方法有破坏 Libevent 其他版本的二进制兼容性的风险，因为可能有不同大小的事件结构。' },
    { EN: "", CN: '这些成本其实非常小，对于大多数应用来说并不重要。除非你确定event堆分配会带来显著的性能损失，否则你应该坚持使用 `event_new()`。使用 `event_assign()` 可能会导致难以诊断的错误，未来版本的 Libevent 使用的是比你当前构建的版本更大的事件结构。' },
    { EN: "", CN: '`event_assign()` 的所有参数都与 `event_new()` 的相同，除了event参数必须指向一个未初始化的event。它在成功时返回 0，在发生内部错误或参数错误时返回 -1。' },
    { EN: "", CN: '你还可以使用 `event_assign()` 来初始化栈分配或静态分配的event。' },
    { EN: "", CN: '绝对不要对已经pending的event调用 event_assign()。这样做可能会导致极其难以诊断的错误。如果event已经初始化并pending，你可以先event_del()再event_assign()。' },
    { EN: "", CN: '有一些方便的宏你可以用来将 `event_assign()` 用于只有超时或信号事件：' },
    { EN: "", CN: '如果你需要使用 `event_assign()` 并保持与未来版本的 Libevent 的二进制兼容，你可以请求 Libevent 库告诉你 struct event 应该有多大：' },
    { EN: "", CN: '这个函数返回你需要为 event 留出的字节数。如前所述，你应该只在确认堆分配是重大问题时才使用此函数，因为它可能使你的代码阅读和编写起来更加困难。' },
    { EN: "", CN: '请注意，`event_get_struct_event_size()` 在未来可能会给你一个小于 `sizeof(struct event)` 的值。如果发生这种情况，这意味着 struct event 结尾的额外字节仅仅是为未来版本的 Libevent 预留的填充字节。' },
    { EN: "", CN: '这里有一个和上面相同的例子，但我们没有依赖于 event_struct.h 中的 struct event 的大小，而是使用 `event_get_struct_size()` 来在运行时使用正确的大小。' },
    { EN: "", CN: '`event_assign()` 函数定义在 `<event2/event.h>` 中。自 Libevent 2.0.1-alpha 起就存在。自 2.0.3-alpha 起，它返回一个 int。之前返回 void。`event_get_struct_event_size()` 函数在 Libevent 2.0.4-alpha 中被引入。event结构体定义在 `<event2/event_struct.h>` 中。' },
    { EN: "", CN: '在你构造了一个event，它实际上不会做任何事情，除非你通过添加它使其处于pending。你可以使用 `event_add` 来做这件事：' },
    { EN: "", CN: '在一个non-pending的event上调用 `event_add` 会使其在base上变为pending。函数在成功时返回 0，在失败时返回 -1。如果 tv 是 NULL，则事件会被添加且没有超时。否则，tv 就是秒和微秒为单位的超时。' },
    { EN: "", CN: '如果你在已经pending的event上调用 `event_add()`，它将离开pending，并根据提供的超时重新pending。如果event已经pending，并且你用 NULL 超时重新添加它，`event_add()` 将没有任何效果。' },
    { EN: "", CN: '不要将 tv 设置为时间戳。如果你在 2010 年 1 月 1 日设置 "tv→tv_sec = time(NULL)+10;"，你的超时将等待 40 年，而不是 10 秒。' },
    { EN: "", CN: '在一个已初始化的event上调用 `event_del` 会使其变为non-pending和non-active。如果event并非pending或active，那么将没有任何效果。成功时返回 0，失败时返回 -1。' },
    { EN: "", CN: '如果event变为active但在其回调执行之前删除它，那么回调将不会被执行。' },
    { EN: "", CN: '最后，你可以移除pending状态的event的超时，而不删除其 IO 或信号组件。如果evnet没有设置超时，`event_remove_timer()` 将没有任何效果。如果event只有超时而没有 IO 或信号组件，`event_remove_timer()` 的效果与 `event_del()` 相同。成功时返回 0，失败时返回 -1。' },
    { EN: "", CN: '这些都定义在 `<event2/event.h>` 中；`event_add()` 和 `event_del()` 自 Libevent 0.1 版本以来就存在；`event_remove_timer()` 在 2.1.2-alpha 版本中被添加。' },
    { EN: "", CN: '当多个event同时触发时，Libevent 并没有定义event回调将按照什么顺序执行。你可以通过优先级来定义某些事件比其他事件更重要。' },
    { EN: "", CN: '正如前面章节讨论的，每个 `event_base` 都有一个或多个优先级值。在将event初始化之后，添加到 `event_base` 之前，，你可以设置它的优先级。' },
    { EN: "", CN: '事件的优先级是一个介于 0 和 `event_base` 中的优先级数量减 1 之间的数字。函数在成功时返回 0，在失败时返回 -1。' },
    { EN: "", CN: '当具有多个优先级的多个event被active时，低优先级的事件不会被执行。相反，Libevent 会运行高优先级的事件，然后再次检查事件。只有当没有高优先级的event处于active时，低优先级的才会被运行。' },
    { EN: "", CN: '当你没有为event设置优先级时，默认值是base中队列数量除以 2。' },
    { EN: "", CN: '这个函数在 `<event2/event.h>` 中声明。自 Libevent 1.0 起就存在了。' },
    { EN: "", CN: '有时你可能想知道event是否已经被添加，以及它指向了什么。' },
    { EN: "", CN: '`event_pending` 函数用于确定event是否处于pending或active。如果是，并且在 `what` 参数中设置了任何标志如 EV_READ、EV_WRITE、EV_SIGNAL 和 EV_TIMEOUT，函数会返回event当前的pending或active的所有标志。如果提供了 `tv_out`，并且在 `what` 中设置了 EV_TIMEOUT，且event当前在超时上处于pending或active，则 `tv_out` 被设置为超时将到期的时间。' },
    { EN: "", CN: '`event_get_fd()` 和 `event_get_signal()` 函数返回配置的fd或信号值。`event_get_base()` 函数返回 `event_base`。`event_get_events()` 函数返回事件标志（EV_READ、EV_WRITE 等）。`event_get_callback()` 和 `event_get_callback_arg()` 函数返回回调函数和参数指针。`event_get_priority()` 函数返回优先级。' },
    { EN: "", CN: '`event_get_assignment()` 函数将所有已分配字段复制到提供的指针中。如果任何指针是 NULL，它会被忽略。' },
    { EN: "", CN: '这些函数在 `<event2/event.h>` 中声明。`event_pending()` 函数自 Libevent 0.1 起就存在。Libevent 2.0.1-alpha 引入了 `event_get_fd()` 和 `event_get_signal()`。Libevent 2.0.2-alpha 引入了 `event_get_base()`。Libevent 2.1.2-alpha 添加了 `event_get_priority()`。其它函数是在 Libevent 2.0.4-alpha 中新增的。' },
    { EN: "", CN: '为了调试或其他目的，你可以获取一个指向当前运行事件的指针。' },
    { EN: "", CN: '请注意，当这个函数从提供的 `event_base` 的循环内部被调用时，其行为才有明确定义。从另一个线程调用它是不被支持的，并且可能会引起未定义行为。' },
    { EN: "", CN: '该函数在 `<event2/event.h>` 中声明。它是在 Libevent 2.1.1-alpha 中引入的。' },
    { EN: "", CN: '如果你不需要多次添加一个事件，或者在添加后不需要删除它，并且它不必是持久的，你可以使用 `event_base_once()`。' },
    { EN: "", CN: '这个函数的接口与 `event_new()` 相同，不同之处在于它不支持 EV_SIGNAL 或 EV_PERSIST。event会以默认优先级插入并执行。当回调最终完成时，Libevent 会自己释放内部事件结构。返回值为 0 表示成功，-1 表示失败。' },
    { EN: "", CN: '使用 `event_base_once` 插入的event不能被删除或手动激活：如果你想能够取消event，应使用常规的 `event_new()` 或 `event_assign()` 接口创建它。' },
    { EN: "", CN: '还要注意，直到 Libevent 2.0，如果event从未被触发，用来持有它的内部内存永远不会被释放。从 Libevent 2.1.2-alpha 开始，即使这些event没有被active，当 `event_base` 被释放时，它们也会被释放，但仍需注意：如果与它们的回调参数相关联的有一些存储，除非你的程序做了一些跟踪和释放它的操作，否则这部分存储不会被释放。' },
    { EN: "", CN: '偶尔，你可能希望使一个event变为active，即使它的条件尚未触发。' },
    { EN: "", CN: '这个函数使event变为active并附带 `what` （EV_READ、EV_WRITE 和 EV_TIMEOUT 的组合）。event不需要是pending，并且激活它不会使它变为pending。' },
    { EN: "", CN: '警告：在同一个event上递归调用 `event_active()` 可能会导致资源耗尽。以下代码片段是一个错误使用 `event_active` 的例子。' },
    { EN: "", CN: '这会创建一个情形，event循环只执行一次并且永远调用函数 "cb"。' },
    { EN: "", CN: '此函数在 `<event2/event.h>` 中定义。它自 Libevent 0.3 起就存在了。' },
    { EN: "", CN: '当前版本的 Libevent 使用二叉堆算法跟踪pending event的超时。二叉堆对于添加和删除event超时的性能为 O(lg n)。如果你添加的event超时是随机分布的，这是最优的，但如果大量event具有相同超时，这并不理想。' },
    { EN: "", CN: '例如，你有一万个event，每个event应在添加后五秒内触发超时。在这种情况下，如果使用双向链表实现，你可以为每个超时获得 O(1) 的性能。' },
    { EN: "", CN: '当然，你不会希望对所有的超时值都使用队列，因为队列只对常数超时更快。如果一些超时多多少少的随机分布，那么添加这些到队列中将花费 O(n) 的时间，这比二叉堆要糟糕得多。' },
    { EN: "", CN: 'Libevent 允许你将一些超时放入队列，而将其他超时放入二叉堆来解决这个问题。为此，你需要向 Libevent 请求一个特殊的“common timeout”时间值，然后使用该值添加到event。如果你有大量具有单一公共超时的event，使用这种优化应该会提高超时性能。' },
    { EN: "", CN: '此函数接受 event_base 和公共超时时间作为参数。它返回指向特殊 struct timeval 的指针，你可以使用该指针来指示应该将一个event添加到 O(1) 队列而不是 O(lg n) 堆中。这个特殊的 timeval 可以在你的代码中自由复制或赋值。它只会与你构的特定 base 一起工作。不要依赖它的实际内容：Libevent 使用它们来告诉自己使用哪个队列。' },
    { EN: "", CN: '就像所有优化功能一样，除非你确信它对你很重要，否则应该避免使用 common_timeout 功能。' },
    { EN: "", CN: '这个功能是在 Libevent 2.0.4-alpha 中引入的。' },
    { EN: "", CN: 'Libevent 提供了一些函数，你可以使用这些函数来区分已初始化的event（例如，通过使用 calloc() 分配它或使用 memset() 或 bzero() 清除它）。' },
    { EN: "", CN: '这些函数不能可靠地区分已初始化的event和一块未初始化的内存。除非你知道所讨论的内存要么被清除，要么作为事件被初始化，否则你不应该使用它们。' },
    { EN: "", CN: '通常，除非你有一个相当特定的应用场景，否则你不需要使用这些函数。通过 event_new() 返回的event总是已经初始化的。' },
    { EN: "", CN: 'event_initialized() 函数自 Libevent 0.3 版本起就已存在。' },
    { EN: "", CN: 'Libevent 2.0 之前的版本没有 event_assign() 或 event_new()。相反，你需要使用 event_set()，它将event与“当前”base关联起来。如果你有多个base，你需要记得调用 event_base_set() 来确保event与你实际想要使用的base关联。' },
    { EN: "", CN: 'event_set() 函数类似于 event_assign()，除了它使用当前base。event_base_set() 函数改变event与base的关联。' },
    { EN: "", CN: '有 event_set() 的变体，用于更方便地处理计时器和信号：evtimer_set() 大致对应于 evtimer_assign()，evsignal_set() 大致对应于 evsignal_assign()。' },
    { EN: "", CN: 'Libevent 2.0 之前的版本使用 "signal_" 作为 event_set() 及其基于信号的变体的前缀，而不是 "evsignal_"。（也就是说，它们有 signal_set()、signal_add()、signal_del()、signal_pending() 和 signal_initialized()）。更早的的 Libevent（0.6 之前）使用 "timeout_" 而不是 "evtimer_"。因此，如果你在做代码考古，你可能会看到 timeout_add()、timeout_del()、timeout_initialized()、timeout_set()、timeout_pending() 等。' },
    { EN: "", CN: '旧版本的 Libevent（2.0 之前）使用了两个宏 EVENT_FD() 和 EVENT_SIGNAL() 来替代 event_get_fd() 和 event_get_signal() 函数。这些宏直接检查事件结构的内容，因此阻止了版本之间的二进制兼容性；在 2.0 及以后，它们只是 event_get_fd() 和 event_get_signal() 的别名。' },
    { EN: "", CN: '由于 Libevent 2.0 之前的版本没有锁支持，因此在base线程之外调用任何改变event与base相关状态的函数都是不安全的。这些函数包括 event_add()、event_del()、event_active() 和 event_base_once()。' },
    { EN: "", CN: '还有一个 event_once() 函数，起到了 event_base_once() 的作用，但使用当base。' },
    { EN: "", CN: '在 Libevent 2.0 之前，EV_PERSIST 标志与超时不会合理地互操作。EV_PERSIST 标志没有在每次active重置超时，而是对超时不做任何操作。' },
    { EN: "", CN: 'Libevent 2.0 之前的版本不支持同时插入具有相同 fd 和相同 READ/WRITE 的多个event。换句话说，每个 fd 同一时间只能有一个event在等待读取，同一时间只能有一个event在等待写入。' },
  ]
)


doTranslate(
  './public/Libevent_R5_Helper_functions_and_types_for_Libevent.html',
  [
    { EN: "", CN: '`<event2/util.h>`头文件定义了许多可能对使用Libevent实现可移植应用程序有帮助的函数。Libevent在内部使用这些类型和函数。' },
    { EN: "", CN: '在除了Windows之外的大多数地方，socket是int类型，操作系统按数字顺序分配它们。然而，在使用Windows时，socket是SOCKET类型，这实际上是一个类指针的操作系统句柄，并且你接收到它们的顺序是未定义的。我们定义了evutil_socket_t类型，它是一个整数，可以在Windows上避免发生指针截断的风险的情况下保存socket()或accept()的输出。' },
    { EN: "", CN: '这种类型在Libevent 2.0.1-alpha版本中被引入。' },
    { EN: "", CN: '通常，你会发现自己处于一个错过了21世纪的C系统中，因此没有实现标准的C99 stdint.h头文件。对于这种情况，Libevent定义了它自己版本的来自stdint.h的特定位宽的整数类型：' },
    { EN: "", CN: '就像C99标准中那样，每种类型都有它指定的确切位宽。' },
    { EN: "", CN: '这些类型在Libevent 1.4.0-beta版本中被引入。MAX/MIN常量最早出现在Libevent 2.0.4-alpha版本。' },
    { EN: "", CN: '如果平台有ssize_t类型（有符号的size_t），那么ev_ssize_t类型就定义为ssize_t，如果没有，则定义为一个合理的默认值。ev_ssize_t的可能的最大值是EV_SSIZE_MAX；最小值是EV_SSIZE_MIN。（size_t可能的最大值是EV_SIZE_MAX，以防你的平台没有为你定义SIZE_MAX。）' },
    { EN: "", CN: 'ev_off_t类型用于表示文件或内存块的偏移量。在有合理的off_t定义的平台上，它被定义为off_t，在Windows上被定义为ev_int64_t。' },
    { EN: "", CN: '一些sockets API实现提供了一个长度类型socklen_t，有些则没有。ev_socklen_t定义为这种类型当它存在时，否则就定义为一个合理的默认值。' },
    { EN: "", CN: 'ev_intptr_t类型是一个有符号整数，足够大以至于可以在不丢失位的情况下存放一个指针。ev_uintptr_t类型是一个无符号整数，足够大以至于可以在不丢失位的情况下存放一个指针。' },
    { EN: "", CN: 'ev_ssize_t类型在Libevent 2.0.2-alpha版本中被添加。ev_socklen_t类型是在Libevent 2.0.3-alpha中新引入的。ev_intptr_t和ev_uintptr_t类型，以及EV_SSIZE_MAX/MIN宏，在Libevent 2.0.4-alpha版本中被添加。ev_off_t类型最早出现在Libevent 2.0.9-rc版本中。' },
    { EN: "", CN: '并不是每个平台都定义了标准的timeval操作函数，因此我们提供了我们自己的实现。' },
    { EN: "", CN: '这些宏将它们的前两个参数相加或相减（分别），并将结果储存在第三个参数中。' },
    { EN: "", CN: '清除一个timeval将其值设置为零。检查它是否被设置，如果非零则返回true，否则返回false。' },
    { EN: "", CN: 'evutil_timercmp宏将比较两个timevals，如果它们与关系运算符cmp指定的关系一致，则产生true。例如，evutil_timercmp(t1, t2, ⇐)的意思是，“t1是否⇐t2？”请注意，与某些操作系统的版本不同，Libevent的timercmp支持所有C关系操作（即<、>、==、!=、⇐和>=）。' },
    { EN: "", CN: 'evutil_gettimeofday函数将tv设置为当前时间。tz参数未被使用。' },
    { EN: "", CN: '这些函数是在Libevent 1.4.0-beta版本中引入的，除了evutil_gettimeofday()，它是在Libevent 2.0中引入的。' },
    { EN: "", CN: '在Libevent 1.4.4之前，使用timercmp时使用⇐或>=并不安全。' },
    { EN: "", CN: '由于历史原因，Windows从来没有以一种真正兼容（并且很好地兼容）的方式实现Berkeley sockets API。以下是一些函数，你可以使用它们来假装Windows已经实现了这些功能。' },
    { EN: "", CN: '这个函数用于关闭socket。在Unix系统上，它是`close()`的别名；在Windows上，它调用`closesocket()`。（在Windows上你不能使用`close()`来关闭socket，而其他系统也没有定义`closesocket()`。）' },
    { EN: "", CN: '`evutil_closesocket`函数是在Libevent 2.0.5-alpha版本中引入的。在此之前，你需要调用`EVUTIL_CLOSESOCKET`宏。' },
    { EN: "", CN: '这些宏用于访问和操作socket错误代码。`EVUTIL_SOCKET_ERROR()`返回这个线程最后一次socket操作的全局错误代码，`evutil_socket_geterror()`用于特定socket。（在类Unix系统上两者都是errno。）`EVUTIL_SET_SOCKET_ERROR()`更改当前socket错误代码（就像在Unix上设置errno一样）， `evutil_socket_error_to_string()`返回给定socket错误代码的字符串表示（就像Unix上的`strerror()`）。' },
    { EN: "", CN: '（我们需要这些函数是因为Windows不使用errno来表示socket函数的错误，而是使用`WSAGetLastError()`。）' },
    { EN: "", CN: '请注意，Windows的socket错误与在标准C中的errno不同；要小心。' },
    { EN: "", CN: '即使是进行socket非阻塞IO的调用在Windows上也不是可移植的。`evutil_make_socket_nonblocking()`函数接受一个新的socket（来自`socket()`或`accept()`）并将其变为非阻塞。（在Unix上设置O_NONBLOCK，在Windows上设置FIONBIO。）' },
    { EN: "", CN: '这个函数确保监听socket使用的地址在socket关闭后立即可用于另一个socket。（在Unix上设置SO_REUSEADDR，在Windows上不执行任何操作。你不想在Windows上使用SO_REUSEADDR；那里的含义不同。）' },
    { EN: "", CN: '这个调用告诉操作系统，如果我们调用exec()，这个socket应该被关闭。它在Unix上设置FD_CLOEXEC标志，在Windows上不执行任何操作。' },
    { EN: "", CN: '这个函数的行为类似于Unix的`socketpair()`调用：它创建了两个彼此连接的socket，可以使用普通的socket IO调用。它将两个socket存储在sv[0]和sv[1]中，并在成功时返回0，在失败时返回-1。' },
    { EN: "", CN: '在Windows上，这只支持family AF_INET，type SOCK_STREAM，和protocol 0。请注意，在一些安装了防火墙软件并巧妙地将127.0.0.1进行防火墙设置以防止主机与自己通信的Windows主机上，这可能会失败。' },
    { EN: "", CN: '这些函数是在Libevent 1.4.0-beta版本中引入的，除了`evutil_make_socket_closeonexec()`，它是在Libevent 2.0.4-alpha中新增的。' },
    { EN: "", CN: '这个函数的行为同strtol，但它处理 64 位整数。在某些平台上，它只支持十进制（Base 10）。' },
    { EN: "", CN: '这些 snprintf 替代函数的行为表现像标准的 snprintf 和 vsnprintf 接口。它们返回的是将要写入的字节数如果缓冲区足够长，不包括终止的 NUL 字节。（这种行为符合 C99 snprintf() 标准，并且与 Windows 的 _snprintf() 不同，后者如果字符串不适合缓冲区将返回一个负数。）' },
    { EN: "", CN: 'evutil_strtoll() 函数自 1.4.2-rc 版本以来一直存在于 Libevent 中。这些其他函数首次出现在 1.4.5 版本中。' },
    { EN: "", CN: '有时，在实现基于ASCII的协议时，你希望根据ASCII来操作字符串，而不用考虑你当前的地区设置是什么。Libevent提供了一些函数来帮助完成这个任务：' },
    { EN: "", CN: '这些函数的行为类似于`strcasecmp()`和`strncasecmp()`，不同之处在于它们总是使用ASCII字符集进行比较，不管当前的地区设置是什么。`evutil_ascii_str[n]casecmp()`函数首次在Libevent 2.0.3-alpha版本中公开。' },
    { EN: "", CN: '这些功能的行为类似于标准的 inet_ntop() 和 inet_pton() 函数，用于解析和格式化 IPv4 和 IPv6 地址，如 RFC3493 所规定的。即，要格式化一个 IPv4 地址，你需要调用 evutil_inet_ntop()，af 参数设为 AF_INET，src 指向一个 struct in_addr 结构体，dst 指向一个长度为 len 的字符缓冲区。对于 IPv6 地址，af 设为 AF_INET6，src 是一个 struct in6_addr 结构体。要解析一个 IPv4 地址，调用 evutil_inet_pton()，将 af 设为 AF_INET 或 AF_INET6，要解析的字符串在 src 中，dst 指向一个适当的 in_addr 或 in_addr6。' },
    { EN: "", CN: '从 evutil_inet_ntop() 返回的值在失败时为 NULL，其他情况下指向 dst。evutil_inet_pton() 返回 1 表示成功，如果 af 不被支持返回 -1，如果 src 不包含有效网络地址返回 0。' },
    { EN: "", CN: '这个函数解析 str 的地址，并将结果写入 out。outlen 参数必须指向一个整数，持有 out 中可用的字节数；它会被改变为实际使用的字节数。这个函数在成功时返回 0，在失败时返回 -1。它识别以下地址格式：<br>- [ipv6]:port（例如 "[ffff::]:80"）<br>- ipv6（例如 "ffff::"）<br>- [ipv6]（例如 "[ffff::]"）<br>- ipv4:port（例如 "1.2.3.4:80"）<br>- ipv4（例如 "1.2.3.4"）' },
    { EN: "", CN: '如果没有提供端口，结果 sockaddr 中的端口设置为 0。' },
    { EN: "", CN: 'evutil_sockaddr_cmp() 函数比较两个地址，如果 sa1 在 sa2 之前则返回负数，如果它们相等则返回 0，如果 sa2 在 sa1 之前则返回正数。它适用于 AF_INET 和 AF_INET6 地址，并且对于其他地址返回未定义的输出。它保证对这些地址给出一个全序，但排序可能在 Libevent 版本之间改变。' },
    { EN: "", CN: '如果 include_port 参数为 false，那么即便两个 sockaddr 只在端口上有差异，也会被视为相等。否则，端口不同的 sockaddrs 会被视为不相等。' },
    { EN: "", CN: '这些函数首次出现在 Libevent 2.0.1-alpha 版本中，除了 evutil_sockaddr_cmp()，它是在 2.0.3-alpha 版本中引入的。' },
    { EN: "", CN: '与标准的 offsetof 宏一样，这个宏能够得出从类型type到字段field出现位置的字节数。' },
    { EN: "", CN: '这个宏首次引入于 Libevent 2.0.1-alpha 版本。在 Libevent 2.0.3-alpha 版本之前的每个版本中，这个宏都存在错误。' },
    { EN: "", CN: '许多应用程序（包括 evdns）需要一个难以预测的随机数源来确保它们的安全。' },
    { EN: "", CN: '这个函数用 n 个随机字节填充到 buf。' },
    { EN: "", CN: '如果您的平台提供 arc4random() 函数，Libevent 将使用它。否则，它将使用自己的 arc4random() 实现，该实现由操作系统的熵池(Windows 上的 CryptGenRandom，其他地方是 /dev/urandom)提供种子。' },
    { EN: "", CN: '您不需要手动初始化安全随机数生成器，但如果您想确保它被成功初始化，您可以通过调用 evutil_secure_rng_init() 来做到这一点。它将为 RNG 提供种子（如果尚未提供种子），并在成功时返回 0。如果它返回 -1，意味着 Libevent 无法在您的操作系统上找到一个好的熵源，且在没有您自己初始化的情况下使用 RNG 是不安全的。' },
    { EN: "", CN: '如果您处于一个程序可能会降低权限的环境中运行（例如，通过运行chroot()），则您应该在这样做之前调用 evutil_secure_rng_init()。' },
    { EN: "", CN: '您可以通过调用 evutil_secure_rng_add_bytes() 为熵池自行添加更多随机字节；在典型使用中这通常是不必要的。' },
    { EN: "", CN: '这些功能是在 Libevent 2.0.4-alpha 版本中新增的。' },
  ]
)


doTranslate(
  './public/Libevent_R6_Bufferevents_concepts_and_basics.html',
  [
    { EN: "", CN: '大部分时间，应用程序除了简单地响应event外，还希望进行一定量的数据缓冲。例如，当我们想要写入数据时，通常的模式是这样的：<br>- 我们想要向一个连接写入一些数据；将那些数据放入一个缓冲区（buffer）中。<br>- 等待连接变得可写入。<br>- 写入尽可能多的数据。<br>- 记住我们写入了多少，并且如果我们还有更多数据要写入，等待连接再次变得可写入。' },
    { EN: "", CN: '这种缓冲式 IO 模式足够常见，以至于 Libevent 提供了一个通用机制。一个 "bufferevent" 包含了一个底层传输（比如一个socket）、一个读buffer和一个写buffer。与普通event不同，普通event在底层传输准备好读取或写入时给出回调，bufferevent 在它读取或写入足够数据时调用用户提供的回调函数。' },
    { EN: "", CN: 'bufferevent 有多种类型，它们共享一个通用接口。在本文撰写之时，以下类型存在：<br>基于socket的 bufferevents<br>  一个从底层流socket发送和接收数据的 bufferevent，使用 event_* 接口作为它的后端。<br>异步 IO bufferevents<br>  使用 Windows IOCP 接口向底层流socket发送和接收数据的 bufferevent。（仅限 Windows；实验性的。）<br>过滤 bufferevents<br>  在将数据传递给底层 bufferevent 对象之前处理传入和传出数据的 bufferevent——例如，压缩或转换数据。<br>配对的 bufferevents<br>  两个互相传输数据的 bufferevent。' },
    { EN: "", CN: '截至 Libevent 2.0.2-alpha 版本，这里的 bufferevents 接口在所有 bufferevent 类型之间仍然不是完全正交的。换句话说，并非下面描述的每个接口都适用于所有类型的 bufferevent。Libevent 的开发者计划在未来的版本中纠正这一点。' },
    { EN: "", CN: 'Bufferevents 当前只适用于像 TCP 这样的流式协议。将来可能会支持UDP 这样的数据报协议。' },
    { EN: "", CN: '这一部分中的所有函数和类型都声明在 event2/bufferevent.h 中。特别与 evbuffers 相关的函数在 event2/buffer.h 中声明；有关这些内容的信息请参阅下一章。' },
    { EN: "", CN: '每个bufferevent都有一个输入buffer和一个输出buffer。它们都是"struct evbuffer"类型的。当你有数据需要通过bufferevent写入时，你将它添加到输出buffer；当一个bufferevent有数据供你读取时，你需要从输入buffer中将它取出。' },
    { EN: "", CN: 'evbuffer接口支持许多操作；我们将在后面的章节中讨论这些操作。' },
    { EN: "", CN: '每个bufferevent都有两个与数据相关的回调函数：一个读回调和一个写回调。默认情况下，只要从底层传输读取到任何数据，读回调函数就会被调用；只要从输出buffer向底层传输并清空了足够的空间，写回调函数就被调用。你可以通过调整bufferevent的读写“水位标记”（水位标记）来改变这些函数的行为。' },
    { EN: "", CN: '每个bufferevent都有四个watermark：<br>Read low-water mark<br>  每当发生一次读取，使bufferevent的输入buffer达到或超过阈值，就会调用bufferevent的读取回调函数。默认值阈值为0，这样每次读取都会触发读取回调。<br>Read high-water mark<br>  如果bufferevent的输入buffer的数据量达到阈值，bufferevent就会停止读取，直到在输入buffer中清空足够的空间，使我们再次低于阈值。默认值阈值为无限制，因此我们不会因为输入buffer的大小而停止读取。<br>Write low-water mark<br>  每当发生一次写入操作，使空间达到或低于阈值，就会调用写回调函数。默认值为0，因此只有在输出buffer被清空时才会调用写回调函数。<br>Write high-water mark<br>  直接由bufferevent使用的写入高水位标记，当bufferevent被用作另一个bufferevent的底层传输时，这个水位标记可能有特殊的含义。请参阅下面关于过滤bufferevent的注释。' },
    { EN: "", CN: 'bufferevent还有一个“错误”或“事件”回调函数，当发生非数据导向事件时会被调用，比如当连接关闭或发生错误时。以下事件标志被定义：<br>BEV_EVENT_READING<br>  在bufferevent的读操作期间发生了事件。看其他标志以确定是哪个事件。<br>BEV_EVENT_WRITING<br>  在bufferevent的写操作期间发生了事件。看其他标志以确定是哪个事件。<br>BEV_EVENT_ERROR<br>  在bufferevent操作期间发生错误。要获取更多错误信息，请调用EVUTIL_SOCKET_ERROR()。<br>BEV_EVENT_TIMEOUT<br>  bufferevent超时。<br>BEV_EVENT_EOF<br>  我们在bufferevent上得到了EOF。<br>BEV_EVENT_CONNECTED<br>  我们完成了在bufferevent上请求的连接。<br>（以上事件名称在Libevent 2.0.2-alpha中是新的。）' },
    { EN: "", CN: '默认情况下，bufferevent的回调会立即执行。（evbuffer的回调也是如此；我们稍后再讨论这些。）当依赖关系变得复杂时，这种立即调用可能会引起麻烦。例如，假设有一个回调函数在evbuffer A变空时将数据移入，另一个回调函数在evbuffer A变满时处理数据。由于这些调用都是在栈上进行的，如果依赖关系变得足够复杂，你可能会冒着栈溢出的风险。' },
    { EN: "", CN: '为了解决这个问题，你可以告诉bufferevent（或evbuffer），其回调应该被延迟。当满足延迟回调的条件时，不会立即调用它，而是将其在event_loop()排队，并在常规event回调之后调用。' },
    { EN: "", CN: '（延迟回调功能在Libevent 2.0.1-alpha中引入。）' },
    { EN: "", CN: '在创建bufferevent时，你可以使用一个或多个标志来改变其行为。被识别的标志包括：<br>BEV_OPT_CLOSE_ON_FREE<br>  当bufferevent被释放时，关闭底层传输。这将关闭底层socket，释放底层bufferevent等。<br>BEV_OPT_THREADSAFE<br>  为bufferevent自动分配锁，这样它就可以安全地在多个线程中使用。<br>BEV_OPT_DEFER_CALLBACKS<br>  设置此标志后，bufferevent会延迟其所有回调，如上所述。<br>BEV_OPT_UNLOCK_CALLBACKS<br>  默认情况下，当bufferevent设置为线程安全时，调用用户提供的回调时，bufferevent都会被上锁。设置这个选项会使Libevent在调用用户回调时释放bufferevent的锁。' },
    { EN: "", CN: '（Libevent 2.0.5-beta引入了BEV_OPT_UNLOCK_CALLBACKS。上面的其他选项在Libevent 2.0.1-alpha中是新的。）' },
    { EN: "", CN: 'bufferevent中最简单的是基于socket的操作。基于socket的bufferevent使用Libevent的底层事件机制来检测底层网络socket何时准备好进行读取和/或写入操作，并使用底层网络调用（如readv、writev、WSASend或WSARecv）来传输和接收数据。' },
    { EN: "", CN: '你可以使用bufferevent_socket_new()创建一个基于socket的bufferevent：' },
    { EN: "", CN: '参数base是event_base，options是bufferevent的位掩码（BEV_OPT_CLOSE_ON_FREE等）。fd是可选的socket。如果你想稍后设置fd，可以将fd设置为-1。' },
    { EN: "", CN: '[确保提供给bufferevent_socket_new的socket处于非阻塞模式。Libevent提供了便捷方法evutil_make_socket_nonblocking来实现这一点。]' },
    { EN: "", CN: '此函数在成功时返回bufferevent，在失败时返回NULL。' },
    { EN: "", CN: 'bufferevent_socket_new()函数在Libevent 2.0.1-alpha中引入。' },
    { EN: "", CN: '如果bufferevent的socket尚未连接，你可以启动新的连接。' },
    { EN: "", CN: 'address和addrlen参数与标准调用connect()的参数相同。如果bufferevent尚未设置socket，调用此函数会为其分配一个新的tcp socket，并使其非阻塞。' },
    { EN: "", CN: '如果bufferevent已经有socket，调用bufferevent_socket_connect()会告诉Libevent socket未连接，在连接操作成功之前不应在socket上进行读取或写入操作。' },
    { EN: "", CN: '在连接完成之前向输出buffer添加数据是可以的 ！！！' },
    { EN: "", CN: '如果连接成功启动，此函数返回0；如果发生错误，返回-1。' },
    { EN: "", CN: 'bufferevent_socket_connect()函数在Libevent-2.0.2-alpha中引入。在此之前，你必须手动在你的socket上调用connect()，当连接完成时，bufferevent会将其报告为一个写入操作。' },
    { EN: "", CN: '请注意，只有在使用bufferevent_socket_connect()尝试connect()时，你才会收到BEV_EVENT_CONNECTED事件。如果你自己调用connect()，连接会被报告为一个写入操作。' },
    { EN: "", CN: '如果你想自己调用connect()，但仍然希望在连接成功时收到BEV_EVENT_CONNECTED事件，请在connect()返回-1且errno等于EAGAIN或EINPROGRESS之后调用bufferevent_socket_connect(bev, NULL, 0)。' },
    { EN: "", CN: '这个功能在Libevent 2.0.2-alpha中引入。' },
    { EN: "", CN: '很多时候，你可能希望将解析主机名和连接到它合并为单个操作。有一个接口可以做到这一点：' },
    { EN: "", CN: '这个函数解析DNS名称hostname，寻找类型为family的地址。（允许的family类型有AF_INET、AF_INET6和AF_UNSPEC。）如果解析失败，它会使用错误事件调用事件回调。如果成功，它会启动一个连接尝试，就像bufferevent_connect一样。' },
    { EN: "", CN: 'dns_base参数是可选的。如果它为NULL，那么Libevent在等待名称查找完成时会阻塞，这通常不是你想要的。如果提供了dns_base，则Libevent使用它来异步查找主机名。更多关于DNS的信息，请参见第R9章。' },
    { EN: "", CN: '与bufferevent_socket_connect()一样，这个函数告诉Libevent，bufferevent上的任何现有socket都未连接，在解析完成和连接操作成功之前不应在socket上进行读取或写入操作。' },
    { EN: "", CN: '如果发生错误，它可能是DNS主机名查找错误。你可以通过调用bufferevent_socket_get_dns_error()来查明错误。如果返回的错误代码是0，表示没有检测到DNS错误。' },
    { EN: "", CN: 'bufferevent_socket_connect_hostname() 函数在 Libevent 2.0.3-alpha 版本中首次引入；bufferevent_socket_get_dns_error() 函数在 2.0.5-beta 版本中新增。' },
    { EN: "", CN: '本节中的函数适用于多种bufferevent实现。' },
    { EN: "", CN: '这个函数释放bufferevent。Bufferevent在内部是通过引用计数的方式管理的，所以，如果在你释放它的时候bufferevent还有待处理的延迟回调，它不会被立即删除，直到这些回调处理完成。' },
    { EN: "", CN: '然而，bufferevent_free()函数确实尝试尽快释放bufferevent。如果bufferevent上还有待发送的数据，这些数据可能发不出去。' },
    { EN: "", CN: '如果设置了BEV_OPT_CLOSE_ON_FREE标志，并且这个bufferevent拥有socket，释放bufferevent时，该传输方式将被关闭。' },
    { EN: "", CN: '这个函数在Libevent 0.8版本中引入。' },
    { EN: "", CN: 'bufferevent_setcb()函数更改一个或多个bufferevent的回调。当读取到足够的数据、写入足够的数据，或发生某个事件时，分别调用readcb、writecb和eventcb函数。每个函数的第一个参数是发生事件的bufferevent。最后一个参数是用户在bufferevent_callcb()的cbarg参数中提供的值：你可以使用这个参数向回调传递数据。events参数是事件标志的位掩码：参见上文的“回调和水位”。' },
    { EN: "", CN: '你可以通过传递NULL来禁用回调，而不是传递回调函数。注意，bufferevent上的所有回调函数共享cbarg值，所以更改它会影响所有回调。' },
    { EN: "", CN: '你可以通过向bufferevent_getcb()传递指针来检索bufferevent的当前设置的回调，该函数会设置*readcb_ptr为当前的读取回调，*writecb_ptr为当前的写入回调，*eventcb_ptr为当前的事件回调，*cbarg_ptr为当前的回调参数字段。任何设置为NULL的指针都将被忽略。' },
    { EN: "", CN: 'bufferevent_setcb()函数在Libevent 1.4.4版本中引入。类型名“bufferevent_data_cb”和“bufferevent_event_cb”在Libevent 2.0.2-alpha版本中新增。bufferevent_getcb()函数在2.1.1-alpha中添加。' },
    { EN: "", CN: '你可以在bufferevent上启用或禁用EV_READ、EV_WRITE或EV_READ|EV_WRITE事件。当未启用读取或写入时，bufferevent不会尝试读取或写入数据。' },
    { EN: "", CN: '当输出buffer为空时，无需禁用写入：bufferevent会自动停止写入，并在有数据要写入时再次开始。' },
    { EN: "", CN: '同样，当输入缓冲区达到high-water mark，无需禁用读取：bufferevent会自动停止读取，并在有空间可读时再次开始。' },
    { EN: "", CN: '默认情况下，新创建的bufferevent启用了写入，但未启用读取。' },
    { EN: "", CN: '你可以调用bufferevent_get_enabled()来查看bufferevent上当前启用了哪些事件。' },
    { EN: "", CN: '这些函数在Libevent 0.8版本中引入，除了bufferevent_get_enabled()，它在2.0.3-alpha版本中引入。' },
    { EN: "", CN: 'bufferevent_setwatermark()函数调整单个bufferevent的读水位、写水位或两者。如果在events字段中设置了EV_READ，就调整读水位。如果设置了EV_WRITE，就调整写水位。' },
    { EN: "", CN: '高水位设置为0等同于“无限制”。' },
    { EN: "", CN: '这个函数最初在Libevent 1.4.4版本中公开。' },
    { EN: "", CN: '如果你无法查看网络中的数据，那么读取和写入数据就没有任何好处。缓冲事件为你提供了以下方法，用来传输要写入的数据，并获取要读取的数据：' },
    { EN: "", CN: '这两个函数非常强大且基础：它们分别返回输入和输出buffer。要了解可以在evbuffer类型上执行的所有操作的完整信息，请参阅下一章。' },
    { EN: "", CN: '请注意，应用程序只能从输入buffer删除（而不是添加）数据，且只能向输出buffer添加（而不是删除）数据。' },
    { EN: "", CN: '如果因为数据太少（或因为数据太多）而导致缓冲事件的写入被阻塞，那么向输出buffer添加数据（或从输入buffer移除数据）将自动重启它。' },
    { EN: "", CN: '这些功能在Libevent 2.0.1-alpha中引入。' },
    { EN: "", CN: '这些功能向bufferevent的输出缓冲区添加数据。调用bufferevent_write()会将数据内存中的size字节添加到输出buffer的末尾。调用bufferevent_write_buffer()会移除buf的全部内容，并将它们放在输出缓冲区的末尾。如果成功，两者都返回0，如果发生错误，则返回-1。' },
    { EN: "", CN: '这些功能自Libevent 0.8以来就存在。' },
    { EN: "", CN: '这些函数从bufferevent的输入buffer中移除数据。bufferevent_read()函数最多从输入buffer移除size字节，将它们存储到data中。它返回实际移除的字节数。bufferevent_read_buffer()函数排空输入buffer的全部内容，并将它们放入buf中；成功返回0，失败返回-1。' },
    { EN: "", CN: '请注意，使用bufferevent_read()时，data必须有足够的空间来存储size字节的数据。' },
    { EN: "", CN: 'bufferevent_read()函数自Libevent 0.8以来就存在；bufferevent_read_buffer()是在Libevent 2.0.1-alpha中引入的。' },
    { EN: "", CN: '与其他event一样，如果bufferevent在一定时间内没有成功写入或读取任何数据，你可以设置一个超时来触发。' },
    { EN: "", CN: '设置超时为NULL应该是为了移除它；然而，在Libevent 2.1.2-alpha之前，这并不适用于所有事件类型。（作为旧版本的一种解决方法，你可以尝试将超时设置为多日间隔和/或让你的eventcb函数忽略你不想要的BEV_TIMEOUT事件。）' },
    { EN: "", CN: '如果bufferevent尝试读取数据时至少等待了timeout_read秒，则会触发读取超时。如果bufferevent尝试写入数据时至少等待了timeout_write秒，则会触发写入超时。' },
    { EN: "", CN: '注意，只有当bufferevent想要读取或写入时，超时才会计算。换句话说，如果在bufferevent上禁用了读取，或者输入buffer已满（达到其高水位线），则不启用读取超时。同样，如果禁用了写入，或者没有数据可以写入，则不启用写入超时。' },
    { EN: "", CN: '当发生读取或写入超时时，对应的读取或写入操作在bufferevent上被禁用。然后将调用回调函数，参数为BEV_EVENT_TIMEOUT|BEV_EVENT_READING或BEV_EVENT_TIMEOUT|BEV_EVENT_WRITING。' },
    { EN: "", CN: '该功能自Libevent 2.0.1-alpha以来就存在。直到Libevent 2.0.4-alpha，它才在不同的缓冲事件类型之间表现一致。' },
    { EN: "", CN: '刷新bufferevent将强制尽可能多的字节被读取到或从底层传输中写入，忽略其他可能会阻止它们被写入的限制。其详细功能取决于缓冲事件的类型。' },
    { EN: "", CN: 'iotype参数应该是EV_READ、EV_WRITE或EV_READ|EV_WRITE，以指示是要处理正在读取、正在写入还是同时进行的字节。state参数可以是BEV_NORMAL、BEV_FLUSH或BEV_FINISHED之一。BEV_FINISHED指的是应该告诉对方不会再发送更多的数据；BEV_NORMAL与BEV_FLUSH之间的区别取决于bufferevent的类型。' },
    { EN: "", CN: 'bufferevent_flush()函数在失败时返回-1，在没有数据被刷新时返回0，如果有一些数据被刷新，则返回1。' },
    { EN: "", CN: '目前（截至Libevent 2.0.5-beta），bufferevent_flush()只针对某些类型的bufferevent实现。特别是，基于socket的bufferevent没有这个功能。' },
    { EN: "", CN: '这些函数并不支持所有类型的 bufferevent。' },
    { EN: "", CN: '这个函数调整 bufev 的优先级为 pri。关于优先级的更多信息，请参阅 event_priority_set()。' },
    { EN: "", CN: '这个函数成功时返回 0，在失败时返回 -1。它仅适用于基于socket的 bufferevents。' },
    { EN: "", CN: 'bufferevent_priority_set() 函数在 Libevent 1.0 中引入；bufferevent_get_priority() 直到 Libevent 2.1.2-alpha 才出现。' },
    { EN: "", CN: '这些函数为基于 fd 的事件设置或返回fd。只有基于socket的 bufferevents 支持 setfd()。两者在失败时都返回 -1；setfd() 在成功时返回 0。' },
    { EN: "", CN: 'bufferevent_setfd() 函数在 Libevent 1.4.4 中引入；bufferevent_getfd() 函数在 Libevent 2.0.2-alpha 中引入。' },
    { EN: "", CN: '此函数返回 bufferevent 的 event_base。它在 2.0.9-rc 中引入。' },
    { EN: "", CN: '此函数返回另一个 bufferevent 正在用作传输的 bufferevent（如果有的话）。关于何时会发生这种情况的信息，请参见"filtering bufferevent"的注释。' },
    { EN: "", CN: '这个函数在 Libevent 2.0.2-alpha 中引入。' },
    { EN: "", CN: '就像对 evbuffers 一样，有时您希望确保对 bufferevent 的一系列操作都能原子性地执行。Libevent 提供了一些函数，您可以使用它们来手动锁定和解锁  bufferevent。' },
    { EN: "", CN: '请注意，如果创建 bufferevent 时没有给予 BEV_OPT_THREADSAFE，或者如果没有激活 Libevent 的线程支持，锁定 bufferevent 是没有效果的。' },
    { EN: "", CN: '使用这个函数锁定 bufferevent 也会锁定其关联的 evbuffers。这些函数是递归的：对于已经持有锁再次对bufferevent上锁是安全的。当然，您必须为每次锁定 bufferevent 调用一次解锁。' },
    { EN: "", CN: '这些函数在 Libevent 2.0.6-rc 中引入。' },
    { EN: "", CN: '在 Libevent 1.4 到 Libevent 2.0 之间，bufferevent 后端代码经过了实质性的修订。在旧接口中，有时会正常构建对 struct bufferevent 内部的访问，并使用依赖此访问的宏。' },
    { EN: "", CN: '为了使问题变得复杂，旧代码有时会使用以 "evbuffer" 为前缀的 bufferevent 功能的名称。' },
    { EN: "", CN: '以下是 Libevent 2.0 之前的简要指南：' },
    { EN: "", CN: '旧函数是在 event.h 中定义的，而不是在 event2/bufferevent.h 中。' },
    { EN: "", CN: '如果您仍然需要访问 bufferevent struct 的公共部分的内部，您可以包含 event2/bufferevent_struct.h。我们不推荐这样做：struct bufferevent 的内容将在 Libevent 的不同版本之间改变。如果您包含了 event2/bufferevent_compat.h，本节中的宏和名称将可用。' },
    { EN: "", CN: '设置 bufferevent 在旧版本中有所不同：' },
    { EN: "", CN: 'bufferevent_new() 函数仅创建一个基于socket的 bufferevent，并且是基于不赞成使用的 event_base。调用 bufferevent_base_set 仅调整bufferevent 的 event_base。' },
    { EN: "", CN: '超时设置为秒数而不是struct timeval：' },
    { EN: "", CN: '最后，请注意，Libevent 2.0 之前版本的底层 evbuffer 实现效率非常低下，以至于对于高性能应用程序使用 bufferevents 有点令人质疑。' },
  ]
)


doTranslate(
  './public/Libevent_R6a_Bufferevents_advanced_topics.html',
  [
    { EN: "", CN: '本章节将介绍Libevent的bufferevent实现中一些高级功能，这些功能对于典型用途来说并不是必需的。如果你刚开始学习如何使用bufferevents，你现在应该跳过这一章，继续阅读evbuffer章节。' },
    { EN: "", CN: '有时你的程序需要与自身通信。例如，你的程序，用于通过某种协议隧道化连接用户，有时也希望通过该协议隧道化自己的连接。当然，你可以通过连接到自己的监听端口来实现这一点，但这样会通过网络堆栈让程序与自己通信而浪费资源。' },
    { EN: "", CN: '相反，你可以创建一对配对的bufferevents，这样在一端写入的所有字节都会在另一端接收到（反之亦然），但不使用任何实际的socket。' },
    { EN: "", CN: '调用bufferevent_pair_new()会将pair[0]和pair[1]设置为一对bufferevents，每个都连接到另一个。所有常见的选项都支持，除了BEV_OPT_CLOSE_ON_FREE无效，以及BEV_OPT_DEFER_CALLBACKS始终开启。' },
    { EN: "", CN: '为什么bufferevent对需要延迟执行回调？在对配对的元素进行操作时，通常会调用一个回调来改变bufferevent，从而调用另一个bufferevent的回调，如此通过许多步骤。当回调没有被延迟时，这一连串的调用会相当频繁地导致栈溢出、饿死其他连接，并且要求所有回调都是可重入的。' },
    { EN: "", CN: '配对的bufferevents支持刷新；将mode参数设置为BEV_NORMAL或BEV_FLUSH会强制将一对bufferevents中的一端的所有相关数据传输到另一端，忽略限制它的watermark。将mode设置为BEV_FINISHED还会在对面的bufferevent上生成一个EOF事件。' },
    { EN: "", CN: '释放任何一个成员不会自动释放另一个或生成EOF事件；它只会使配对中的另一个成员变得未链接。一旦bufferevent未链接，它将不再成功读取或写入数据或生成任何事件。' },
    { EN: "", CN: '有时候，你可能需要通过bufferevent对的一个来获取另一个。为了做到这一点，你可以调用bufferevent_pair_get_partner()函数。如果bev是对成对的，并且另一个成员仍然存在，它会返回对中的另一个成员。否则，它返回NULL。' },
    { EN: "", CN: 'Bufferevent对是在Libevent 2.0.1-alpha中新引入的功能；bufferevent_pair_get_partner()函数则是在Libevent 2.0.6中引入的。' },
    { EN: "", CN: '有时你想转换通过bufferevent对象传递的所有数据。你可以这样做来添加压缩层，或者封装一个协议。' },
    { EN: "", CN: 'bufferevent_filter_new()函数创建一个新的过滤bufferevent，围绕一个现有的"底层"bufferevent。通过底层bufferevent接收的所有数据都会在到达过滤bufferevent之前用"输入"过滤器进行转换，通过过滤bufferevent发送的所有数据都会在发送给底层bufferevent之前用一个"输出"过滤器进行转换。' },
    { EN: "", CN: '向底层bufferevent添加过滤器将替换底层bufferevent上的回调。你仍然可以向底层bufferevent的evbuffers添加回调，但如果你希望过滤器仍然工作，你就不能设置bufferevent本身的回调。' },
    { EN: "", CN: '输入过滤器和输出过滤器函数如上所述。所有常见的选项在options中都支持。如果设置了BEV_OPT_CLOSE_ON_FREE，则释放过滤bufferevent也会释放底层bufferevent。ctx字段是传递给过滤函数的任意指针；如果提供了free_context函数，在关闭过滤bufferevent之前将对ctx调用该函数。' },
    { EN: "", CN: '每当底层输入buffer有新的可读数据时，都会调用输入过滤器函数。每当过滤器的输出buffer有新的可写空间，都会调用输出过滤器函数。每个函数都会接收一对evbuffers：一个源evbuffer来读取数据，一个目的evbuffer来写入数据。dst_limit参数描述了添加到目的地的字节上限。过滤器函数被允许忽略此值，但这样做可能会违反high-water marks或速率限制。如果dst_limit是-1，则没有限制。mode参数告诉过滤器写入时的积极性。如果它是BEV_NORMAL，则它应该写尽可能多的能够方便转换的数据。BEV_FLUSH值意味着要写尽可能多，而BEV_FINISHED意味着过滤器函数还应该在流结束时做任何必要的清理工作。最后，过滤器函数的ctx参数是一个void指针，如同提供给bufferevent_filter_new()构造函数的一样。' },
    { EN: "", CN: '过滤器函数必须在成功将任何数据写入目的缓冲区时返回BEV_OK，如果没有更多的输入或使用不同的刷新模式就无法将更多数据写入目的缓冲区，则返回BEV_NEED_MORE，如果过滤器上有不可恢复的错误，则返回BEV_ERROR。' },
    { EN: "", CN: '创建过滤器会在底层bufferevent上启用读写功能。你不需要自己管理读/写：当过滤器不想读取时，它会为你暂停底层bufferevent上的读取。对于2.0.8-rc及之后的版本，允许独立于过滤器启用/禁用底层bufferevent上的读写。但如果你这样做，你可能会阻止过滤器成功获取它想要的数据。' },
    { EN: "", CN: '你不需要指定输入过滤器和输出过滤器：你省略的任何过滤器都会被替换为不转换数据就传递数据的过滤器。' },
    { EN: "", CN: '默认情况下，bufferevents在每次事件循环的调用中不会读取或写入最大可能的字节数；这样做可能会导致奇怪的不公平行为和资源饥饿。另一方面，默认设置可能并不适用于所有情况。' },
    { EN: "", CN: '这两个“set”函数分别替换当前的读取和写入最大值。如果size值为0或超过EV_SSIZE_MAX，它们会将最大值设置为默认值。这些函数在成功时返回0，在失败时返回-1。' },
    { EN: "", CN: '这两个“get”函数分别返回当前每次循环的读取和写入最大值。' },
    { EN: "", CN: '这些函数在2.1.1-alpha中被添加。' },
    { EN: "", CN: '一些程序希望限制单个bufferevent或一组bufferevent的带宽。Libevent 2.0.4-alpha和Libevent 2.0.5-alpha增加了一个基本功能，可以对单个bufferevent进行带宽上限限制，或将bufferevent分配到一个速率限制组中。' },
    { EN: "", CN: 'Libevent的速率限制使用一个令牌桶算法来决定一次读取或写入多少字节。每个速率限制对象在任何给定时间都有一个“读桶”和一个“写桶”，其大小决定了对象可以立即读取或写入多少字节。每个桶都有一个补充率、最大突发大小和一个时间单位或“tick”。每当时间单位过去，桶就会根据补充率按比例补充——但如果桶比其突发大小更满，任何超出的字节都会丢失。' },
    { EN: "", CN: '因此，补充率决定了对象发送或接收字节的最大平均速率，突发大小决定了在单次突发中将发送或接收的最大字节数。时间单位决定了流量的平滑度。' },
    { EN: "", CN: 'ev_token_bucket_cfg结构表示用于限制单个bufferevent或一组bufferevent的读写的一对令牌桶的配置值。要创建一个，调用ev_token_bucket_cfg_new函数并提供最大平均读取速率、最大读取突发、最大写入速率、最大写入突发和滴答的长度。如果tick_len参数为NULL，tick的长度默认为一秒。该函数可能在错误时返回NULL。' },
    { EN: "", CN: '请注意，read_rate和write_rate参数的单位是每个tick的字节。也就是说，如果tick是十分之一秒，而read_rate是300，那么最大平均读取速率是每秒3000字节。超过EV_RATE_LIMIT_MAX的速率和突发值不受支持。' },
    { EN: "", CN: '要限制bufferevent的传输速率，对其调用bufferevent_set_rate_limit()并使用一个ev_token_bucket_cfg。该函数成功时返回0，失败时返回-1。您可以给任意数量的bufferevent相同的ev_token_bucket_cfg。要移除bufferevent的速率限制，调用bufferevent_set_rate_limit()，并为cfg参数传递NULL。' },
    { EN: "", CN: '要释放一个ev_token_bucket_cfg，请调用ev_token_bucket_cfg_free()。请注意，直到没有bufferevent使用ev_token_bucket_cfg时，释放才是安全的。' },
    { EN: "", CN: '如果您想限制它们的总带宽使用量，您可以将bufferevent分配到一个速率限制组中。' },
    { EN: "", CN: '要构建一个速率限制组，请使用一个event_base和一个初始过的ev_token_bucket_cfg调用bufferevent_rate_limit_group()。您可以通过bufferevent_add_to_rate_limit_group()和bufferevent_remove_from_rate_limit_group()将bufferevent添加到组中或从组中移除；这些函数成功时返回0，错误时返回-1。' },
    { EN: "", CN: '单个bufferevent一次只能是一个速率限制组的成员。一个bufferevent可以同时有独立的速率限制（如通过bufferevent_set_rate_limit()设置）和组速率限制。当两个限制都设置时，bufferevent适用较低的限制。' },
    { EN: "", CN: '您可以通过调用bufferevent_rate_limit_group_set_cfg()来更改现有组的速率限制。它成功时返回0，失败时返回-1。bufferevent_rate_limit_group_free()函数释放一个速率限制组并移除其所有成员。' },
    { EN: "", CN: '截至2.0版，Libevent的组速率限制试图在总体上公平，但在非常小的时间尺度上实现可能不公平。如果您非常关心调度公平性，请通过补丁帮助未来版本。' },
    { EN: "", CN: '有时您的代码可能想检查bufferevent或组的当前速率限制。Libevent提供了一些函数来做到这一点。' },
    { EN: "", CN: '上述函数返回bufferevent或组的读或写令牌桶的当前大小，单位是字节。请注意，如果bufferevent被迫超出其分配，则这些值可以是负数。（刷新bufferevent可以做到这一点。）' },
    { EN: "", CN: '这些函数返回bufferevent现在愿意读取或写入的字节数，考虑到适用于bufferevent、其速率限制组（如果有的话），以及Libevent作为一个整体的任何最大一次读取/写入值。' },
    { EN: "", CN: '每个bufferevent_rate_limit_group跟踪它发送的总字节数。您可以使用此功能来跟踪组中多个bufferevent的总使用量。在组上调用bufferevent_rate_limit_group_get_totals()会将*total_read_out和*total_written_out设置为分别在bufferevent组上读取和写入的总字节数。这些总数在创建组时从0开始，并且每当在一个组上调用bufferevent_rate_limit_group_reset_totals()时重置为0。' },
    { EN: "", CN: '对于复杂需求的程序，您可能希望调整令牌桶的值。例如，如果您的程序以不通过bufferevent的方式生成流量。' },
    { EN: "", CN: '这些功能减少了bufferevent或速率限制组中当前的读或写桶。请注意，递减是有符号的：如果您想增加一个桶，请传递一个负值。' },
    { EN: "", CN: '通常，您不希望在速率限制组中给所有bufferevent平均分配速率。例如，如果您有10,000个活跃的bufferevent在一个速率限制组中，每个tick有10,000字节可用于写入，由于系统调用和TCP头部的开销，让每个bufferevent每个tick只写1字节是不高效的。' },
    { EN: "", CN: '为了解决这个问题，每个速率限制组都有一个“最小份额”的概念。在上述情况下，不是每个bufferevent每个tick都被允许写入1字节，而是10,000/SHARE的bufferevent被允许每个tick写入SHARE字节，其余的则不允许写入。每个tick中首先允许哪些bufferevent写入是随机选择的。' },
    { EN: "", CN: '默认的最小份额是为了提供良好的性能，并且目前（截至2.0.6-rc）设置为64。您可以使用以下函数调整这个值：' },
    { EN: "", CN: '将min_share设置为0将完全禁用最小份额。' },
    { EN: "", CN: 'Libevent的速率限制自引入以来就有最小份额。更改它们的函数是在Libevent 2.0.6-rc首次公开的。' },
    { EN: "", CN: '截至Libevent 2.0版，您应该知道速率限制实现有一些局限性。<br>- 并非每一种bufferevent类型都能很好地或完全支持速率限制。<br>- Bufferevent速率限制组不能嵌套，且一个bufferevent一次只能在一个速率限制组中。<br>- 速率限制实现仅将TCP数据包中传输的字节计为数据，不包括TCP头部。<br>- 读取限制实现依赖于TCP堆栈，应用程序仅以特定速率消费数据，并在其缓冲区变满时对TCP连接的另一侧施加压力。<br>- 某些bufferevents实现（特别是Windows IOCP实现）可能会超额。<br>- 桶在开始时有一个完整tick流量。这意味着bufferevent可以立即开始读取或写入，而不必等待完整的tick通过。然而，这也意味着，一个已经被限制为N.1 tick的bufferevent可以潜在地传输N+1 tick的流量。<br>- tick不能小于1毫秒，所有小于1毫秒的分数都会被忽略。' },
    { EN: "", CN: '/// todo：写一个关于速率限制的示例' },
    { EN: "", CN: 'bufferevent 可以使用OpenSSL库来实现SSL/TLS安全传输层。因为许多应用程序不需要或不想链接OpenSSL，这个功能被实现在一个独立的库中，安装时称为"libevent_openssl"。未来的Libevent版本可能会增加对其他SSL/TLS库如NSS或GnuTLS的支持，但现在只有OpenSSL。' },
    { EN: "", CN: '在Libevent 2.0.3-alpha中引入了OpenSSL功能，尽管在Libevent 2.0.5-beta或Libevent 2.0.6-rc之前它的工作表现并不理想。' },
    { EN: "", CN: '本节不是关于OpenSSL，SSL/TLS或一般加密技术的教程。' },
    { EN: "", CN: '这些函数都在头文件"event2/bufferevent_ssl.h"中声明。' },
    { EN: "", CN: '你可以创建两种类型的SSL bufferevent：一种基于过滤器的bufferevent，通过另一个底层bufferevent进行通信，或者是一个基于socket的bufferevent，告诉OpenSSL直接通过网络进行通信。在任何一种情况下，你都必须提供一个SSL对象和对SSL对象状态的描述。如果SSL当前作为客户端进行协商，则状态应为BUFFEREVENT_SSL_CONNECTING；如果SSL当前作为服务器，则为BUFFEREVENT_SSL_ACCEPTING；或者如果SSL握手已完成，则为BUFFEREVENT_SSL_OPEN。' },
    { EN: "", CN: '通常的选项：BEV_OPT_CLOSE_ON_FREE使得SSL对象和底层的fd或bufferevent在openssl bufferevent本身关闭时被关闭。' },
    { EN: "", CN: '一旦握手完成，新的bufferevent的事件回调将被调用，并在标志中带有BEV_EVENT_CONNECTED。' },
    { EN: "", CN: '如果你正在创建一个基于socket的bufferevent，并且SSL对象已经设置了一个socket，你不需要自己提供套接字：只需传递-1。你也可以稍后用bufferevent_setfd()设置fd。' },
    { EN: "", CN: '/// TODO：一旦bufferevent_shutdown() API完成后删除此项。' },
    { EN: "", CN: '请注意，当在SSL bufferevent上设置了BEV_OPT_CLOSE_ON_FREE时，SSL连接上不会执行干净的关闭。这有两个问题：首先，连接会看起来像是被对方"断开"的，而不是被干净地关闭：对方将无法判断是你关闭了连接，还是它被攻击者或第三方破坏了。其次，OpenSSL会将会话视为"坏的"，并从会话缓存中移除。这可能会在负载下的SSL应用程序上造成显著的性能下降。' },
    { EN: "", CN: '目前唯一的解决方法是手动进行懒惰的SSL关闭。虽然这违反了TLS RFC，但它将确保一旦关闭，会话将保留在缓存中。以下代码实现了这种解决方法。' },
    { EN: "", CN: '这个函数返回由OpenSSL bufferevent使用的SSL对象，如果bev不是基于OpenSSL的bufferevent，则返回NULL。' },
    { EN: "", CN: '这个函数返回给定bufferevent操作的第一个挂起的OpenSSL错误，如果没有挂起错误，则返回0。错误格式与openssl库中的ERR_get_error()返回的格式相同。' },
    { EN: "", CN: '调用这个函数告诉SSL重新协商，并且bufferevent调用相应的回调。这是一个高级主题；除非你真的知道你在做什么，通常应该避免它，尤其是因为许多SSL版本已知存在与重新协商相关的安全问题。' },
    { EN: "", CN: '优秀的SSL版本（即SSLv3和所有TLS版本）都支持经过验证的关闭操作，它使得双方能够区分有意的关闭和意外或恶意引起的底层缓冲终止。默认情况下，我们将除了正确的关闭之外的任何事情视为连接上的错误。然而，如果将allow_dirty_shutdown标志设置为1，我们将在连接中的关闭视为BEV_EVENT_EOF。' },
    { EN: "", CN: 'allow_dirty_shutdown函数在Libevent 2.1.1-alpha中被添加。' },
    { EN: "", CN: 'Libevent的内置线程机制不覆盖OpenSSL锁。由于OpenSSL使用了大量的全局变量，你仍然必须配置OpenSSL以确保线程安全。虽然这个过程不在Libevent的范围内，但这个话题被足够多地提及，值得进行讨论。' },
  ]
)


doTranslate(
  './public/Libevent_R7_Evbuffers_utility_functionality_for_buffered_IO.html',
  [
    { EN: "", CN: 'Libevent的evbuffer功能实现了字节队列，针对从末尾添加数据和从前端移除数据进行了优化。' },
    { EN: "", CN: 'Evbuffers旨在通用地执行网络IO的“缓冲”部分。它们不提供用于调度IO或在IO准备就绪时触发IO的函数：这是bufferevents的工作。' },
    { EN: "", CN: '除非另有说明，本章中的函数都声明在event2/buffer.h中。' },
    { EN: "", CN: '这些函数应该相对明确：evbuffer_new() 会分配并返回一个新的空evbuffer，而evbuffer_free() 则会删除一个evbuffer以及其所有内容。' },
    { EN: "", CN: '这些函数自Libevent 0.8版以来一直存在。' },
    { EN: "", CN: '默认情况下，同时从多个线程访问evbuffer是不安全的。如果你需要这样做，你可以在evbuffer上调用evbuffer_enable_locking()。如果其lock参数为NULL，Libevent将使用evthread_set_lock_creation_callback分配一个新锁。否则，它将使用该参数作为锁。' },
    { EN: "", CN: 'evbuffer_lock() 和 evbuffer_unlock() 函数分别获取和释放evbuffer上的锁。你可以使用它们使一组操作成为原子操作。如果没有在evbuffer上启用锁定，这些函数不会执行任何操作。' },
    { EN: "", CN: '（注意，你不需要在单个操作周围调用evbuffer_lock() 和 evbuffer_unlock()：如果在evbuffer上启用了锁，单个操作已经是原子的。只有当你有多个需要执行的操作，且不希望其他线程介入时，你才需要手动锁定evbuffer。）' },
    { EN: "", CN: '这些函数都是在Libevent 2.0.1-alpha中引入的。' },
    { EN: "", CN: '这个函数返回存储在evbuffer中的字节数。' },
    { EN: "", CN: '它在Libevent 2.0.1-alpha中被引入。' },
    { EN: "", CN: '这个函数返回evbuffer顶部存储的字节数。evbuffer中的数据可能被存储在多个分开的内存块中；这个函数返回第一个块中存储的字节数。' },
    { EN: "", CN: '它在Libevent 2.0.1-alpha中被引入。' },
    { EN: "", CN: '这个函数将datlen字节的数据添加到buf的末尾。成功时返回0，失败时返回-1。' },
    { EN: "", CN: '这些函数将格式化数据添加到buf的末尾。格式参数和其他剩余参数被处理，就像由C库函数"printf"和"vprintf"分别处理一样。函数返回追加的字节数。' },
    { EN: "", CN: '这个函数修改缓冲区中的最后一个内存块，或添加一个新的内存块，以使缓冲区足够大，可以在不进行任何进一步分配的情况下包含datlen字节。' },
    { EN: "", CN: 'evbuffer_add() 和 evbuffer_add_printf() 函数在Libevent 0.8中引入；evbuffer_expand() 在Libevent 0.9中引入，而evbuffer_add_vprintf() 首次出现在Libevent 1.1中。' },
    { EN: "", CN: '为了提高效率，Libevent对从一个evbuffer移动数据到另一个evbuffer有专门的优化。' },
    { EN: "", CN: 'evbuffer_add_buffer() 函数将所有数据从src移动到dst的末尾。成功时返回0，失败时返回-1。' },
    { EN: "", CN: 'evbuffer_remove_buffer() 函数从src移动datlen字节的数据到dst的末尾，尽可能少地复制。如果src的字节数少于datlen，它将移动所有的字节。它返回移动的字节数。' },
    { EN: "", CN: '我们在Libevent 0.8中引入了evbuffer_add_buffer()；evbuffer_remove_buffer() 在Libevent 2.0.1-alpha中是新功能。' },
    { EN: "", CN: '这些函数的行为类似于evbuffer_add()和evbuffer_add_buffer()，不同之处在于它们将数据移动到目标缓冲区的前端。' },
    { EN: "", CN: '这些函数应谨慎使用，且永远不要在与bufferevent共享的evbuffer上使用。它们在Libevent 2.0.1-alpha中是新功能。' },
    { EN: "", CN: '有时你想要查看evbuffer前端的N个字节数据，并将其视为一个连续的字节数组。要做到这一点，你首先必须确保缓冲区的前端确实是连续的。' },
    { EN: "", CN: 'evbuffer_pullup()函数“线性化”buf的前size字节，必要时通过复制或移动它们来确保它们都是连续的，并占据相同的内存块。如果size为负数，该函数将线性化整个缓冲区。如果size大于缓冲区中的字节数，函数返回NULL。否则，evbuffer_pullup()返回指向buf中第一个字节的指针。' },
    { EN: "", CN: '使用较大的size调用evbuffer_pullup()可能会相当慢，因为它可能需要复制整个缓冲区的内容。' },
    { EN: "", CN: '调用evbuffer_pullup()时，size如果等于evbuffer_get_contiguous_space()不会导致任何数据被复制或移动。' },
    { EN: "", CN: 'evbuffer_pullup()函数在Libevent 2.0.1-alpha中是新功能：之前的Libevent版本总是保持evbuffer数据连续，不管成本如何。' },
    { EN: "", CN: 'evbuffer_remove()函数将buf前端的前datlen字节数据复制并移除，放到data中。如果可用字节数少于datlen，那么函数会复制所有可用的字节。失败返回-1，在其他情况下返回复制的字节数。' },
    { EN: "", CN: 'evbuffer_drain()函数的行为类似于evbuffer_remove()，区别在于它不复制数据：它只是将数据从缓冲区前端移除。成功时返回0，失败时返回-1。' },
    { EN: "", CN: 'Libevent 0.8引入了evbuffer_drain()；evbuffer_remove()出现在Libevent 0.9中。' },
    { EN: "", CN: '有时候，你希望在不清空数据的情况下，获取缓冲区开始处的数据副本。例如，你可能想要检查完整记录是否已经到达，而不需要移除任何数据（如evbuffer_remove所做的那样），或者内部重新排列缓冲区（如evbuffer_pullup()所做的那样）。' },
    { EN: "", CN: 'evbuffer_copyout()的行为就像evbuffer_remove()，但不会从缓冲区中移除任何数据。也就是说，它会将buf前端的前datlen字节复制到data中。如果可用的字节数少于datlen，函数将复制所有可用的字节。失败时返回-1，在其他情况下是复制的字节数。' },
    { EN: "", CN: 'evbuffer_copyout_from()函数的行为类似于evbuffer_copyout()，但它不是从缓冲区的前端复制字节，而是从pos位置开始复制。有关evbuffer_ptr结构的信息，请参阅下面的“在evbuffer内搜索”。' },
    { EN: "", CN: '如果从缓冲区复制数据太慢，使用evbuffer_peek()代替。' },
    { EN: "", CN: 'evbuffer_copyout()函数首次出现在Libevent 2.0.5-alpha中；evbuffer_copyout_from()在Libevent 2.1.1-alpha中被添加。' },
    { EN: "", CN: '许多互联网协议使用基于行的格式。evbuffer_readln()函数从evbuffer的前端提取一行，并将其以NUL结尾的字符串返回。如果n_read_out不是NULL，*n_read_out被设置为返回的字符串中的字节数。如果没有完整的行可以读取，则该函数返回NULL。复制的字符串中不包括行终止符。' },
    { EN: "", CN: 'evbuffer_readln()函数理解4种行终止格式：<br>EVBUFFER_EOL_LF<br>  一行的结束是单个换行符。（这也被称为"\n"。它的ASCII值是0x0A。）<br>EVBUFFER_EOL_CRLF_STRICT<br>  一行的结束是一个回车符，后跟一个换行符。（这也被称为"\r\n"。ASCII值是0x0D 0x0A。）<br>EVBUFFER_EOL_CRLF<br>  行的结束是一个可选的回车符，后跟一个换行符。（换句话说，它可以是"\r\n"或"\n"）。这种格式在解析基于文本的互联网协议时非常有用，因为标准通常规定一个"\r\n"作为行终结符，但不符合标准的客户端有时只使用"\n"。<br>EVBUFFER_EOL_ANY<br>  行的结束是任意数量的回车符和换行符序列。这种格式不是很有用；它主要存在是为了向后兼容。<br>EVBUFFER_EOL_NUL<br>  行的结束是一个值为0的单字节 —— 也就是，一个ASCII NUL。<br>（请注意，如果你使用event_set_mem_functions()覆盖默认的malloc，那么由evbuffer_readln返回的字符串将由你指定的malloc替换函数分配。）' },
    { EN: "", CN: 'evbuffer_readln()接口在Libevent 1.4.14-stable及以后版本中可用。EVBUFFER_EOL_NUL在Libevent 2.1.1-alpha中被添加。' },
    { EN: "", CN: 'evbuffer_ptr结构指向evbuffer中的一个位置，并包含可用于遍历evbuffer的数据。' },
    { EN: "", CN: 'pos字段是唯一的公开字段；其他字段不应由用户使用。它表示在evbuffer中的位置，作为从起始处的偏移。' },
    { EN: "", CN: 'evbuffer_search()函数扫描缓冲区以寻找len字符长的字符串what。它返回一个包含字符串位置的evbuffer_ptr，如果找不到字符串则返回-1。如果提供了start参数，搜索应从该位置开始；否则，搜索从字符串的开头开始。' },
    { EN: "", CN: 'evbuffer_search_range()函数的行为类似于evbuffer_search，不同之处在于它只只搜索到end位置。' },
    { EN: "", CN: 'evbuffer_search_eol()函数检测行尾，类似于evbuffer_readln()，但不是复制行，而是返回一个指向行尾字符(s)开始的evbuffer_ptr。如果eol_len_out非NULL，它被设置为EOL字符串的长度。' },
    { EN: "", CN: 'evbuffer_ptr_set函数操纵evbuffer_ptr pos在buffer内的位置。如果how是EVBUFFER_PTR_SET，则指针被移动到缓冲区内的绝对位置position。如果是EVBUFFER_PTR_ADD，则指针向前移动position字节。此函数成功时返回0，失败时返回-1。' },
    { EN: "", CN: '任何修改evbuffer或其布局的调用会使所有未完成的evbuffer_ptr值无效，并使它们不安全。' },
    { EN: "", CN: '这些接口是在Libevent 2.0.1-alpha中新增的。' },
    { EN: "", CN: '有时候，您可能想要在不复制数据（如evbuffer_copyout()所做的）以及不重新排列evbuffer的内部内存（如evbuffer_pullup()所做的）的情况下，阅读evbuffer中的数据。有时您可能想要查看evbuffer中间的数据。' },
    { EN: "", CN: '您可以通过以下方式实现：' },
    { EN: "", CN: '当您调用evbuffer_peek()时，您需要在vec_out中提供一个evbuffer_iovec结构的数组。数组的长度是n_vec。它设置这些结构，使每一个都包含一个指向evbuffer内部RAM的指针（iov_base），以及在该块内设置的内存长度。' },
    { EN: "", CN: '如果len小于0，evbuffer_peek()尝试填充您提供的所有evbuffer_iovec结构。否则，它会填充它们，直到它们都被使用，或者至少len字节。如果函数能够给您所有请求的数据，它返回它实际使用的evbuffer_iovec结构的数量。否则，它返回为了满足您的请求需要的数量。' },
    { EN: "", CN: '当ptr为NULL时，evbuffer_peek()从缓冲区的开头开始。否则，它从ptr的位置开始。<br>- 修改evbuffer_iovec指向的数据可能会导致未定义行为。<br>- 如果调用任何修改evbuffer的函数，evbuffer_peek()产生的指针可能会变无效。<br>- 如果您的evbuffer可能在多个线程中使用，请确保在调用evbuffer_peek()之前使用evbuffer_lock()对其进行锁定，并在使用完后解锁。' },
    { EN: "", CN: '此函数是在Libevent 2.0.2-alpha中新增的。' },
    { EN: "", CN: '有时候，您希望直接将数据插入到evbuffer中，而不是首先将其写入字符数组然后再使用evbuffer_add()复制进来。有一对高级函数可以让您做到这一点：evbuffer_reserve_space()和evbuffer_commit_space()。与evbuffer_peek()一样，这些函数使用evbuffer_iovec结构直接访问evbuffer内部的内存。' },
    { EN: "", CN: 'evbuffer_reserve_space()函数为您提供了指向evbuffer内部空间的指针。它根据需要扩展缓冲区，以给您提供至少size字节的空间。这些范围的指针及其长度将存储在vec中；n_vec是此数组的长度。' },
    { EN: "", CN: 'n_vec的值必须至少为1。如果您只提供一个向量，那么Libevent将确保您在单个范围内拥有所请求的所有连续空间，但它可能不得不重新排列缓冲区或浪费内存才能做到这一点。为了获得更好的性能，请提供至少2个向量。该函数返回它为您请求的空间所需的向量数量。' },
    { EN: "", CN: '在您调用evbuffer_commit_space()之前，您写入这些向量的数据并不属于缓冲区的一部分，调用后，实际上使您写入的数据才在缓冲区内。如果您想提交的空间小于您请求的空间，您可以减少evbuffer_iovec结构的iov_len字段。您也可以传递更少的向量。evbuffer_commit_space()函数成功时返回0，失败时返回-1。<br>- 调用任何重排evbuffer或向其添加数据的函数将使您从evbuffer_reserve_space()获得的指针失效。<br>- 在当前实现中，无论用户提供多少向量，evbuffer_reserve_space()永远不会使用超过两个向量。这可能在未来的版本中改变。<br>- 多次调用evbuffer_reserve_space()是安全的。<br>- 如果您的evbuffer可能在多个线程中使用，请确保在调用evbuffer_reserve_space()之前使用evbuffer_lock()对其进行锁定，并在提交后解锁。' },
    { EN: "", CN: '这些函数自Libevent 2.0.2-alpha起就以其现有接口存在。' },
    { EN: "", CN: '在Libevent中，evbuffers最常见的用例是网络IO。在evbuffer上执行网络IO的接口是：' },
    { EN: "", CN: 'evbuffer_read()函数从socket fd读取最多howmuch字节的数据到buffer的末端。成功时返回读取的字节数，EOF时返回0，错误时返回-1。请注意，错误可能表示非阻塞操作无法成功；您需要检查错误代码是否为EAGAIN（或在Windows上的WSAEWOULDBLOCK）。如果howmuch是负数，evbuffer_read()会尝试自己猜测要读取多少数据。' },
    { EN: "", CN: 'evbuffer_write_atmost()函数尝试从buffer的前端向socket fd写入最多howmuch字节的数据。成功时返回写入的字节数，失败时返回-1。与evbuffer_read()一样，您需要检查错误代码以确定错误是真实的还是仅表明非阻塞IO无法立即完成。如果您为howmuch提供了一个负值，我们会尝试写入buffer的全部内容。' },
    { EN: "", CN: '调用evbuffer_write()与调用带有负howmuch参数的evbuffer_write_atmost()相同：它尝试flush尽可能多的数据。' },
    { EN: "", CN: '在Unix上，这些函数应该也适用于任何支持读和写的fd上。在Windows上，只支持socket。' },
    { EN: "", CN: '请注意，当您使用bufferevents时，您不需要调用这些IO函数；bufferevents代码会为您做。' },
    { EN: "", CN: 'evbuffer_write_atmost()函数在Libevent 2.0.1-alpha中引入。' },
    { EN: "", CN: '使用evbuffers的用户经常希望知道何时有数据被添加到evbuffer中或从中删除。为支持这一需求，Libevent提供了通用的evbuffer回调机制。' },
    { EN: "", CN: '每当数据被添加到evbuffer中或从中删除时，就会调用一个evbuffer回调。它接收缓冲区、指向evbuffer_cb_info结构的指针以及用户提供的参数。evbuffer_cb_info结构的orig_size字段记录了在其大小发生变化之前缓冲区上有多少字节；n_added字段记录了添加到缓冲区的字节数，n_deleted字段记录了从缓冲区删除的字节数。' },
    { EN: "", CN: 'evbuffer_add_cb()函数向evbuffer添加一个回调，并返回一个不透明指针，该指针稍后可用于引用这个特定的回调实例。cb参数是将被调用的函数，cbarg是用户提供的指针，用于传递给该函数。' },
    { EN: "", CN: '你可以在单个evbuffer上设置多个回调。添加新回调不会移除旧回调。' },
    { EN: "", CN: '顺便提一下，释放非空的evbuffer并不算作从中排空数据，释放evbuffer也不会释放其回调的用户提供的数据指针。' },
    { EN: "", CN: '如果你不希望回调在缓冲区上永久激活，你可以移除它（永久消除），或禁用它（暂时关闭）：' },
    { EN: "", CN: '你可以删除回调通过evbuffer_cb_entry的返回值，或者通过回调和指针来移除回调。evbuffer_remove_cb()函数成功返回0，失败返回-1。' },
    { EN: "", CN: 'evbuffer_cb_set_flags()函数和evbuffer_cb_clear_flags()函数分别使给定回调上的给定标志被设置或清除。目前，只支持一个对用户可见的标志：EVBUFFER_CB_ENABLED。该标志默认设置。当它被清除时，对evbuffer的修改不会导致回调。' },
    { EN: "", CN: '与bufferevent回调一样，你可以使evbuffer回调在evbuffer改变时不立即运行，而是延迟并作为base的event loop的一部分运行。这可能会有所帮助,如果你有多个evbuffers，其回调可能导致数据互相被添加和删除，而你希望避免堆栈被破坏时。' },
    { EN: "", CN: '如果一个evbuffer的回调被延迟，那么当它们最终被调用时，它们可能会总结多个操作的结果。' },
    { EN: "", CN: '像bufferevents一样，evbuffers在内部是引用计数的，因此即使它有尚未执行的延迟回调，释放evbuffer也是安全的。' },
    { EN: "", CN: '整个回调系统是在Libevent 2.0.1-alpha中新增的。evbuffer_cb_(set|clear)_flags()函数自从2.0.2-alpha以来就存在' },
    { EN: "", CN: '进行真正快速的网络编程经常要求尽可能少地进行数据复制。Libevent提供了一些机制来帮助实现这一点。' },
    { EN: "", CN: '这个函数通过引用将一块数据添加到evbuffer的末尾。不执行复制：相反，evbuffer仅仅存储一个指向datlen字节的、存储在data处的指针。因此，只要evbuffer正在使用该指针，指针就必须保持有效。当evbuffer不再需要data时，它会调用提供的“cleanupfn”函数，并将提供的“data”指针、“datlen”值和“extra”指针作为参数。此函数成功返回0，失败返回-1。' },
    { EN: "", CN: 'evbuffer_add_reference()函数自从2.0.2-alpha以来就有了其现在的接口。' },
    { EN: "", CN: '某些操作系统提供了将文件发送到网络而无需将数据复制到用户空间的方法。在可用的情况下，您可以通过以下简单的接口访问这些机制：' },
    { EN: "", CN: '`evbuffer_add_file()` 函数假定它有一个可用于读取的打开的fd（这次不是socket！）。它将文件中从偏移量`offset`开始的`length`字节添加到输出的末尾。成功时返回0，失败时返回-1。' },
    { EN: "", CN: '在Libevent 2.0.x中，唯一可靠的使用这种方式添加数据的方法是使用`evbuffer_write*()`将其发送到网络，使用`evbuffer_drain()`排空它，或者使用`evbuffer_*_buffer()`将其移动到另一个evbuffer中。您不能可靠地使用`evbuffer_remove()`从缓冲区中提取它，使用`evbuffer_pullup()`线性化它等等。Libevent 2.1.x尝试解决这个限制。' },
    { EN: "", CN: '如果您的操作系统支持`splice()`或`sendfile()`，当调用`evbuffer_write()`时，Libevent将使用它直接从fd将数据发送到网络，完全不需要将数据复制到用户RAM中。如果不存在`splice/sendfile`，但您有`mmap()`，Libevent将`mmap`文件，您的内核可以识别它（希望能识别）不需要将数据复制到用户空间。否则，Libevent将从磁盘读取数据到RAM中。' },
    { EN: "", CN: 'fd将在数据从evbuffer中刷新或evbuffer被释放后关闭。如果这不是您想要的，或者如果您希望对文件有更细粒度的控制，请参阅下面的`file_segment`功能。' },
    { EN: "", CN: '这个函数在Libevent 2.0.1-alpha中引入。' },
    { EN: "", CN: '`evbuffer_add_file()` 接口在多次添加同一个文件时效率低下，因为它获取了文件的所有权。' },
    { EN: "", CN: '`evbuffer_file_segment_new()` 函数创建并返回一个新的evbuffer_file_segment对象，以表示存储在`fd`中的底层文件的一部分，该文件从`offset`开始并包含`length`字节。错误时，它返回NULL。' },
    { EN: "", CN: '文件段是使用sendfile、splice、mmap、CreateFileMapping或malloc()-and-read()实现的，具体取决于适用情况。它们使用支持的最轻量级机制创建，并根据需要过渡到更重的机制。（例如，如果您的操作系统支持sendfile和mmap，那么文件段可以仅使用sendfile实现，直到您尝试实际检查其内容。那时，它需要被mmap()。）您可以使用这些标志控制文件段的细粒度行为：<br>EVBUF_FS_CLOSE_ON_FREE<br>  如果设置了此标志，使用`evbuffer_file_segment_free()`释放文件段将关闭底层文件。<br>EVBUF_FS_DISABLE_MMAP<br>  如果设置了此标志，即使这是适当的，文件段也永远不会使用映射内存风格的后端（CreateFileMapping、mmap）。<br>EVBUF_FS_DISABLE_SENDFILE<br>  如果设置了此标志，即使这是适当的，文件段也永远不会使用sendfile风格的后端（sendfile、splice）。<br>EVBUF_FS_DISABLE_LOCKING<br>  如果设置了此标志，将不会为文件段分配锁：在任何多线程可能会看到文件段的方式中，使用它都将不安全。' },
    { EN: "", CN: '一旦您有了一个evbuffer_file_segment，您可以使用`evbuffer_add_file_segment()`将它的全部或部分添加到一个evbuffer中。这里的`offset`参数指的是文件段内的偏移量，而不是文件本身内的偏移量。' },
    { EN: "", CN: '当您不再想使用文件段时，您可以使用`evbuffer_file_segment_free()`将其释放。实际的存储不会被释放，直到没有任何evbuffer再持有对文件段的一部分的引用。' },
    { EN: "", CN: '您可以向文件段添加一个回调函数，当对文件段的最后一个引用被释放并且文件段即将被释放时，将调用此回调函数。此回调不能尝试复活文件段，不能将其添加到任何缓冲区，等等。' },
    { EN: "", CN: '这些文件段函数首次出现在Libevent 2.1.1-alpha中；`evbuffer_file_segment_add_cleanup_cb()` 在2.1.2-alpha中添加。' },
    { EN: "", CN: '您还可以通过引用将一个evbuffer的内容添加到另一个evbuffer中：与其移除一个缓冲区的内容并将它们添加到另一个缓冲区中，不如给一个evbuffer提供对另一个的引用，它的行为就好像您已经复制了所有字节一样。' },
    { EN: "", CN: '`evbuffer_add_buffer_reference()` 函数的行为就好像您已经将所有数据从outbuf复制到inbuf，但不执行任何不必要的复制。成功时返回0，失败时返回-1。' },
    { EN: "", CN: '请注意，对inbuf内容的后续更改不会反映在outbuf中：此函数按引用添加evbuffer的当前内容，而不是evbuffer本身。' },
    { EN: "", CN: '还请注意，您不能嵌套buffer引用：已经作为一个`evbuffer_add_buffer_reference`调用的outbuf不能成为另一个调用的inbuf。' },
    { EN: "", CN: '这个函数在Libevent 2.1.1-alpha中引入。' },
    { EN: "", CN: '您可以使用这些函数来临时禁止对evbuffer的前端或后端进行更改。bufferevent代码在内部使用它们，以防止意外修改输出缓冲区的前端或输入缓冲区的后端。' },
    { EN: "", CN: '`evbuffer_freeze()` 函数在Libevent 2.0.1-alpha中引入。' },
    { EN: "", CN: '在Libevent 2.0中，evbuffer接口发生了很多变化。在此之前，每个evbuffer都是作为一段连续的RAM实现的，这使得访问非常低效。' },
    { EN: "", CN: 'event.h头文件过去曾公开暴露struct evbuffer的内部结构。这些现在不再可用；它们在1.4和2.0之间变化太大，依赖它们的任何代码都无法工作。' },
    { EN: "", CN: '为了访问evbuffer中的字节数，曾经有一个`EVBUFFER_LENGTH()`宏。实际数据可以通过`EVBUFFER_DATA()`获得。这两个都在event2/buffer_compat.h中可用。不过要注意：`EVBUFFER_DATA(b)`是`evbuffer_pullup(b, -1)`的别名，这可能非常耗费资源。' },
    { EN: "", CN: '一些其他已弃用的接口是：' },
    { EN: "", CN: '`evbuffer_readline()`函数的工作方式类似于当前的`evbuffer_readln(buffer, NULL, EVBUFFER_EOL_ANY)`。' },
    { EN: "", CN: '`evbuffer_find()`函数会在缓冲区中搜索字符串的第一次出现，并返回一个指向它的指针。与`evbuffer_search()`不同的是，它只能找到第一个字符串。为了保持与使用此函数的旧代码的兼容性，它现在将整个缓冲区进行线性化。' },
    { EN: "", CN: '回调接口也不同：' },
    { EN: "", CN: '一个evbuffer一次只能设置一个回调，因此设置新的回调会禁用之前的回调，并且设置NULL回调是禁用回调的首选方法。' },
    { EN: "", CN: '回调函数不是接收一个evbuffer_cb_info结构，而是接收evbuffer的旧长度和新长度。因此，如果old_len大于new_len，则数据被取出。如果new_len大于old_len，则添加了数据。不能推迟回调，因此添加和删除永远不会批量到单个回调调用中。' },
    { EN: "", CN: '这里的过时函数仍然可以在event2/buffer_compat.h中找到。' },
  ]
)


doTranslate(
  './public/Libevent_R8_Connection_listeners_accepting_TCP_connections.html',
  [
    { EN: "", CN: 'evconnlistener机制为您提供了一种方法用于监听和接受传入TCP连接。' },
    { EN: "", CN: '本节中的所有函数和类型都在event2/listener.h中声明。它们首次出现在Libevent 2.0.2-alpha版本中，除非另有说明。' },
    { EN: "", CN: '两个`evconnlistener_new*()`函数都用于分配并返回一个新的连接监听器对象。一个连接监听器使用event_base来侦测在给定监听socket上是否有新的TCP连接。当有新连接到来时，它会调用你提供的回调函数。' },
    { EN: "", CN: '在这两个函数中，参数base是一个event_base，监听器将使用它来监听连接。回调函数cb在接收到新连接时被调用；如果cb为NULL，监听器被视为禁用，直到设置了回调。指针ptr将被传递给回调函数。参数flags控制监听器的行为——下文将进一步说明。参数backlog控制pending状态的的socket的最大数量；具体细节请查看你系统中listen()函数的文档。如果backlog是负数，Libevent会尝试为backlog选择一个合适的值；如果它是零，Libevent假定你已经在提供的socket上调用了listen()。' },
    { EN: "", CN: '这些函数在设置监听socket上的区别是：`evconnlistener_new()`函数假定你已经绑定了一个socket到你想要监听的端口，并且你正通过fd作为参数传递这个socket。如果你想让Libevent自己分配并绑定到一个socket，请调用`evconnlistener_new_bind()`，并传入你想要绑定的sockaddr及其长度。' },
    { EN: "", CN: '【当使用`evconnlistener_new`时，确保你的监听socket处于非阻塞模式，可以通过使用`evutil_make_socket_nonblocking`或手动设置正确的socket选项来实现。当监听socket保留在阻塞模式下，可能会发生未定义的行为。】' },
    { EN: "", CN: '要释放listener，请将其传递给`evconnlistener_free()`。' },
    { EN: "", CN: '以下是你可以传递给`evconnlistener_new()`函数flags参数的标志。你可以传递任意数量的这些标志，将它们用OR逻辑运算符连接起来。<br>`LEV_OPT_LEAVE_SOCKETS_BLOCKING`<br>  默认情况下，当监听socket接受一个新的传入socket时，它会将它设置为非阻塞模式，以便你可以使用Libevent的其他功能。如果你不希望这样，请设置这个标志。<br>`LEV_OPT_CLOSE_ON_FREE`<br>  如果设置了这个选项，当你释放连接监听器时，它会关闭其底层socket。<br>`LEV_OPT_CLOSE_ON_EXEC`<br>  如果设置了这个选项，连接socket在底层监听socket上设置close-on-exec标志。更多信息请查看你的平台关于fcntl和FD_CLOEXEC的文档。<br>`LEV_OPT_REUSEABLE`<br>  默认情况下，在某些平台上，一旦监听socket关闭，直到一段时间过去后，其他socket才能绑定到同一个端口。设置这个选项可以使Libevent标记该socket为可重用，这样一旦它关闭，另一个socket就可以打开来监听同一个端口。<br>`LEV_OPT_THREADSAFE`<br>  为监听器分配锁，使得它可以安全地在多个线程中使用。在Libevent 2.0.8-rc中新增。<br>`LEV_OPT_DISABLED`<br>  初始化监听器为禁用状态，而不是启用状态。你可以通过`evconnlistener_enable()`手动开启它。在Libevent 2.1.1-alpha中新增。<br>`LEV_OPT_DEFERRED_ACCEPT`<br>  如果可能，告诉内核不要宣布socket已被接受，直到在它们上面接收到一些数据，并且它们准备好读取。如果你的协议不是从客户端开始传输数据，那么不要使用这个选项，因为在这种情况下，这个选项有时会导致内核永远不会告诉你有关连接的信息。并非所有操作系统都支持这个选项：在不支持的操作系统上，这个选项没有效果。在Libevent 2.1.1-alpha中新增。' },
    { EN: "", CN: '当接收到新连接时，将调用提供的回调函数。参数listener是接收到连接的连接监听器。参数sock是新的socket。参数addr和len分别是连接接收到的地址及该地址的长度。参数ptr是传递给`evconnlistener_new()`的用户提供的指针。' },
    { EN: "", CN: '这些函数临时禁止或重新启用监听新连接。' },
    { EN: "", CN: '这个函数调整现有evconnlistener的回调和回调参数。它在2.0.9-rc中引入。' },
    { EN: "", CN: '这些函数分别返回一个监听器关联的socket和event_base。' },
    { EN: "", CN: 'evconnlistener_get_fd()函数首次出现在Libevent 2.0.3-alpha中。' },
    { EN: "", CN: '你可以设置一个错误回调，每当监听器上的accept()调用失败时，它会被告知。如果你遇到一个错误条件，除非你处理它，否则可能会锁定进程，因此做这样的设置很重要。' },
    { EN: "", CN: '如果你使用evconnlistener_set_error_cb()来设置监听器上的错误回调，那么每次监听器上发生错误时，都会调用该回调。它将接收监听器作为其第一个参数，以及传递给evconnlistener_new()的ptr作为其第二个参数。' },
    { EN: "", CN: '这个函数在Libevent 2.0.8-rc中引入。' },
  ]
)


doTranslate(
  './public/Libevent_R9_Using_DNS_with_Libevent_high_and_low-level_functionality.html',
  [
    { EN: "", CN: 'Libevent 提供了一些用于解析 DNS 名称的 API，以及用于实现简单 DNS 服务器的实现。 设施 -> 实现' },
    { EN: "", CN: '我们将首先描述用于名称查找的高级实现，然后描述底层和服务器实现。' },
    { EN: "", CN: 'Libevent 当前 DNS 客户端实现中存在已知的局限性。它不支持 TCP 查找、DNSSec 或任意记录类型。我们希望在 Libevent 的未来版本中修复所有这些问题，但就目前而言，这些功能还未实现。' },
    { EN: "", CN: '为了帮助那些已经使用阻塞式名称解析的程序进行移植，Libevent 提供了一个标准 getaddrinfo() 接口的可移植实现。这在你的程序需要在没有 getaddrinfo() 函数的平台上运行，或者平台上的 getaddrinfo() 函数不符合标准的情况下很有帮助。（令人震惊的是这样的情况很多。）' },
    { EN: "", CN: 'getaddrinfo() 接口在 RFC 3493 的第 6.1 节中有规定。请参阅下面的“Compatibility Notes”部分，了解我们与符合标准实现的差距。' },
    { EN: "", CN: 'evutil_getaddrinfo() 函数试图根据你在 hints 中给出的规则解析提供的 nodename 和 servname 字段，并为你构建一个 evutil_addrinfo 结构的链表，并将它们存储在 *res 中。成功时返回 0，失败时返回非零错误代码。' },
    { EN: "", CN: '你必须至少提供 nodename 和 servname 中的一个。如果提供了 nodename，它可以是一个字面的 IPv4 地址（如 "127.0.0.1"）、一个字面的 IPv6 地址（如 "::1"）或一个 DNS 名称（如 "www.example.com"）。如果提供了 servname，它可以是网络服务的符号名称（如 "https"）或包含十进制端口号的字符串（如 "443"）。' },
    { EN: "", CN: '如果你没有指定 servname，那么 *res 中的端口值将被设置为零。如果你没有指定 nodename，那么 *res 中的地址要么是 localhost（默认情况下），要么是“any”（如果设置了 EVUTIL_AI_PASSIVE）。' },
    { EN: "", CN: 'hints 中的 ai_flags 字段告诉 evutil_getaddrinfo 如何执行查找。它可以包含下面列出的一个或多个标志，通过 OR 运算组合在一起。<hr>EVUTIL_AI_PASSIVE<hr>  这个标志表明我们将使用地址进行监听，而不是用于连接。通常这没有什么区别，除非 nodename 为NULL：对于连接，空的 nodename 是 localhost（127.0.0.1 或 ::1），而监听时，空的 nodename 是 ANY（0.0.0.0 或 ::0）。<hr>EVUTIL_AI_CANONNAME<hr>  如果设置了这个标志，我们会尝试在 ai_canonname 字段中报告主机的规范名称。<hr>EVUTIL_AI_NUMERICHOST<hr>  设置这个标志时，我们只解析数字的 IPv4 和 IPv6 地址；如果 nodename 需要名称查找，我们会返回 EVUTIL_EAI_NONAME 错误。<hr>EVUTIL_AI_NUMERICSERV<hr>  设置这个标志时，我们只解析数字服务名称。如果 servname 既不是 NULL 也不是十进制整数，返回 EVUTIL_EAI_NONAME 错误。<hr>EVUTIL_AI_V4MAPPED<hr>  这个标志表示，如果 ai_family 是 AF_INET6 并且没有找到 IPv6 地址，结果中的任何 IPv4 地址应该作为 v4 映射的 IPv6 地址返回。除非操作系统支持，否则 evutil_getaddrinfo() 当前不支持它。<hr>EVUTIL_AI_ALL<hr>  如果同时设置了这个标志和 EVUTIL_AI_V4MAPPED，那么结果中的 IPv4 地址会作为 v4 映射的 IPv6 地址包含在结果中，不管是否有 IPv6 地址。除非操作系统支持，否则 evutil_getaddrinfo() 当前不支持它。<hr>EVUTIL_AI_ADDRCONFIG<hr>  如果设置了这个标志，那么只有当系统具有非本地 IPv4 地址时，结果中才包括 IPv4 地址，并且只有当系统具有非本地 IPv6 地址时，结果中才包括 IPv6 地址。' },
    { EN: "", CN: 'hints 中的 ai_family 字段用于告诉 evutil_getaddrinfo() 它应该返回哪些地址。它可以是 AF_INET 来仅请求 IPv4 地址，AF_INET6 来仅请求 IPv6 地址，或者 AF_UNSPEC 来请求所有可用地址。' },
    { EN: "", CN: 'hints 中的 ai_socktype 和 ai_protocol 字段用于告诉 evutil_getaddrinfo() 你将如何使用地址。它们与你传递给 socket() 的 socktype 和 protocol 字段相同。' },
    { EN: "", CN: '如果 evutil_getaddrinfo() 成功，它会分配一个新的 evutil_addrinfo 结构的链表，每个结构通过它的 "ai_next" 指针指向下一个，并将它们存储在 *res 中。因为这个值是在堆上分配的，你需要使用 evutil_freeaddrinfo 来释放它。' },
    { EN: "", CN: '如果失败，它会返回以下一个数值错误代码：<br>EVUTIL_EAI_ADDRFAMILY<br>  你请求了一个对于 nodename 没有意义的地址族。<br>EVUTIL_EAI_AGAIN<br>  名称解析中有一个可恢复的错误；稍后再试。<br>EVUTIL_EAI_FAIL<br>  名称解析中有一个不可恢复的错误；你的解析器或 DNS 服务器可能出问题了。<br>EVUTIL_EAI_BADFLAGS<br>  hints 中的 ai_flags 字段无效。<br>EVUTIL_EAI_FAMILY<br>  hints 中的 ai_family 字段不支持。<br>EVUTIL_EAI_MEMORY<br>  在尝试回答你的请求时我们耗尽了内存。<br>EVUTIL_EAI_NODATA<br>  你询问的主机存在，但没有与之相关的地址信息。（或者，它没有你请求的类型的地址信息。）<br>EVUTIL_EAI_NONAME<br>  你询问的主机似乎不存在。<br>EVUTIL_EAI_SERVICE<br>  你询问的服务似乎不存在。<br>EVUTIL_EAI_SOCKTYPE<br>  我们不支持你请求的socket类型，或者它与 ai_protocol 不兼容。<br>EVUTIL_EAI_SYSTEM<br>  在名称解析过程中出现了其他系统错误。检查 errno 以获取更多信息。<br>EVUTIL_EAI_CANCEL<br>  应用程序请求在 DNS 查找完成之前取消它。evutil_getaddrinfo() 函数永远不会产生这个错误，但它可能来自 evdns_getaddrinfo()，如下面的章节所述。' },
    { EN: "", CN: '你可以使用 evutil_gai_strerror() 将这些结果之一转换为人类可读的字符串。' },
    { EN: "", CN: '注意：如果你的操作系统定义了 struct addrinfo，则 evutil_addrinfo 只是你的操作系统内置结构的别名。类似地，如果你的操作系统定义了任何 AI_* 标志，那么对应的 EVUTIL_AI_* 标志只是本地标志的别名；如果你的操作系统定义了任何 EAI_* 错误，那么相应的 EVUTIL_EAI_* 代码与你的平台的本地错误代码相同。' },
    { EN: "", CN: '这些函数和常量在 Libevent 2.0.3-alpha 中是新的。它们在 event2/util.h 中声明。' },
    { EN: "", CN: '常规的getaddrinfo()接口以及上述的evutil_getaddrinfo()的主要问题在于它们是阻塞的：当你调用它们时，你所在的线程必须等待它们查询DNS服务器并等待响应。由于你正在使用Libevent，这可能不是你想要的行为。' },
    { EN: "", CN: '因此，为了非阻塞使用，Libevent提供了一系列函数来发起DNS请求，并使用Libevent等待服务器回应。' },
    { EN: "", CN: 'evdns_getaddrinfo()函数的行为就像evutil_getaddrinfo()一样，不同之处在于它不是在DNS服务器上阻塞，而是使用Libevent的低级DNS实现为你查找主机名。因为它不能总是立即返回结果，你需要为它提供一个类型为evdns_getaddrinfo_cb的回调函数，以及一个可选的用户提供的该回调函数的参数。' },
    { EN: "", CN: '此外，你需要为evdns_getaddrinfo()提供一个evdns_base。这个结构体保存了Libevent DNS解析器的状态和配置。更多信息请参阅下一节。' },
    { EN: "", CN: '如果evdns_getaddrinfo()函数失败或立即成功，它将返回NULL。否则，它将返回一个指向evdns_getaddrinfo_request的指针。在请求完成之前，你可以随时使用evdns_getaddrinfo_cancel()来取消该请求。' },
    { EN: "", CN: '注意，无论evdns_getaddrinfo()是否返回NULL，以及是否调用了evdns_getaddrinfo_cancel()，最终都会调用回调函数。' },
    { EN: "", CN: '当你调用evdns_getaddrinfo()时，它会对其nodename、servname和hints参数做自己的内部副本：你不需要确保它们在名称查找进行时继续存在。' },
    { EN: "", CN: '这些函数是在Libevent 2.0.3-alpha中新增的。它们在event2/dns.h中声明。' },
    { EN: "", CN: '在你可以使用evdns进行非阻塞DNS查找之前，你需要配置一个evdns_base。每个evdns_base存储了一个域名服务器列表、DNS配置选项，并跟踪活动的和执行中的DNS请求。' },
    { EN: "", CN: 'evdns_base_new()函数在成功时返回一个新的evdns_base，在失败时返回NULL。如果initialize参数为1，它将尝试根据你的操作系统默认设置合理地配置base。如果它为0，它将留下一个空的evdns_base，没有配置任何域名服务器或选项。' },
    { EN: "", CN: '当你不再需要一个evdns_base时，你可以用evdns_base_free来释放它。如果其fail_requests参数为真，它将在释放base之前使所有执行中的请求调用其回调函数，并带有一个 canceled 的错误代码。' },
    { EN: "", CN: '如果你想对evdns_base的初始化过程有更多控制，你可以将initialize参数设为0传递给evdns_base_new，并且调用以下其中一个函数。' },
    { EN: "", CN: 'evdns_base_resolv_conf_parse()函数会扫描保存在filename中的resolv.conf格式的文件，并从中读取所有在flags中列出的选项。（关于resolv.conf文件的更多信息，请参见你本地的Unix手册页。）<br>DNS_OPTION_SEARCH<br>  指示evdns从resolv.conf文件读取域名和搜索字段以及ndots选项，并使用它们来决定搜索哪些域名（如果有的话）来解析不是完全合格的主机名。<br>DNS_OPTION_NAMESERVERS<br>  这个标志告诉evdns从resolv.conf文件中学习域名服务器。<br>DNS_OPTION_MISC<br>  指示evdns从resolv.conf文件设置其他配置选项。<br>DNS_OPTION_HOSTSFILE<br>  指示evdns在加载resolv.conf文件时从/etc/hosts读取主机列表。<br>DNS_OPTIONS_ALL<br>  告诉evdns从resolv.conf文件中尽可能多地学习。' },
    { EN: "", CN: '在Windows上，你没有resolv.conf文件来告诉你域名服务器在哪里，所以你可以使用evdns_base_config_windows_nameservers()函数从你的注册表中读取所有的域名服务器（或者你的NetworkParams，或者它们被隐藏的任何地方）。' },
    { EN: "", CN: 'resolv.conf文件格式' },
    { EN: "", CN: '我们识别的resolv.conf格式是一个文本文件，每一行要么是空的，要么包含一个以#字符开始的注释，或者由一个标记和零个或多个参数组成。我们识别的标记有：<br>nameserver<br>  必须跟着一个域名服务器的IP地址。作为扩展，Libevent允许你指定一个非标准端口给域名服务器，使用IP:Port或者[IPv6]:port语法。<br>domain<br>  本地域名。<br>search<br>  解析本地主机名时要搜索的名称列表。任何名称如果点的数量少于"ndots"，则被认为是本地的，如果我们不能按原样解析它，我们就会在这些域名中寻找。例如，如果"search"是example.com并且"ndots"是1，那么当用户让我们解析"www"时，我们会考虑"www.example.com"。<br>options<br>  由空格分隔的选项列表。每个选项要么作为一个简单字符串给出，要么（如果它带有参数）以option:value格式给出。识别的选项是：<br>  ndots:INTEGER<br>    用于配置搜索。见上面的"search"。默认为1。<br>  timeout:FLOAT<br>    我们等待来自DNS服务器响应的时间有多长。默认为5秒。<br>  max-timeouts:INT<br>    我们允许一个域名服务器连续超时多少次。默认为3次。<br>  max-inflight:INT<br>    我们允许同时有多少DNS请求等待中？（如果我们尝试的请求超过这个数量，额外的请求将会暂停，直到先前的请求得到回答或超时。）默认为64。<br>  attempts:INT<br>    在我们放弃一个DNS请求之前，我们重新传输多少次。默认为3次。<br>  randomize-case:INT<br>    如果非零，则我们在发送DNS请求时随机化大小写，并确保回复具有与我们的请求相同的大小写。这种所谓的"0x20 hack"可以帮助防止一些简单的DNS活动攻击。默认为1。<br>  bind-to:ADDRESS<br>    如果提供，我们每次向域名服务器发送数据包时都会绑定到给定的地址。在Libevent 2.0.4-alpha之后，它只适用于随后的域名服务器条目。<br>  initial-probe-timeout:FLOAT<br>    当我们决定一个域名服务器已经宕机时，我们会以指数递减的频率探测它，看它是否已经恢复。此选项配置系列中的第一个超时时间，以秒为单位。默认为10秒。<br>  getaddrinfo-allow-skew:FLOAT<br>    当evdns_getaddrinfo()同时请求IPv4地址和IPv6地址时，它会在单独的DNS请求数据包中进行，因为有些服务器不能在一个数据包中处理两个请求。一旦它得到了一种地址类型的答案，它会稍等一会儿看看另一种地址类型的答案是否会到来。此选项配置等待多长时间，以秒为单位。默认为3秒。' },
    { EN: "", CN: '不被识别的标记和选项将被忽略。' },
    { EN: "", CN: '如果你想对evdns的行为有更细粒度的控制，你可以使用这些函数：' },
    { EN: "", CN: 'evdns_base_nameserver_sockaddr_add()函数通过其地址向现有的evdns_base添加一个域名服务器。flags参数目前被忽略，并且应该为了向前兼容而设为0。函数成功时返回0，失败时返回负值。（它在Libevent 2.0.7-rc中被加入。）' },
    { EN: "", CN: 'evdns_base_nameserver_ip_add函数向现有的evdns_base添加一个域名服务器。它接受文本字符串中的域名服务器，可以是IPv4地址、IPv6地址、带端口的IPv4地址（IPv4:Port）或带端口的IPv6地址（[IPv6]:Port）。成功时返回0，失败时返回负值。' },
    { EN: "", CN: 'evdns_base_load_hosts()函数从hosts_fname加载一个hosts文件（与/etc/hosts的格式相同）。它也在成功时返回0，在失败时返回负值。' },
    { EN: "", CN: 'evdns_base_search_clear()函数移除evdns_base中所有当前的搜索后缀（由search选项配置）；evdns_base_search_add()函数添加一个后缀。' },
    { EN: "", CN: 'evdns_base_set_option()函数在evdns_base中为给定的选项设置给定的值。每个都以字符串形式给出。（在Libevent 2.0.3之前，选项名称需要在其后面有一个冒号。）' },
    { EN: "", CN: '如果你刚刚解析了一组配置文件并想知道是否添加了任何域名服务器，你可以使用evdns_base_count_nameservers()来查看有多少个。' },
    { EN: "", CN: '有几个函数你可以用来为evdns模块指定库级别的设置：' },
    { EN: "", CN: '由于历史原因，evdns子系统执行自己的日志记录；你可以使用evdns_set_log_fn()给它一个回调，用来处理它的消息，而不是丢弃它们。' },
    { EN: "", CN: '出于安全考虑，evdns需要一个良好的随机数来源：它使用这个来挑选难以猜测的交易ID并在使用0x20 hack时随机化查询。（有关"randomize-case"选项的更多信息，请参阅这里。）然而，旧版本的Libevent并没有提供自己的安全RNG。你可以通过调用evdns_set_transaction_id_fn并给它一个函数来给evdns一个更好的随机数生成器，该函数返回一个难以预测的两字节无符号整数。' },
    { EN: "", CN: '在Libevent 2.0.4-alpha及以后版本中，Libevent使用自己内置的安全RNG；evdns_set_transaction_id_fn()没有效果。' },
    { EN: "", CN: '偶尔，您会希望能够发起具有比evdns_getaddrinfo()提供的更细粒度控制的特定DNS请求。Libevent提供了一些接口来实现这一点。' },
    { EN: "", CN: '目前，Libevent的DNS支持缺少一些您期望从低级DNS系统中找到的功能，例如对任意请求类型和TCP请求的支持。如果您需要evdns没有的功能，请考虑贡献一个补丁。您也可以考虑使用更完整的DNS库，如c-ares。' },
    { EN: "", CN: '这些解析函数开始对特定记录的DNS请求初始化。每个函数都接受一个evdns_base用于请求，一个要查找的资源（前向查找的主机名或反向查找的地址），一组标志来确定如何进行查找，一个在查找完成时调用的回调函数，以及一个传递给用户提供的回调函数的指针。' },
    { EN: "", CN: 'flags参数是0或DNS_QUERY_NO_SEARCH，用于否定搜索列表如果原始搜索失败。DNS_QUERY_NO_SEARCH对于反向查找没有效果，因为反向查找从不进行搜索。' },
    { EN: "", CN: '当请求完成——不论是成功还是失败——回调函数将被调用。回调接受一个结果，表示成功或一个错误代码（见下面的DNS错误表），一个记录类型（DNS_IPv4_A、DNS_IPv6_AAAA或DNS_PTR之一），地址中的记录数量，以秒为单位的生存时间，地址本身，以及用户提供的参数指针。' },
    { EN: "", CN: '如果发生错误，回调中的地址参数为NULL。对于PTR记录，它是一个NUL结尾的字符串。对于IPv4记录，它是网络顺序的四字节值数组。对于IPv6记录，它是网络顺序的16字节记录数组。（注意，即使没有错误，地址数量也可以是0。当名称存在，但没有请求类型的记录时，就会发生这种情况。）' },
    { EN: "", CN: '可以传递给回调的错误代码如下：' },
    { EN: "", CN: '（DNS_ERR_NODATA在2.0.15-stable中是新加的。）' },
    { EN: "", CN: '您可以使用以下接口将这些错误代码解码为可读字符串：' },
    { EN: "", CN: '每个解析函数返回一个指向不透明evdns_request结构的指针。您可以使用此结构在回调被调用之前的任何时点取消请求：' },
    { EN: "", CN: '用这个函数取消一个请求会使其调用回调并附带DNS_ERR_CANCEL。' },
    { EN: "", CN: '有时候，您可能希望重新配置或关闭DNS子系统，而不会过多影响正在进行中的DNS请求。' },
    { EN: "", CN: '如果您在一个evdns_base上调用evdns_base_clear_nameservers_and_suspend()，所有的域名服务器都会被移除，而挂起的请求会处于不确定状态，直到您稍后重新添加域名服务器并调用evdns_base_resume()。' },
    { EN: "", CN: '这些函数成功时返回0，失败时返回-1。它们在Libevent 2.0.1-alpha中引入。' },
    { EN: "", CN: 'Libevent提供了简单的功能，用作一个简单的DNS服务器并响应UDP DNS请求。' },
    { EN: "", CN: '这一部分假设你对DNS协议有一定的了解。' },
    { EN: "", CN: '要开始监听DNS请求，请调用evdns_add_server_port_with_base()。它需要一个event_base来处理事件；一个用于监听的UDP socket；一个标志变量（目前始终为0）；当接收到新的DNS查询时调用的回调函数；以及一个将传递给回调的用户数据指针。它返回一个新的evdns_server_port对象。' },
    { EN: "", CN: '当您完成DNS服务器的使用时，可以将其传递给evdns_close_server_port()。' },
    { EN: "", CN: 'evdns_add_server_port_with_base()函数是在2.0.1-alpha中新增的；evdns_close_server_port()则是在1.3中引入的。' },
    { EN: "", CN: '不幸的是，Libevent目前没有提供一个很好的程序化接口来检查DNS请求。相反，你只能包含event2/dns_struct.h并手动检查evdns_server_request结构。' },
    { EN: "", CN: '如果未来版本的Libevent能提供一个更好的方式来做这件事，那将是极好的。' },
    { EN: "", CN: '请求中的flags字段包含请求设置的DNS标志；nquestions字段是请求的数量；questions是指向struct evdns_server_question的指针数组。每个evdns_server_question包括请求的资源类型（下面有一个列表，列出了EVDNS_*_TYPE宏），请求的类别（通常是EVDNS_CLASS_INET），以及所请求的主机名。' },
    { EN: "", CN: '这些结构是在Libevent 1.3中引入的。在Libevent 1.4之前，dns_question_class被称为"class"，这给C++使用者造成了麻烦。那些仍然使用旧的"class"名字的C程序将在未来的版本中停止工作。' },
    { EN: "", CN: '有时你可能想知道是哪个地址发出了特定的DNS请求。你可以通过对它调用evdns_server_request_get_requesting_addr()来检查。你应该传入一个足够存储地址的sockaddr：建议使用struct sockaddr_storage。' },
    { EN: "", CN: '这个函数是在Libevent 1.3c中引入的。' },
    { EN: "", CN: '每次你的DNS服务器收到一个请求时，这个请求都会被传递给你提供的回调函数，以及你的user_data指针。回调函数必须响应请求、忽略请求，或确保请求最终被回答或忽略。' },
    { EN: "", CN: '在你响应一个请求之前，你可以向你的响应中添加一个或多个答案：' },
    { EN: "", CN: '以上函数都在DNS回复中为请求req添加了一个单独的资源记录（RR）（分别是类型A、AAAA或CNAME）。在每种情况下，name参数是要添加答案的主机名，ttl是答案的生存时间值，以秒为单位。对于A和AAAA记录，n是要添加的地址数量，addrs是指向原始地址的指针，要么是A记录中IPv4地址的n*4字节序列，要么是AAAA记录中IPv6地址的n*16字节序列。' },
    { EN: "", CN: '这些函数成功时返回0，失败时返回-1。' },
    { EN: "", CN: '这个函数在请求的答案部分添加一个PTR记录。req和ttl的参数如上所述。你必须准确地提供in（一个IPv4地址）或inaddr_name（一个.arpa域中的地址）中的一个，以表明你正在为哪个地址提供响应。hostname参数是PTR查找的答案。' },
    { EN: "", CN: '这个函数为请求req的DNS回复添加了一个任意的资源记录（RR）。section参数描述了要将其添加到的部分，并且应该是EVDNS_*_SECTION值中的一个。name参数是RR的name字段。type参数是RR的type字段，如果可能的话，应该是EVDNS_TYPE_*值中的一个。dns_class参数是RR的class字段，通常应该是EVDNS_CLASS_INET。ttl参数是RR的生存时间，单位是秒。RR的rdata和rdlength字段将由提供的datalen字节的data生成。如果is_name为真，则数据会被编码为DNS名称（即，使用DNS名称压缩）。否则，它会按原样包含。' },
    { EN: "", CN: 'evdns_server_request_respond()函数发送一个DNS响应给一个请求，包括所有你附加到它的RR，以及错误代码err。如果你收到了一个你不想响应的请求，你可以通过在它上面调用evdns_server_request_drop()来释放所有关联的内存和结构。' },
    { EN: "", CN: '如果你想在你的响应消息上设置任何标志，你可以在发送响应之前的任何时候调用这个函数。' },
    { EN: "", CN: '本节中的所有函数都是在Libevent 1.3中引入的，除了evdns_server_request_set_flags()，它是在Libevent 2.0.1-alpha中首次出现的。' },
    { EN: "", CN: '调用 evdns_base_search_ndots_set() 等同于使用带有 "ndots" 选项的 evdns_base_set_option()。' },
    { EN: "", CN: 'evdns_base_nameserver_add() 函数的行为类似于 evdns_base_nameserver_ip_add()，不同之处在于它只能添加具有IPv4地址的名称服务器。它以一种特殊的方式接收它们，即以网络顺序的四个字节。' },
    { EN: "", CN: '在Libevent 2.0.1-alpha之前，无法为DNS服务器端口指定 event_base。你必须使用 evdns_add_server_port()，它采用默认的event_base。' },
    { EN: "", CN: '从Libevent 2.0.1-alpha到2.0.3-alpha，你可以使用 evdns_set_random_bytes_fn 来指定用于生成随机数的函数，而不是 evdns_set_transaction_id_fn。现在，由于Libevent提供其自己的安全随机数生成器（RNG），它不再有任何作用。' },
    { EN: "", CN: 'DNS_QUERY_NO_SEARCH 标志也被称为 DNS_NO_SEARCH。' },
    { EN: "", CN: '在Libevent 2.0.1-alpha之前，没有单独的 evdns_base 概念：evdns 子系统中的所有信息都被全局存储，操作它的函数不接受 evdns_base 作为参数。它们现在都已被弃用，并且只在 event2/dns_compat.h 中声明。它们通过一个单一的全局 evdns_base 实现；你可以通过在Libevent 2.0.3-alpha中引入的 evdns_get_global_base() 函数访问这个base。' },
    { EN: "", CN: '如果且仅当 evdns_config_windows_nameservers() 可用时，才会定义 EVDNS_CONFIG_WINDOWS_NAMESERVERS_IMPLEMENTED 宏。' },
  ]
)


doTranslate(
  './public/Libevent_R10_Using_the_built-in_HTTP_server.html',
  [
    { EN: "The plain network-based Libevent interface is usefu", CN: 'Libevent的简单网络接口在您想要构建原生应用程序时很有用，但基于HTTP协议和加载页面的网络应用程序的开发日渐普遍，这种页面通常会动态地重新加载信息。' },
    { EN: "To use the Libevent service", CN: '要使用Libevent服务，您可以使用已经描述的主网络事件模型的相同基本结构，但是不需要处理网络接口，HTTP包装器会为您处理。HTTP包装器将整个过程转变为四个函数调用（初始化、启动HTTP服务器、设置HTTP回调函数、进入事件循环），加上回调函数的内容，该函数将发送数据回来。在列表中提供了一个非常简单的示例：' },
    { EN: 'Given the previous example', CN: '基于前面的例子，这里的代码基础应该相对容易理解。主要元素包括evhttp_set_gencb()函数，其设置了在接收到HTTP请求时要使用的回调函数，以及generic_request_handler()回调函数本身，它用一个简单的消息填充响应缓冲区以显示成功。' },
    { EN: 'The HTTP wrapper provides a wealth of different functionality', CN: 'HTTP包装器提供了丰富的不同功能。例如，有一个请求解析器，它会从典型请求中提取查询参数（就像您在HTTP请求中使用的那样），并且您还可以设置不同的处理程序来触发不同请求路径下的操作。' },
    { EN: 'Let’s extend this example act Libevent', CN: '让我们扩展这个示例，使Libevent充当类似Nginx的服务器来托管静态内容：' },
    { EN: 'After that it decoded URI string from something', CN: `如您所见，我们用特定的send_file_to_user()处理程序替换了generic_request_handler()，它用来处理传入的请求：<br>1.首先它检查HTTP命令是否等于GET或HEAD。<br>2.然后它解析请求URI，通过一对evhttp_request_get_uri()/evhttp_uri_parse()函数提取请求路径，并确定我们应当处理的文件路径。<br>3.之后，它将URI字符串从类似folder%2Fmy%20doc.txt的编码形式解码为普通的folder/my doc.txt。` },
  ]
)
